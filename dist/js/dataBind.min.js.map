{"version":3,"file":"dataBind.min.js","sources":["../../src/switchBinding.js","../../src/config.js","../../src/util.js","../../src/domWalker.js","../../src/renderTemplate.js","../../src/clickBinding.js","../../src/dbclickBinding.js","../../src/blurBinding.js","../../src/focusBinding.js","../../src/hoverBinding.js","../../src/changeBinding.js","../../src/modelBinding.js","../../src/submitBinding.js","../../src/textBinding.js","../../src/showBinding.js","../../src/cssBinding.js","../../src/attrBinding.js","../../src/commentWrapper.js","../../src/renderForOfBinding.js","../../src/forOfBinding.js","../../src/renderIfBinding.js","../../src/ifBinding.js","../../src/pubSub.js","../../src/binder.js","../../src/index.js"],"sourcesContent":["import {getViewModelPropValue} from './util';\r\nimport {createClonedElementCache, wrapCommentAround} from './commentWrapper';\r\nimport {renderIfBinding, removeIfBinding} from './renderIfBinding';\r\n/**\r\n * switch-Binding\r\n * @description\r\n * DOM decleartive switch binding.\r\n * switch parent element wrap direct child with case bindings\r\n * @param {object} cache\r\n * @param {object} viewModel\r\n * @param {object} bindingAttrs\r\n */\r\nconst switchBinding = (cache, viewModel, bindingAttrs) => {\r\n    const dataKey = cache.dataKey;\r\n\r\n    if (!dataKey) {\r\n        return;\r\n    }\r\n\r\n    cache.elementData = cache.elementData || {};\r\n\r\n    const newExpression = getViewModelPropValue(viewModel, cache);\r\n\r\n    if (newExpression === cache.elementData.viewModelPropValue) {\r\n        return;\r\n    }\r\n\r\n    cache.elementData.viewModelPropValue = newExpression;\r\n\r\n    // build switch cases if not yet defined\r\n    if (!cache.cases) {\r\n        const childrenElements = cache.el.children;\r\n        if (!childrenElements.length) {\r\n            return;\r\n        }\r\n        cache.cases = [];\r\n        for (let i = 0, elementLength = childrenElements.length; i < elementLength; i += 1) {\r\n            let caseData = null;\r\n            if (childrenElements[i].hasAttribute(bindingAttrs.case)) {\r\n                caseData = createCaseData(childrenElements[i], bindingAttrs.case);\r\n            } else if (childrenElements[i].hasAttribute(bindingAttrs.default)) {\r\n                caseData = createCaseData(childrenElements[i], bindingAttrs.default);\r\n                caseData.isDefault = true;\r\n            }\r\n            // create fragment by clone node\r\n            // wrap with comment tag\r\n            if (caseData) {\r\n                wrapCommentAround(caseData, caseData.el);\r\n                // remove binding attribute for later dataBind parse\r\n                if (caseData.isDefault) {\r\n                    caseData.el.removeAttribute(bindingAttrs.default);\r\n                } else {\r\n                    caseData.el.removeAttribute(bindingAttrs.case);\r\n                }\r\n                createClonedElementCache(caseData);\r\n                cache.cases.push(caseData);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (cache.cases.length) {\r\n        let hasMatch = false;\r\n        // do switch operation - reuse if binding logic\r\n        for (let j = 0, casesLength = cache.cases.length; j < casesLength; j += 1) {\r\n            let newCaseValue;\r\n            if (cache.cases[j].dataKey) {\r\n                // set back to dataKey if nothing found in viewModel\r\n                newCaseValue = getViewModelPropValue(viewModel, cache.cases[j]) || cache.cases[j].dataKey;\r\n            }\r\n\r\n            if (newCaseValue === cache.elementData.viewModelPropValue || cache.cases[j].isDefault) {\r\n                hasMatch = true;\r\n                // render element\r\n                renderIfBinding({\r\n                    bindingData: cache.cases[j],\r\n                    viewModel: viewModel,\r\n                    bindingAttrs: bindingAttrs,\r\n                });\r\n\r\n                // remove other elements\r\n                removeUnmatchCases(cache.cases, j);\r\n                break;\r\n            }\r\n        }\r\n        // no match remove all cases\r\n        if (!hasMatch) {\r\n            removeUnmatchCases(cache.cases);\r\n        }\r\n    }\r\n};\r\n\r\nfunction removeUnmatchCases(cases, matchedIndex) {\r\n    cases.forEach((caseData, index) => {\r\n        if (index !== matchedIndex || typeof matchedIndex === 'undefined') {\r\n            removeIfBinding(caseData);\r\n            // remove cache.IterationBindingCache to prevent memory leak\r\n            if (caseData.hasIterationBindingCache) {\r\n                caseData.iterationBindingCache = null;\r\n                caseData.hasIterationBindingCache = false;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nfunction createCaseData(node, attrName) {\r\n    const caseData = {\r\n        el: node,\r\n        dataKey: node.getAttribute(attrName),\r\n        type: attrName,\r\n    };\r\n    return caseData;\r\n}\r\n\r\nexport default switchBinding;\r\n","const bindingAttrs = {\r\n    comp: 'data-jq-comp',\r\n    tmp: 'data-jq-tmp',\r\n    text: 'data-jq-text',\r\n    click: 'data-jq-click',\r\n    dblclick: 'data-jq-dblclick',\r\n    blur: 'data-jq-blur',\r\n    focus: 'data-jq-focus',\r\n    hover: 'data-jq-hover',\r\n    change: 'data-jq-change',\r\n    submit: 'data-jq-submit',\r\n    model: 'data-jq-model',\r\n    show: 'data-jq-show',\r\n    css: 'data-jq-css',\r\n    attr: 'data-jq-attr',\r\n    forOf: 'data-jq-for',\r\n    if: 'data-jq-if',\r\n    switch: 'data-jq-switch',\r\n    case: 'data-jq-case',\r\n    default: 'data-jq-default',\r\n};\r\nconst serverRenderedAttr = 'data-server-rendered';\r\nconst dataIndexAttr = 'data-index';\r\nconst commentPrefix = {\r\n    forOf: 'data-forOf_',\r\n    if: 'data-if_',\r\n    case: 'data-case_',\r\n    default: 'data-default_',\r\n};\r\nconst commentSuffix = '_end';\r\n\r\n// global setting of underscore template inteprolate default token\r\nconst templateSettings = {\r\n    evaluate: /<%([\\s\\S]+?)%>/g,\r\n    interpolate: /\\{\\{=(.+?)\\}\\}/g,\r\n    escape: /\\{\\{(.+?)\\}\\}/g,\r\n};\r\n\r\nconst bindingDataReference = {\r\n    rootDataKey: '$root',\r\n    currentData: '$data',\r\n    currentIndex: '$index',\r\n    mouseEnterHandlerName: 'in',\r\n    mouseLeaveHandlerName: 'out',\r\n};\r\n\r\nconst bindingUpdateConditions = {\r\n    serverRendered: 'SERVER-RENDERED',\r\n    init: 'INIT',\r\n};\r\n\r\n// maximum string length before running regex\r\nconst maxDatakeyLength = 50;\r\n\r\nconst constants = {\r\n    filters: {\r\n        ONCE: 'once',\r\n    },\r\n    PARENT_REF: '_parent',\r\n};\r\n\r\nexport {\r\n    bindingAttrs,\r\n    dataIndexAttr,\r\n    templateSettings,\r\n    serverRenderedAttr,\r\n    commentPrefix,\r\n    commentSuffix,\r\n    bindingUpdateConditions,\r\n    bindingDataReference,\r\n    maxDatakeyLength,\r\n    constants,\r\n};\r\n","import * as config from './config';\r\n\r\n// require to use lodash\r\n_ = window._ || {};\r\n\r\nconst hasIsArray = Array.isArray;\r\n\r\nconst supportPromise = typeof window['Promise'] === 'function';\r\n\r\nconst REGEX = {\r\n    FUNCTIONPARAM: /\\((.*?)\\)/,\r\n    WHITESPACES: /\\s+/g,\r\n    FOROF: /(.*?)\\s+(?:in|of)\\s+(.*)/,\r\n    PIPE: /\\|/,\r\n};\r\n\r\nconst generateElementCache = (bindingAttrs) => {\r\n    const elementCache = {};\r\n    $.each(bindingAttrs, function(k, v) {\r\n        elementCache[v] = [];\r\n    });\r\n    return elementCache;\r\n};\r\n\r\nconst isArray = (obj) => {\r\n    return hasIsArray ? Array.isArray(obj) : Object.prototype.toString.call(obj) === '[object Array]';\r\n};\r\n\r\nconst isJsObject = (obj) => {\r\n    return obj !== null && typeof obj === 'object' && Object.prototype.toString.call(obj) === '[object Object]';\r\n};\r\n\r\nconst isPlainObject = (obj) => {\r\n    if (!isJsObject(obj)) {\r\n        return false;\r\n    }\r\n\r\n    // If has modified constructor\r\n    const ctor = obj.constructor;\r\n    if (typeof ctor !== 'function') return false;\r\n\r\n    // If has modified prototype\r\n    const prot = ctor.prototype;\r\n    if (isJsObject(prot) === false) return false;\r\n\r\n    // If constructor does not have an Object-specific method\r\n    if (prot.hasOwnProperty('isPrototypeOf') === false) {\r\n        return false;\r\n    }\r\n\r\n    // Most likely a plain Object\r\n    return true;\r\n};\r\n\r\nconst isEmptyObject = (obj) => {\r\n    if (isJsObject(obj)) {\r\n        return Object.getOwnPropertyNames(obj).length === 0;\r\n    }\r\n    return false;\r\n};\r\n\r\n/**\r\n * getViewModelValue\r\n * @description walk a object by provided string path. eg 'a.b.c'\r\n * @param {object} viewModel\r\n * @param {string} prop\r\n * @return {object}\r\n */\r\nconst getViewModelValue = (viewModel, prop) => {\r\n    return _.get(viewModel, prop);\r\n};\r\n\r\n/**\r\n * setViewModelValue\r\n * @description populate viewModel object by path string\r\n * @param {object} obj\r\n * @param {string} prop\r\n * @param {string} value\r\n * @return {call} underscore set\r\n */\r\nconst setViewModelValue = (obj, prop, value) => {\r\n    return _.set(obj, prop, value);\r\n};\r\n\r\nconst getViewModelPropValue = (viewModel, bindingCache) => {\r\n    let dataKey = bindingCache.dataKey;\r\n    let paramList = bindingCache.parameters;\r\n    const isInvertBoolean = dataKey.charAt(0) === '!';\r\n\r\n    if (isInvertBoolean) {\r\n        dataKey = isInvertBoolean ? dataKey.substring(1) : dataKey;\r\n    }\r\n\r\n    let ret = getViewModelValue(viewModel, dataKey);\r\n\r\n    if (typeof ret === 'function') {\r\n        const viewModelContext = resolveViewModelContext(viewModel, dataKey);\r\n        const oldViewModelProValue = bindingCache.elementData ? bindingCache.elementData.viewModelProValue : null;\r\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\r\n        // let args = [oldViewModelProValue, bindingCache.el].concat(paramList);\r\n        const args = paramList.concat([oldViewModelProValue, bindingCache.el]);\r\n        ret = ret.apply(viewModelContext, args);\r\n    }\r\n\r\n    ret = isInvertBoolean ? !Boolean(ret) : ret;\r\n\r\n    // call through fitlers to get final value\r\n    ret = filtersViewModelPropValue({\r\n        value: ret,\r\n        viewModel: viewModel,\r\n        bindingCache: bindingCache,\r\n    });\r\n\r\n    return ret;\r\n};\r\n\r\nconst filtersViewModelPropValue = ({value, viewModel, bindingCache}) => {\r\n    let ret = value;\r\n    if (bindingCache.filters) {\r\n        each(bindingCache.filters, (index, filter) => {\r\n            const viewModelContext = resolveViewModelContext(viewModel, filter);\r\n            const filterFn = getViewModelValue.call(viewModelContext, viewModelContext, filter);\r\n            try {\r\n                ret = filterFn.call(viewModelContext, ret);\r\n            } catch (err) {\r\n                throwErrorMessage(err, `Invalid filter: ${filter}`);\r\n            }\r\n        });\r\n    }\r\n    return ret;\r\n};\r\n\r\nconst parseStringToJson = (str) => {\r\n    // fix unquote or single quote keys and replace single quote to double quote\r\n    const ret = str.replace(/(\\s*?{\\s*?|\\s*?,\\s*?)(['\"])?([a-zA-Z0-9]+)(['\"])?:/g, '$1\"$3\":').replace(/'/g, '\"');\r\n    return JSON.parse(ret);\r\n};\r\n\r\n/**\r\n * arrayRemoveMatch\r\n * @description remove match items in fromArray out of toArray\r\n * @param {array} toArray\r\n * @param {array} frommArray\r\n * @return {boolean}\r\n */\r\nconst arrayRemoveMatch = (toArray, frommArray) => {\r\n    return toArray.filter((value, index) => {\r\n        return frommArray.indexOf(value) < 0;\r\n    });\r\n};\r\n\r\nconst getFormData = ($form) => {\r\n    const sArray = $form.serializeArray();\r\n    const data = {};\r\n\r\n    sArray.map((n) => {\r\n        data[n['name']] = n['value'];\r\n    });\r\n\r\n    return data;\r\n};\r\n\r\n/**\r\n * getFunctionParameterList\r\n * @description convert parameter string to arrary\r\n * eg. '(\"a\",\"b\",\"c\")' > [\"a\",\"b\",\"c\"]\r\n * @param {string} str\r\n * @return {array} paramlist\r\n */\r\nconst getFunctionParameterList = (str) => {\r\n    if (!str || str.length > config.maxDatakeyLength) {\r\n        return;\r\n    }\r\n    let paramlist = str.match(REGEX.FUNCTIONPARAM);\r\n\r\n    if (paramlist && paramlist[1]) {\r\n        paramlist = paramlist[1].split(',');\r\n        paramlist.forEach(function(v, i) {\r\n            paramlist[i] = v.trim();\r\n        });\r\n    }\r\n    return paramlist;\r\n};\r\n\r\nconst extractFilterList = (cacheData) => {\r\n    if (!cacheData || !cacheData.dataKey || cacheData.dataKey.length > config.maxDatakeyLength) {\r\n        return cacheData;\r\n    }\r\n    const filterList = cacheData.dataKey.split(REGEX.PIPE);\r\n    let isOnceIndex;\r\n    cacheData.dataKey = filterList[0].trim();\r\n    if (filterList.length > 1) {\r\n        filterList.shift(0);\r\n        filterList.forEach(function(v, i) {\r\n            filterList[i] = v.trim();\r\n            if (filterList[i] === config.constants.filters.ONCE) {\r\n                cacheData.isOnce = true;\r\n                isOnceIndex = i;\r\n            }\r\n        });\r\n        // don't store filter 'once' - because it is internal logic not a property from viewModel\r\n        if (isOnceIndex >= 0) {\r\n            filterList.splice(isOnceIndex, 1);\r\n        }\r\n        cacheData.filters = filterList;\r\n    }\r\n    return cacheData;\r\n};\r\n\r\nconst invertObj = (sourceObj) => {\r\n    return Object.keys(sourceObj).reduce(function(obj, key) {\r\n        obj[sourceObj[key]] = key;\r\n        return obj;\r\n    }, {});\r\n};\r\n\r\nconst createDeferredObj = () => {\r\n    let dfObj = {};\r\n    if (supportPromise) {\r\n        dfObj.promise = new Promise((resolve, reject) => {\r\n            dfObj.resolve = resolve;\r\n            dfObj.reject = reject;\r\n        });\r\n    } else {\r\n        dfObj = $.Deferred(); // eslint-disable-line new-cap\r\n    }\r\n    return dfObj;\r\n};\r\n\r\n/**\r\n * debounce\r\n * @description decorate a function to be debounce using requestAnimationFrame\r\n * @param {function} fn\r\n * @param {context} ctx\r\n * @return {function}\r\n */\r\nconst debounceRaf = (fn, ctx = null) => {\r\n    return (function(fn, ctx) {\r\n        let dfObj = createDeferredObj();\r\n        let rafId = 0;\r\n\r\n        // return decorated fn\r\n        return function() {\r\n            /* eslint-disable prefer-rest-params */\r\n            const args = Array.from ? Array.from(arguments) : Array.prototype.slice.call(arguments);\r\n\r\n            window.cancelAnimationFrame(rafId);\r\n            rafId = window.requestAnimationFrame(() => {\r\n                try {\r\n                    // fn is Binder.render function\r\n                    fn.apply(ctx, args);\r\n                    // dfObj.resolve is function provided in .then promise chain\r\n                    // ctx is the current component\r\n                    dfObj.resolve(ctx);\r\n                } catch (err) {\r\n                    dfObj.reject(ctx, err);\r\n                }\r\n\r\n                // reset dfObj - otherwise then callbacks will not be in execution order\r\n                // example:\r\n                // myApp.render().then(function(){console.log('ok1')});\r\n                // myApp.render().then(function(){console.log('ok2')});\r\n                // myApp.render().then(function(){console.log('ok3')});\r\n                // >> ok1, ok2, ok3\r\n                dfObj = createDeferredObj();\r\n\r\n                window.cancelAnimationFrame(rafId);\r\n            });\r\n\r\n            /* eslint-enable prefer-rest-params */\r\n            return supportPromise ? dfObj.promise : dfObj.promise();\r\n        };\r\n    })(fn, ctx);\r\n};\r\n\r\n/**\r\n * getNodeAttrObj\r\n * @description convert Node attributes object to a json object\r\n * @param {object} node\r\n * @param {array} skipList\r\n * @return {object}\r\n */\r\nconst getNodeAttrObj = (node, skipList) => {\r\n    let attributesLength = 0;\r\n    let skipArray;\r\n\r\n    if (!node || node.nodeType !== 1 || !node.hasAttributes()) {\r\n        return;\r\n    }\r\n    if (skipList) {\r\n        skipArray = [];\r\n        skipArray = typeof skipList === 'string' ? skipArray.push(skipList) : skipList;\r\n    }\r\n    const attrObj = {};\r\n    attributesLength = node.attributes.length;\r\n\r\n    if (attributesLength) {\r\n        for (let i = 0; i < attributesLength; i += 1) {\r\n            const attribute = node.attributes.item(i);\r\n            attrObj[attribute.nodeName] = attribute.nodeValue;\r\n        }\r\n    }\r\n\r\n    if (isArray(skipArray)) {\r\n        skipArray.forEach((item) => {\r\n            if (attrObj[item]) {\r\n                delete attrObj[item];\r\n            }\r\n        });\r\n    }\r\n    return attrObj;\r\n};\r\n\r\n/**\r\n * extend\r\n * @param {boolean} isDeepMerge\r\n * @param {object} target\r\n * @param {object} sources\r\n * @return {object} merged object\r\n */\r\nconst extend = (isDeepMerge = false, target, ...sources) => {\r\n    if (!sources.length) {\r\n        return target;\r\n    }\r\n    const source = sources.shift();\r\n    if (source === undefined) {\r\n        return target;\r\n    }\r\n\r\n    if (!isDeepMerge) {\r\n        return Object.assign(target, ...sources);\r\n    }\r\n\r\n    if (isMergebleObject(target) && isMergebleObject(source)) {\r\n        Object.keys(source).forEach((key) => {\r\n            if (isMergebleObject(source[key])) {\r\n                if (!target[key]) {\r\n                    target[key] = {};\r\n                }\r\n                extend(target[key], source[key]);\r\n            } else {\r\n                target[key] = source[key];\r\n            }\r\n        });\r\n    }\r\n\r\n    return extend(true, target, ...sources);\r\n};\r\n\r\nconst each = (obj, fn) => {\r\n    if (typeof obj !== 'object' || typeof fn !== 'function') {\r\n        return;\r\n    }\r\n    let keys = [];\r\n    let keysLength = 0;\r\n    const isArrayObj = isArray(obj);\r\n    let key;\r\n    let value;\r\n    let i = 0;\r\n\r\n    if (isArrayObj) {\r\n        keysLength = obj.length;\r\n    } else if (isJsObject(obj)) {\r\n        keys = Object.keys(obj);\r\n        keysLength = keys.length;\r\n    } else {\r\n        throw new TypeError('Object is not an array or object');\r\n    }\r\n\r\n    for (i = 0; i < keysLength; i += 1) {\r\n        if (isArrayObj) {\r\n            key = i;\r\n            value = obj[i];\r\n        } else {\r\n            key = keys[i];\r\n            value = obj[key];\r\n        }\r\n        fn(key, value);\r\n    }\r\n};\r\n\r\nconst isMergebleObject = (item) => {\r\n    return isJsObject(item) && !isArray(item);\r\n};\r\n\r\n/**\r\n * cloneDomNode\r\n * @param {object} element\r\n * @return {object} cloned element\r\n * @description helper function to clone node\r\n */\r\nconst cloneDomNode = (element) => {\r\n    return element.cloneNode(true);\r\n};\r\n\r\n/**\r\n * insertAfter\r\n * @param {object} parentNode\r\n * @param {object} newNode\r\n * @param {object} referenceNode\r\n * @return {object} node\r\n * @description helper function to insert new node before the reference node\r\n */\r\nconst insertAfter = (parentNode, newNode, referenceNode) => {\r\n    const refNextElement = referenceNode && referenceNode.nextSibling ? referenceNode.nextSibling : null;\r\n    return parentNode.insertBefore(newNode, refNextElement);\r\n};\r\n\r\nconst resolveViewModelContext = (viewModel, datakey) => {\r\n    let ret = viewModel;\r\n    if (typeof datakey !== 'string') {\r\n        return ret;\r\n    }\r\n    const bindingDataContext = datakey.split('.');\r\n    if (bindingDataContext.length > 1) {\r\n        if (bindingDataContext[0] === config.bindingDataReference.rootDataKey) {\r\n            ret = viewModel[config.bindingDataReference.rootDataKey] || viewModel;\r\n        } else if (bindingDataContext[0] === config.bindingDataReference.currentData) {\r\n            ret = viewModel[config.bindingDataReference.currentData] || viewModel;\r\n        }\r\n    }\r\n    return ret;\r\n};\r\n\r\nconst resolveParamList = (viewModel, paramList) => {\r\n    if (!viewModel || !isArray(paramList)) {\r\n        return;\r\n    }\r\n    return paramList.map((param) => {\r\n        param = param.trim();\r\n\r\n        if (param === config.bindingDataReference.currentIndex) {\r\n            // convert '$index' to value\r\n            param = viewModel[config.bindingDataReference.currentIndex];\r\n        } else if (param === config.bindingDataReference.currentData) {\r\n            // convert '$data' to value or current viewModel\r\n            param = viewModel[config.bindingDataReference.currentData] || viewModel;\r\n        } else if (param === config.bindingDataReference.rootDataKey) {\r\n            // convert '$root' to root viewModel\r\n            param = viewModel[config.bindingDataReference.rootDataKey] || viewModel;\r\n        }\r\n        return param;\r\n    });\r\n};\r\n\r\nconst removeElement = (el) => {\r\n    if (el && el.parentNode) {\r\n        el.parentNode.removeChild(el);\r\n    }\r\n};\r\n\r\nconst throwErrorMessage = (err = null, errorMessage = '') => {\r\n    const message = err && err.message ? err.message : errorMessage;\r\n    if (typeof console.error === 'function') {\r\n        return console.error(message);\r\n    }\r\n    return console.log(message);\r\n};\r\n\r\nexport {\r\n    REGEX,\r\n    arrayRemoveMatch,\r\n    cloneDomNode,\r\n    debounceRaf,\r\n    each,\r\n    extend,\r\n    extractFilterList,\r\n    generateElementCache,\r\n    getFormData,\r\n    getFunctionParameterList,\r\n    getNodeAttrObj,\r\n    getViewModelPropValue,\r\n    getViewModelValue,\r\n    insertAfter,\r\n    invertObj,\r\n    isArray,\r\n    isEmptyObject,\r\n    isJsObject,\r\n    isPlainObject,\r\n    parseStringToJson,\r\n    removeElement,\r\n    resolveParamList,\r\n    resolveViewModelContext,\r\n    setViewModelValue,\r\n    throwErrorMessage,\r\n};\r\n","import {invertObj, extractFilterList, getFunctionParameterList, REGEX} from './util';\r\nimport {constants} from './config';\r\n\r\nlet bindingAttrsMap;\r\n\r\n/**\r\n * walkDOM\r\n * @description by Douglas Crockford - walk each DOM node and calls provided callback function\r\n * start walk from firstChild\r\n * @param {object} node\r\n * @param {function} func\r\n */\r\nconst walkDOM = (node, func) => {\r\n    let parseChildNode = true;\r\n    node = node.firstElementChild;\r\n    while (node) {\r\n        parseChildNode = func(node);\r\n        if (parseChildNode) {\r\n            walkDOM(node, func);\r\n        }\r\n        node = node.nextElementSibling;\r\n    }\r\n};\r\n\r\nconst getAttributesObject = (node) => {\r\n    const ret = {};\r\n    Array.prototype.slice.call(node.attributes).forEach((item) => {\r\n        ret[item.name] = item.value;\r\n    });\r\n    return ret;\r\n};\r\n\r\nconst checkSkipChildParseBindings = (attrObj = {}, bindingAttrs) => {\r\n    return [bindingAttrs.forOf, bindingAttrs.if, bindingAttrs.case, bindingAttrs.default].filter((type) => {\r\n        return typeof attrObj[type] !== 'undefined';\r\n    });\r\n};\r\n\r\nconst rootSkipCheck = (node) => {\r\n    return node.tagName === 'SVG';\r\n};\r\n\r\nconst defaultSkipCheck = (node, bindingAttrs) => {\r\n    return node.tagName === 'SVG' || node.hasAttribute(bindingAttrs.comp);\r\n};\r\n\r\nconst populateBindingCache = ({node, attrObj, bindingCache, type}) => {\r\n    let attrValue;\r\n    let cacheData;\r\n\r\n    if (bindingAttrsMap && bindingAttrsMap[type] && typeof attrObj[type] !== 'undefined') {\r\n        bindingCache[type] = bindingCache[type] || [];\r\n        attrValue = attrObj[type].trim();\r\n        cacheData = {\r\n            el: node,\r\n            dataKey: attrValue,\r\n        };\r\n\r\n        // populate cacheData.filters. update filterList first item as dataKey\r\n        cacheData = extractFilterList(cacheData);\r\n\r\n        // populate cacheData.parameters\r\n        // for store function call parameters eg. '$index', '$root'\r\n        // useful with DOM for-loop template as reference to binding data\r\n        const paramList = getFunctionParameterList(cacheData.dataKey);\r\n        if (paramList) {\r\n            cacheData.parameters = paramList;\r\n            cacheData.dataKey = cacheData.dataKey.replace(REGEX.FUNCTIONPARAM, '').trim();\r\n        }\r\n        // store parent array reference to cacheData\r\n        cacheData[constants.PARENT_REF] = bindingCache[type];\r\n        bindingCache[type].push(cacheData);\r\n    }\r\n    return bindingCache;\r\n};\r\n\r\nconst createBindingCache = ({rootNode = null, bindingAttrs = {}, skipCheck, isRenderedTemplate = false}) => {\r\n    let bindingCache = {};\r\n\r\n    if (!rootNode instanceof window.Node) {\r\n        throw new TypeError('walkDOM: Expected a DOM node');\r\n    }\r\n\r\n    bindingAttrsMap = bindingAttrsMap || invertObj(bindingAttrs);\r\n\r\n    const parseNode = (node, skipNodeCheckFn = defaultSkipCheck) => {\r\n        let isSkipForOfChild = false;\r\n\r\n        if (node.nodeType !== 1 || !node.hasAttributes()) {\r\n            return true;\r\n        }\r\n        if (skipNodeCheckFn(node, bindingAttrs) || (typeof skipCheck === 'function' && skipCheck(node))) {\r\n            return false;\r\n        }\r\n\r\n        // when creating sub bindingCache if is for tmp binding\r\n        // skip same element that has forOf binding the  forOf is alredy parsed\r\n        const attrObj = getAttributesObject(node);\r\n        const hasSkipChildParseBindings = checkSkipChildParseBindings(attrObj, bindingAttrs);\r\n        let iterateList = [];\r\n\r\n        if (hasSkipChildParseBindings.length) {\r\n            isSkipForOfChild = true;\r\n            iterateList = hasSkipChildParseBindings;\r\n        } else if (isRenderedTemplate && attrObj[bindingAttrs.tmp]) {\r\n            // skip current node parse if was called by node has template binding and already rendered\r\n            return true;\r\n        } else {\r\n            iterateList = Object.keys(attrObj);\r\n        }\r\n\r\n        iterateList.forEach((key) => {\r\n            // skip for switch case and default bining\r\n            if (key !== bindingAttrs.case && key !== bindingAttrs.default) {\r\n                bindingCache = populateBindingCache({\r\n                    node: node,\r\n                    attrObj: attrObj,\r\n                    bindingCache: bindingCache,\r\n                    type: key,\r\n                });\r\n            }\r\n        });\r\n\r\n        // after cache forOf skip parse child nodes\r\n        if (isSkipForOfChild) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    };\r\n\r\n    if (parseNode(rootNode, rootSkipCheck)) {\r\n        walkDOM(rootNode, parseNode);\r\n    }\r\n    return bindingCache;\r\n};\r\n\r\nexport default createBindingCache;\r\n","import {dataIndexAttr} from './config';\r\nimport {parseStringToJson, getViewModelPropValue} from './util';\r\n\r\nlet $domFragment = null;\r\nlet $templateRoot = null;\r\nlet nestTemplatesCount = 0;\r\nconst templateCache = {};\r\n\r\n/**\r\n * compileTemplate\r\n * @description compile underscore template and store in templateCache\r\n * @param {string} id\r\n * @param {object} templateData\r\n * @return {string} rendered html string\r\n */\r\nconst compileTemplate = (id, templateData = null) => {\r\n    let templateString;\r\n    let templateElement;\r\n\r\n    if (!templateCache[id]) {\r\n        templateElement = document.getElementById(id);\r\n        templateString = templateElement ? templateElement.innerHTML : '';\r\n        templateCache[id] = _.template(templateString, {\r\n            variable: 'data',\r\n        });\r\n    }\r\n\r\n    return templateCache[id](templateData);\r\n};\r\n\r\n/**\r\n * renderTemplate\r\n * @description\r\n * get template setting from DOM attribute then call compileTemplate\r\n * to render and append to target DOM\r\n * @param {object} cache\r\n * @param {object} viewModel\r\n * @param {object} bindingAttrs\r\n * @param {object} elementCache\r\n */\r\nconst renderTemplate = (cache, viewModel, bindingAttrs, elementCache) => {\r\n    const settings = typeof cache.dataKey === 'string' ? parseStringToJson(cache.dataKey) : cache.dataKey;\r\n    let viewData = settings.data;\r\n    const isAppend = settings.append;\r\n    const isPrepend = settings.prepend;\r\n    let $currentElement;\r\n\r\n    cache.dataKey = settings;\r\n\r\n    viewData =\r\n        typeof viewData === 'undefined' || viewData === '$root'\r\n            ? viewModel\r\n            : getViewModelPropValue(viewModel, {\r\n                dataKey: settings.data,\r\n                parameters: cache.parameters,\r\n            });\r\n\r\n    if (!viewData) {\r\n        return;\r\n    }\r\n\r\n    const $element = $(cache.el);\r\n    const $index = typeof viewModel.$index !== 'undefined' ? viewModel.$index : $element.attr(dataIndexAttr);\r\n    if (typeof $index !== 'undefined') {\r\n        viewData.$index = $index;\r\n    }\r\n    $domFragment = $domFragment ? $domFragment : $('<div/>');\r\n    $templateRoot = $templateRoot ? $templateRoot : $element;\r\n    const html = compileTemplate(settings.id, viewData);\r\n\r\n    // domFragment should be empty in first run\r\n    // append rendered html\r\n    if (!$domFragment.children().length) {\r\n        $currentElement = $domFragment;\r\n        $domFragment.append(html);\r\n    } else {\r\n        $currentElement = $element;\r\n        if (!isAppend && !isPrepend) {\r\n            $currentElement.empty();\r\n        }\r\n        if (isPrepend) {\r\n            $currentElement.prepend(html);\r\n        } else {\r\n            $currentElement.append(html);\r\n        }\r\n    }\r\n\r\n    // check if there are nested template then recurisive render them\r\n    const $nestedTemplates = $currentElement.find('[' + bindingAttrs.tmp + ']');\r\n\r\n    if ($nestedTemplates.length) {\r\n        nestTemplatesCount += $nestedTemplates.length;\r\n        $nestedTemplates.each(function(index, element) {\r\n            const thisTemplateCache = {\r\n                el: element,\r\n                dataKey: element.getAttribute(bindingAttrs.tmp),\r\n            };\r\n            elementCache[bindingAttrs.tmp].push(thisTemplateCache);\r\n            // recursive template render\r\n            renderTemplate(thisTemplateCache, viewModel, bindingAttrs, elementCache);\r\n            nestTemplatesCount -= 1;\r\n        });\r\n    }\r\n\r\n    // no more nested tempalted to render, start to append $domFragment into $templateRoot\r\n    if (nestTemplatesCount === 0) {\r\n        // append to DOM once\r\n        if (!isAppend && !isPrepend) {\r\n            $templateRoot.empty();\r\n        }\r\n        if (isPrepend) {\r\n            $templateRoot.prepend($domFragment.html());\r\n        } else {\r\n            $templateRoot.append($domFragment.html());\r\n        }\r\n        // clear cached fragment\r\n        $domFragment = $templateRoot = null;\r\n        // trigger callback if provided\r\n        if (typeof viewModel.afterTemplateRender === 'function') {\r\n            viewModel.afterTemplateRender(viewData);\r\n        }\r\n    }\r\n};\r\n\r\nexport default renderTemplate;\r\n","/* eslint-disable no-invalid-this */\r\nimport {getViewModelValue, resolveViewModelContext, resolveParamList} from './util';\r\n\r\n/**\r\n * clickBinding\r\n * @description\r\n * DOM decleartive click event binding\r\n * event handler bind to viewModel method according to the DOM attribute\r\n * @param {object} cache\r\n * @param {object} viewModel\r\n * @param {object} bindingAttrs\r\n * @param {boolean} forceRender\r\n */\r\nconst clickBinding = (cache, viewModel, bindingAttrs, forceRender) => {\r\n    const handlerName = cache.dataKey;\r\n    let paramList = cache.parameters;\r\n    let viewModelContext;\r\n    const APP = viewModel.APP || viewModel.$root.APP;\r\n\r\n    if (!handlerName || (!forceRender && !APP.$rootElement.contains(cache.el))) {\r\n        return;\r\n    }\r\n\r\n    const handlerFn = getViewModelValue(viewModel, handlerName);\r\n\r\n    if (typeof handlerFn === 'function') {\r\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\r\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\r\n        $(cache.el)\r\n            .off('click.databind')\r\n            .on('click.databind', function(e) {\r\n                const args = [e, $(this)].concat(paramList);\r\n                handlerFn.apply(viewModelContext, args);\r\n            });\r\n    }\r\n};\r\n\r\nexport default clickBinding;\r\n","/* eslint-disable no-invalid-this */\r\nimport {getViewModelValue, resolveViewModelContext, resolveParamList} from './util';\r\n\r\n/**\r\n * dblclickBinding\r\n * DOM decleartive double click event binding\r\n * event handler bind to viewModel method according to the DOM attribute\r\n * @param {object} cache\r\n * @param {object} viewModel\r\n * @param {object} bindingAttrs\r\n * @param {boolean} forceRender\r\n */\r\nconst dblclickBinding = (cache, viewModel, bindingAttrs, forceRender) => {\r\n    const handlerName = cache.dataKey;\r\n    let paramList = cache.parameters;\r\n    let viewModelContext;\r\n    const APP = viewModel.APP || viewModel.$root.APP;\r\n\r\n    if (!handlerName || (!forceRender && !APP.$rootElement.contains(cache.el))) {\r\n        return;\r\n    }\r\n\r\n    const handlerFn = getViewModelValue(viewModel, handlerName);\r\n\r\n    if (typeof handlerFn === 'function') {\r\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\r\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\r\n        $(cache.el)\r\n            .off('dblclick.databind')\r\n            .on('dblclick.databind', function(e) {\r\n                const args = [e, $(this)].concat(paramList);\r\n                handlerFn.apply(viewModelContext, args);\r\n            });\r\n    }\r\n};\r\n\r\nexport default dblclickBinding;\r\n","/* eslint-disable no-invalid-this */\r\nimport {getViewModelValue, resolveViewModelContext, resolveParamList} from './util';\r\n\r\n/**\r\n * blurBinding\r\n * DOM decleartive on blur event binding\r\n * event handler bind to viewModel method according to the DOM attribute\r\n * @param {object} cache\r\n * @param {object} viewModel\r\n * @param {object} bindingAttrs\r\n * @param {boolean} forceRender\r\n */\r\nconst blurBinding = (cache, viewModel, bindingAttrs, forceRender) => {\r\n    const handlerName = cache.dataKey;\r\n    let paramList = cache.parameters;\r\n    let viewModelContext;\r\n    const APP = viewModel.APP || viewModel.$root.APP;\r\n\r\n    if (!handlerName || (!forceRender && !APP.$rootElement.contains(cache.el))) {\r\n        return;\r\n    }\r\n\r\n    const handlerFn = getViewModelValue(viewModel, handlerName);\r\n\r\n    if (typeof handlerFn === 'function') {\r\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\r\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\r\n\r\n        $(cache.el)\r\n            .off('blur.databind')\r\n            .on('blur.databind', function(e) {\r\n                const args = [e, $(this)].concat(paramList);\r\n                handlerFn.apply(viewModelContext, args);\r\n            });\r\n    }\r\n};\r\n\r\nexport default blurBinding;\r\n","/* eslint-disable no-invalid-this */\r\nimport {getViewModelValue, resolveViewModelContext, resolveParamList} from './util';\r\n\r\n/**\r\n * focusBinding\r\n * DOM decleartive on focus event binding\r\n * event handler bind to viewModel method according to the DOM attribute\r\n * @param {object} cache\r\n * @param {object} viewModel\r\n * @param {object} bindingAttrs\r\n * @param {boolean} forceRender\r\n */\r\nconst focusBinding = (cache, viewModel, bindingAttrs, forceRender) => {\r\n    const handlerName = cache.dataKey;\r\n    let paramList = cache.parameters;\r\n    let viewModelContext;\r\n    const APP = viewModel.APP || viewModel.$root.APP;\r\n\r\n    if (!handlerName || (!forceRender && !APP.$rootElement.contains(cache.el))) {\r\n        return;\r\n    }\r\n\r\n    const handlerFn = getViewModelValue(viewModel, handlerName);\r\n\r\n    if (typeof handlerFn === 'function') {\r\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\r\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\r\n        $(cache.el)\r\n            .off('focus.databind')\r\n            .on('focus.databind', function(e) {\r\n                const args = [e, $(this)].concat(paramList);\r\n                handlerFn.apply(viewModelContext, args);\r\n            });\r\n    }\r\n};\r\n\r\nexport default focusBinding;\r\n","/* eslint-disable no-invalid-this */\r\nimport {bindingDataReference} from './config';\r\nimport {getViewModelValue, resolveViewModelContext, resolveParamList} from './util';\r\n\r\n/**\r\n * blurBinding\r\n * DOM decleartive on blur event binding\r\n * event handler bind to viewModel method according to the DOM attribute\r\n * @param {object} cache\r\n * @param {object} viewModel\r\n * @param {object} bindingAttrs\r\n * @param {boolean} forceRender\r\n */\r\nconst hoverBinding = (cache, viewModel, bindingAttrs, forceRender) => {\r\n    const handlerName = cache.dataKey;\r\n    let paramList = cache.parameters;\r\n    const inHandlerName = bindingDataReference.mouseEnterHandlerName;\r\n    const outHandlerName = bindingDataReference.mouseLeaveHandlerName;\r\n    let viewModelContext;\r\n    const APP = viewModel.APP || viewModel.$root.APP;\r\n\r\n    cache.elementData = cache.elementData || {};\r\n\r\n    if (!handlerName || (!forceRender && !APP.$rootElement.contains(cache.el))) {\r\n        return;\r\n    }\r\n\r\n    const handlers = getViewModelValue(viewModel, handlerName);\r\n\r\n    if (handlers && typeof handlers[inHandlerName] === 'function' && typeof handlers[outHandlerName] === 'function') {\r\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\r\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\r\n\r\n        $(cache.el)\r\n            .off('mouseenter.databind mouseleave.databind')\r\n            .hover(\r\n                function enter(e) {\r\n                    const args = [e, cache.el].concat(paramList);\r\n                    handlers[inHandlerName].apply(viewModelContext, args);\r\n                },\r\n                function leave(e) {\r\n                    const args = [e, cache.el].concat(paramList);\r\n                    handlers[outHandlerName].apply(viewModelContext, args);\r\n                }\r\n            );\r\n    }\r\n};\r\n\r\nexport default hoverBinding;\r\n","/* eslint-disable no-invalid-this */\r\nimport {getViewModelValue, setViewModelValue, resolveViewModelContext, resolveParamList} from './util';\r\n\r\n/**\r\n * changeBinding\r\n * @description input element on change event binding. DOM -> viewModel update\r\n * @param {object} cache\r\n * @param {object} viewModel\r\n * @param {object} bindingAttrs\r\n * @param {boolean} forceRender\r\n */\r\nconst changeBinding = (cache, viewModel, bindingAttrs, forceRender) => {\r\n    const handlerName = cache.dataKey;\r\n    let paramList = cache.parameters;\r\n    const modelDataKey = cache.el.getAttribute(bindingAttrs.model);\r\n    let newValue = '';\r\n    let oldValue = '';\r\n    let viewModelContext;\r\n    const APP = viewModel.APP || viewModel.$root.APP;\r\n\r\n    if (!handlerName || (!forceRender && !APP.$rootElement.contains(cache.el))) {\r\n        return;\r\n    }\r\n\r\n    const handlerFn = getViewModelValue(viewModel, handlerName);\r\n\r\n    if (typeof handlerFn === 'function') {\r\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\r\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\r\n\r\n        // assing on change event\r\n        $(cache.el)\r\n            .off('change.databind')\r\n            .on('change.databind', function(e) {\r\n                const $this = $(this);\r\n                const isCheckbox = $this.is(':checkbox');\r\n                newValue = isCheckbox ? $this.prop('checked') : _.escape($this.val());\r\n                // set data to viewModel\r\n                if (modelDataKey) {\r\n                    oldValue = getViewModelValue(viewModel, modelDataKey);\r\n                    setViewModelValue(viewModel, modelDataKey, newValue);\r\n                }\r\n                const args = [e, $this, newValue, oldValue].concat(paramList);\r\n                handlerFn.apply(viewModelContext, args);\r\n                oldValue = newValue;\r\n            });\r\n    }\r\n};\r\n\r\nexport default changeBinding;\r\n","import {getViewModelValue} from './util';\r\n\r\n/**\r\n * modelBinding\r\n * @description input element data binding. viewModel -> DOM update\r\n * @param {object} cache\r\n * @param {object} viewModel\r\n * @param {object} bindingAttrs\r\n * @param {boolean} forceRender\r\n */\r\nconst modelBinding = (cache, viewModel, bindingAttrs, forceRender) => {\r\n    const dataKey = cache.dataKey;\r\n    let newValue = '';\r\n    const APP = viewModel.APP || viewModel.$root.APP;\r\n\r\n    if (!dataKey || (!forceRender && !APP.$rootElement.contains(cache.el))) {\r\n        return;\r\n    }\r\n\r\n    newValue = getViewModelValue(viewModel, dataKey);\r\n\r\n    if (typeof newValue !== 'undefined' && newValue !== null) {\r\n        const $element = $(cache.el);\r\n        const isCheckbox = $element.is(':checkbox');\r\n        const isRadio = $element.is(':radio');\r\n        const inputName = $element[0].name;\r\n        const $radioGroup = isRadio ? $('input[name=\"' + inputName + '\"]') : null;\r\n        const oldValue = isCheckbox ? $element.prop('checked') : $element.val();\r\n\r\n        // update element value\r\n        if (newValue !== oldValue) {\r\n            if (isCheckbox) {\r\n                $element.prop('checked', Boolean(newValue));\r\n            } else if (isRadio) {\r\n                $radioGroup.val([newValue]);\r\n            } else {\r\n                $element.val(newValue);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nexport default modelBinding;\r\n","import {getViewModelValue, resolveViewModelContext, resolveParamList, getFormData} from './util';\r\n\r\n/**\r\n * submitBinding\r\n * @description on form submit binding. pass current form data as json object to handler\r\n * @param {object} cache\r\n * @param {object} viewModel\r\n * @param {object} bindingAttrs\r\n * @param {boolean} forceRender\r\n */\r\nconst submitBinding = (cache, viewModel, bindingAttrs, forceRender) => {\r\n    const handlerName = cache.dataKey;\r\n    let paramList = cache.parameters;\r\n    let viewModelContext;\r\n    const APP = viewModel.APP || viewModel.$root.APP;\r\n\r\n    if (!handlerName || (!forceRender && !APP.$rootElement.contains(cache.el))) {\r\n        return;\r\n    }\r\n\r\n    const handlerFn = getViewModelValue(viewModel, handlerName);\r\n    const $element = $(cache.el);\r\n\r\n    if (typeof handlerFn === 'function') {\r\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\r\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\r\n        // assing on change event\r\n        $element.off('submit.databind').on('submit.databind', function(e) {\r\n            const args = [e, $element, getFormData($element)].concat(paramList);\r\n            handlerFn.apply(viewModelContext, args);\r\n        });\r\n    }\r\n};\r\n\r\nexport default submitBinding;\r\n","import {getViewModelPropValue} from './util';\r\n\r\n/**\r\n * textBinding\r\n * * @description\r\n * DOM decleartive text binding update dom textnode with viewModel data\r\n * @param {object} cache\r\n * @param {object} viewModel\r\n * @param {object} bindingAttrs\r\n * @param {boolean} forceRender\r\n */\r\nconst textBinding = (cache, viewModel, bindingAttrs, forceRender) => {\r\n    const dataKey = cache.dataKey;\r\n    const APP = viewModel.APP || viewModel.$root.APP;\r\n\r\n    // NOTE: this doesn't work for for-of, if and switch bindings because element was not in DOM\r\n    if (!dataKey || (!forceRender && !APP.$rootElement.contains(cache.el))) {\r\n        return;\r\n    }\r\n\r\n    const newValue = getViewModelPropValue(viewModel, cache);\r\n    const oldValue = cache.el.textContent;\r\n\r\n    if (typeof newValue !== 'undefined' && typeof newValue !== 'object' && newValue !== null) {\r\n        if (newValue !== oldValue) {\r\n            cache.el.textContent = newValue;\r\n        }\r\n    }\r\n};\r\n\r\nexport default textBinding;\r\n","import {getViewModelPropValue} from './util';\r\n\r\n/**\r\n * showBinding\r\n * @description\r\n * DOM decleartive show binding. Make binding show/hide according to viewModel data (boolean)\r\n * viewModel data can function but must return boolean\r\n * @param {object} cache\r\n * @param {object} viewModel\r\n * @param {object} bindingAttrs\r\n */\r\nconst showBinding = (cache, viewModel, bindingAttrs) => {\r\n    const dataKey = cache.dataKey;\r\n    let currentInlineSytle = {};\r\n    let currentInlineDisplaySytle = '';\r\n    let shouldShow = true;\r\n\r\n    if (!dataKey) {\r\n        return;\r\n    }\r\n\r\n    cache.elementData = cache.elementData || {};\r\n\r\n    const oldShowStatus = cache.elementData.viewModelPropValue;\r\n\r\n    // store current element display default style once only\r\n    if (\r\n        typeof cache.elementData.displayStyle === 'undefined' ||\r\n        typeof cache.elementData.computedStyle === 'undefined'\r\n    ) {\r\n        currentInlineSytle = cache.el.style;\r\n        currentInlineDisplaySytle = currentInlineSytle.display;\r\n        // use current inline style if defined\r\n        if (currentInlineDisplaySytle) {\r\n            // set to 'block' if is 'none'\r\n            cache.elementData.displayStyle = currentInlineDisplaySytle === 'none' ? 'block' : currentInlineDisplaySytle;\r\n            cache.elementData.computedStyle = null;\r\n        } else {\r\n            const computeStyle = window.getComputedStyle(cache.el, null).getPropertyValue('display');\r\n            cache.elementData.displayStyle = null;\r\n            cache.elementData.computedStyle = computeStyle;\r\n        }\r\n    }\r\n\r\n    shouldShow = getViewModelPropValue(viewModel, cache);\r\n\r\n    // treat undefined || null as false.\r\n    // eg if property doesn't exsits in viewModel, it will treat as false to hide element\r\n    shouldShow = Boolean(shouldShow);\r\n\r\n    // reject if nothing changed\r\n    if (oldShowStatus === shouldShow) {\r\n        return;\r\n    }\r\n\r\n    if (!shouldShow) {\r\n        if (cache.el.style.display !== 'none') {\r\n            cache.el.style.setProperty('display', 'none');\r\n        }\r\n    } else {\r\n        if (cache.elementData.computedStyle || cache.el.style.display === 'none') {\r\n            if (cache.elementData.computedStyle === 'none') {\r\n                // default display is none in css rule, so use display 'block'\r\n                cache.el.style.setProperty('display', 'block');\r\n            } else {\r\n                // has default displayable type so just remove inline display 'none'\r\n                if (currentInlineSytle.length > 1) {\r\n                    cache.el.style.removeProperty('display');\r\n                } else {\r\n                    cache.el.removeAttribute('style');\r\n                }\r\n            }\r\n        } else {\r\n            // element default display was inline style, so restore it\r\n            cache.el.style.setProperty('display', cache.elementData.displayStyle);\r\n        }\r\n    }\r\n\r\n    // store new show status\r\n    cache.elementData.viewModelPropValue = shouldShow;\r\n};\r\n\r\nexport default showBinding;\r\n","import {getViewModelPropValue, isPlainObject, arrayRemoveMatch, each} from './util';\r\n\r\n/**\r\n * cssBinding\r\n * @description\r\n * DOM decleartive css binding. update classlist.\r\n * viewModel data can function but must return JSOL.\r\n * added css class if value is true\r\n * @param {object} cache\r\n * @param {object} viewModel\r\n * @param {object} bindingAttrs\r\n * @param {boolean} forceRender\r\n */\r\nconst cssBinding = (cache, viewModel, bindingAttrs, forceRender) => {\r\n    const dataKey = cache.dataKey;\r\n    const APP = viewModel.APP || viewModel.$root.APP;\r\n\r\n    if (!dataKey || (!forceRender && !APP.$rootElement.contains(cache.el))) {\r\n        return;\r\n    }\r\n\r\n    cache.elementData = cache.elementData || {};\r\n    cache.elementData.viewModelPropValue = cache.elementData.viewModelPropValue || '';\r\n\r\n    // let $element = $(cache.el);\r\n    const oldCssList = cache.elementData.viewModelPropValue;\r\n    let newCssList = '';\r\n    const vmCssListObj = getViewModelPropValue(viewModel, cache);\r\n    let vmCssListArray = [];\r\n    let isViewDataObject = false;\r\n    let isViewDataString = false;\r\n    let cssList = [];\r\n\r\n    if (typeof vmCssListObj === 'string') {\r\n        isViewDataString = true;\r\n    } else if (isPlainObject(vmCssListObj)) {\r\n        isViewDataObject = true;\r\n    } else {\r\n        // reject if vmCssListObj is not an object or string\r\n        return;\r\n    }\r\n\r\n    if (isViewDataObject) {\r\n        newCssList = JSON.stringify(vmCssListObj);\r\n    } else {\r\n        newCssList = vmCssListObj.replace(/\\s\\s+/g, ' ').trim();\r\n        vmCssListArray = newCssList.split(' ');\r\n    }\r\n    // reject if nothing changed\r\n    if (oldCssList === newCssList) {\r\n        return;\r\n    }\r\n\r\n    // get current css classes from element\r\n    const domCssList = cache.el.classList;\r\n    // clone domCssList as new array\r\n    const domCssListLength = domCssList.length;\r\n    for (let i = 0; i < domCssListLength; i += 1) {\r\n        cssList.push(domCssList[i]);\r\n    }\r\n\r\n    if (isViewDataObject) {\r\n        each(vmCssListObj, function(k, v) {\r\n            const i = cssList.indexOf(k);\r\n            if (v === true) {\r\n                cssList.push(k);\r\n            } else if (i !== -1) {\r\n                cssList.splice(i, 1);\r\n            }\r\n        });\r\n    } else if (isViewDataString) {\r\n        // remove oldCssList items from cssList\r\n        cssList = arrayRemoveMatch(cssList, oldCssList);\r\n        cssList = cssList.concat(vmCssListArray);\r\n    }\r\n\r\n    // unique cssList array\r\n    cssList = cssList.filter((v, i, a) => {\r\n        return a.indexOf(v) === i;\r\n    });\r\n\r\n    cssList = cssList.join(' ');\r\n    // update element data\r\n    cache.elementData.viewModelPropValue = newCssList;\r\n    // replace all css classes\r\n    cache.el.setAttribute('class', cssList);\r\n};\r\n\r\nexport default cssBinding;\r\n","import {getViewModelPropValue, isPlainObject, isEmptyObject, each} from './util';\r\n\r\n/**\r\n * attrBinding\r\n * @description\r\n * DOM decleartive attr binding. update elenment attributes\r\n * @param {object} cache\r\n * @param {object} viewModel\r\n * @param {object} bindingAttrs\r\n */\r\nconst attrBinding = (cache, viewModel, bindingAttrs) => {\r\n    const dataKey = cache.dataKey;\r\n\r\n    if (!dataKey) {\r\n        return;\r\n    }\r\n\r\n    cache.elementData = cache.elementData || {};\r\n    cache.elementData.viewModelProValue = cache.elementData.viewModelProValue || {};\r\n\r\n    const oldAttrObj = cache.elementData.viewModelProValue;\r\n    const vmAttrObj = getViewModelPropValue(viewModel, cache);\r\n\r\n    if (!isPlainObject(vmAttrObj)) {\r\n        return;\r\n    }\r\n\r\n    // reject if nothing changed\r\n    if (JSON.stringify(oldAttrObj) === JSON.stringify(vmAttrObj)) {\r\n        return;\r\n    }\r\n\r\n    // reset old data and update it\r\n    cache.elementData.viewModelProValue = {};\r\n\r\n    if (isEmptyObject(oldAttrObj)) {\r\n        each(vmAttrObj, (key, value)=> {\r\n            cache.el.setAttribute(key, value);\r\n            // populate with vmAttrObj data\r\n            cache.elementData.viewModelProValue[key] = value;\r\n        });\r\n    } else {\r\n        each(oldAttrObj, (key, value)=> {\r\n            if (typeof vmAttrObj[key] === 'undefined') {\r\n                // remove attribute if not present in current vm\r\n                cache.el.removeAttribute(key);\r\n            }\r\n        });\r\n\r\n        each(vmAttrObj, (key, value)=> {\r\n            if (oldAttrObj[key] !== vmAttrObj[key]) {\r\n                // update attribute if value changed\r\n                cache.el.setAttribute(key, vmAttrObj[key]);\r\n            }\r\n            // populate with vmAttrObj data\r\n            cache.elementData.viewModelProValue[key] = value;\r\n        });\r\n    }\r\n};\r\n\r\nexport default attrBinding;\r\n","/* eslint-disable no-invalid-this */\r\nimport * as config from './config';\r\nimport * as util from './util';\r\n\r\nconst createClonedElementCache = (bindingData) => {\r\n    const clonedElement = bindingData.el.cloneNode(true);\r\n    bindingData.fragment = document.createDocumentFragment();\r\n    bindingData.fragment.appendChild(clonedElement);\r\n    return bindingData;\r\n};\r\n\r\nconst setCommentPrefix = (bindingData) => {\r\n    if (!bindingData || !bindingData.type) {\r\n        return;\r\n    }\r\n    let commentPrefix = '';\r\n    const dataKeyMarker = bindingData.dataKey ? bindingData.dataKey.replace(util.REGEX.WHITESPACES, '_') : '';\r\n\r\n    switch (bindingData.type) {\r\n    case config.bindingAttrs.forOf:\r\n        commentPrefix = config.commentPrefix.forOf;\r\n        break;\r\n    case config.bindingAttrs.if:\r\n        commentPrefix = config.commentPrefix.if;\r\n        break;\r\n    case config.bindingAttrs.case:\r\n        commentPrefix = config.commentPrefix.case;\r\n        break;\r\n    case config.bindingAttrs.default:\r\n        commentPrefix = config.commentPrefix.default;\r\n        break;\r\n    }\r\n    bindingData.commentPrefix = commentPrefix + dataKeyMarker;\r\n    return bindingData;\r\n};\r\n\r\n/**\r\n * setDocRangeEndAfter\r\n * @param {object} node\r\n * @param {object} bindingData\r\n * @description\r\n * recursive execution to find last wrapping comment node\r\n * and set as bindingData.docRange.setEndAfter\r\n * if not found deleteContents will has no operation\r\n * @return {undefined}\r\n */\r\nconst setDocRangeEndAfter = (node, bindingData) => {\r\n    if (!bindingData.commentPrefix) {\r\n        setCommentPrefix(bindingData);\r\n    }\r\n    const startTextContent = bindingData.commentPrefix;\r\n    const endTextContent = startTextContent + config.commentSuffix;\r\n    node = node.nextSibling;\r\n\r\n    // check last wrap comment node\r\n    if (node) {\r\n        if (node.nodeType === 8 && node.textContent === endTextContent) {\r\n            return bindingData.docRange.setEndBefore(node);\r\n        }\r\n        setDocRangeEndAfter(node, bindingData);\r\n    }\r\n};\r\n\r\n/**\r\n * wrapCommentAround\r\n * @param {object} bindingData\r\n * @param {Node} node\r\n * @return {object} DOM fragment\r\n * @description\r\n * wrap frament with comment node\r\n */\r\nconst wrapCommentAround = (bindingData, node) => {\r\n    let prefix = '';\r\n    if (!bindingData.commentPrefix) {\r\n        setCommentPrefix(bindingData);\r\n    }\r\n    prefix = bindingData.commentPrefix;\r\n    const commentBegin = document.createComment(prefix);\r\n    const commentEnd = document.createComment(prefix + config.commentSuffix);\r\n    // document fragment - logic for ForOf binding\r\n    // check node.parentNode because node could be from cache and no longer in DOM\r\n    if (node.nodeType === 11) {\r\n        node.insertBefore(commentBegin, node.firstChild);\r\n        node.appendChild(commentEnd);\r\n    } else if (node.parentNode) {\r\n        node.parentNode.insertBefore(commentBegin, node);\r\n        util.insertAfter(node.parentNode, commentEnd, node);\r\n        // update bindingData details\r\n        bindingData.previousNonTemplateElement = node.previousSibling;\r\n        bindingData.nextNonTemplateElement = node.nextSibling;\r\n        bindingData.parentElement = node.previousSibling.parentElement;\r\n    }\r\n\r\n    return node;\r\n};\r\n\r\n/**\r\n * removeElemnetsByCommentWrap\r\n * @param {object} bindingData\r\n * @return {undefined}\r\n * @description remove elments by range\r\n */\r\nconst removeElemnetsByCommentWrap = (bindingData) => {\r\n    if (!bindingData.docRange) {\r\n        bindingData.docRange = document.createRange();\r\n    }\r\n    try {\r\n        if (bindingData.previousNonTemplateElement) {\r\n            // update docRange start and end match the wrapped comment node\r\n            bindingData.docRange.setStartBefore(bindingData.previousNonTemplateElement.nextSibling);\r\n            setDocRangeEndAfter(bindingData.previousNonTemplateElement.nextSibling, bindingData);\r\n        } else {\r\n            // insert before next non template element\r\n            bindingData.docRange.setStartBefore(bindingData.parentElement.firstChild);\r\n            setDocRangeEndAfter(bindingData.parentElement.firstChild, bindingData);\r\n        }\r\n    } catch (err) {\r\n        console.log('error removeElemnetsByCommentWrap: ', err.message);\r\n    }\r\n\r\n    return bindingData.docRange.deleteContents();\r\n};\r\n\r\n/**\r\n * removeDomTemplateElement\r\n * @param {object} bindingData\r\n * @return {object} null\r\n */\r\nconst removeDomTemplateElement = (bindingData) => {\r\n    // first render - forElement is live DOM element so has parentNode\r\n    if (bindingData.el.parentNode) {\r\n        return bindingData.el.parentNode.removeChild(bindingData.el);\r\n    }\r\n    removeElemnetsByCommentWrap(bindingData);\r\n};\r\n\r\nconst insertRenderedElements = (bindingData, fragment) => {\r\n    // insert rendered fragment after the previousNonTemplateElement\r\n    if (bindingData.previousNonTemplateElement) {\r\n        util.insertAfter(bindingData.parentElement, fragment, bindingData.previousNonTemplateElement);\r\n    } else {\r\n        // insert before next non template element\r\n        if (bindingData.nextNonTemplateElement) {\r\n            bindingData.parentElement.insertBefore(fragment, bindingData.nextNonTemplateElement);\r\n        } else if (bindingData.parentElement) {\r\n            // insert from parent\r\n            bindingData.parentElement.appendChild(fragment);\r\n        }\r\n    }\r\n};\r\n\r\nexport {\r\n    createClonedElementCache,\r\n    setCommentPrefix,\r\n    wrapCommentAround,\r\n    removeElemnetsByCommentWrap,\r\n    removeDomTemplateElement,\r\n    setDocRangeEndAfter,\r\n    insertRenderedElements,\r\n};\r\n","/* eslint-disable no-invalid-this */\r\nimport {bindingAttrs as configBindingAttrs, bindingDataReference} from './config';\r\nimport {getViewModelPropValue, isArray, isPlainObject, throwErrorMessage, cloneDomNode, isEmptyObject} from './util';\r\nimport createBindingCache from './domWalker';\r\nimport {renderIteration} from './binder';\r\nimport {wrapCommentAround, removeElemnetsByCommentWrap, insertRenderedElements} from './commentWrapper';\r\n\r\nconst renderForOfBinding = ({bindingData, viewModel, bindingAttrs}) => {\r\n    if (!bindingData || !viewModel || !bindingAttrs) {\r\n        return;\r\n    }\r\n    let keys;\r\n    let iterationDataLength;\r\n    const iterationData = getViewModelPropValue(viewModel, bindingData.iterator);\r\n    let isRegenerate = false;\r\n\r\n    // check iterationData and set iterationDataLength\r\n    if (isArray(iterationData)) {\r\n        iterationDataLength = iterationData.length;\r\n    } else if (isPlainObject(iterationData)) {\r\n        keys = Object.keys(iterationData);\r\n        iterationDataLength = keys.length;\r\n    } else {\r\n        // throw error but let script contince to run\r\n        return throwErrorMessage(null, 'iterationData is not an plain object or array');\r\n    }\r\n\r\n    // flag as pared for-of logic with bindingData.type\r\n    if (!bindingData.type) {\r\n        bindingData.type = configBindingAttrs.forOf;\r\n        wrapCommentAround(bindingData, bindingData.el);\r\n    }\r\n\r\n    // assign forOf internal id to bindingData once\r\n    if (typeof bindingData.iterationSize === 'undefined') {\r\n        // store iterationDataLength\r\n        bindingData.iterationSize = iterationDataLength;\r\n        // remove orignal node for-of attributes\r\n        bindingData.el.removeAttribute(bindingAttrs.forOf);\r\n        isRegenerate = true;\r\n    } else {\r\n        // only regenerate cache if iterationDataLength changed\r\n        isRegenerate = bindingData.iterationSize !== iterationDataLength;\r\n        // update iterationSize\r\n        bindingData.iterationSize = iterationDataLength;\r\n    }\r\n\r\n    if (!isRegenerate) {\r\n        bindingData.iterationBindingCache.forEach(function(elementCache, i) {\r\n            if (!isEmptyObject(elementCache)) {\r\n                const iterationVm = createIterationViewModel({\r\n                    bindingData: bindingData,\r\n                    viewModel: viewModel,\r\n                    iterationData: iterationData,\r\n                    keys: keys,\r\n                    index: i,\r\n                });\r\n                renderIteration({\r\n                    elementCache: elementCache,\r\n                    iterationVm: iterationVm,\r\n                    bindingAttrs: bindingAttrs,\r\n                    isRegenerate: false,\r\n                });\r\n            }\r\n        });\r\n\r\n        return;\r\n    }\r\n\r\n    // generate forOfBinding elements into fragment\r\n    const fragment = generateForOfElements(bindingData, viewModel, bindingAttrs, iterationData, keys);\r\n\r\n    removeElemnetsByCommentWrap(bindingData);\r\n\r\n    // insert fragment content into DOM\r\n    return insertRenderedElements(bindingData, fragment);\r\n};\r\n\r\nconst createIterationViewModel = ({bindingData, viewModel, iterationData, keys, index}) => {\r\n    const iterationVm = {};\r\n    iterationVm[bindingData.iterator.alias] = keys ? iterationData[keys[index]] : iterationData[index];\r\n    // populate common binding data reference\r\n    iterationVm[bindingDataReference.rootDataKey] = viewModel.$root || viewModel;\r\n    iterationVm[bindingDataReference.currentData] = iterationVm[bindingData.iterator.alias];\r\n    iterationVm[bindingDataReference.currentIndex] = index;\r\n    return iterationVm;\r\n};\r\n\r\nconst generateForOfElements = (bindingData, viewModel, bindingAttrs, iterationData, keys) => {\r\n    const fragment = document.createDocumentFragment();\r\n    const iterationDataLength = bindingData.iterationSize;\r\n    let clonedItem;\r\n    let iterationVm;\r\n    let iterationBindingCache;\r\n    let i = 0;\r\n\r\n    // create or clear exisitng iterationBindingCache\r\n    if (isArray(bindingData.iterationBindingCache)) {\r\n        bindingData.iterationBindingCache.length = 0;\r\n    } else {\r\n        bindingData.iterationBindingCache = [];\r\n    }\r\n\r\n    // generate forOf and append to DOM\r\n    for (i = 0; i < iterationDataLength; i += 1) {\r\n        clonedItem = cloneDomNode(bindingData.el);\r\n\r\n        // create bindingCache per iteration\r\n        iterationBindingCache = createBindingCache({\r\n            rootNode: clonedItem,\r\n            bindingAttrs: bindingAttrs,\r\n        });\r\n\r\n        bindingData.iterationBindingCache.push(iterationBindingCache);\r\n\r\n        if (!isEmptyObject(iterationBindingCache)) {\r\n            // create an iterationVm match iterator alias\r\n            iterationVm = createIterationViewModel({\r\n                bindingData: bindingData,\r\n                viewModel: viewModel,\r\n                iterationData: iterationData,\r\n                keys: keys,\r\n                index: i,\r\n            });\r\n\r\n            renderIteration({\r\n                elementCache: bindingData.iterationBindingCache[i],\r\n                iterationVm: iterationVm,\r\n                bindingAttrs: bindingAttrs,\r\n                isRegenerate: true,\r\n            });\r\n        }\r\n\r\n        fragment.appendChild(clonedItem);\r\n    }\r\n\r\n    return fragment;\r\n};\r\n\r\nexport default renderForOfBinding;\r\n","import {maxDatakeyLength} from './config';\r\nimport {REGEX} from './util';\r\nimport renderForOfBinding from './renderForOfBinding';\r\n\r\n/**\r\n * forOfBinding\r\n * @description\r\n * DOM decleartive for binding.\r\n * @param {object} cache\r\n * @param {object} viewModel\r\n * @param {object} bindingAttrs\r\n */\r\nconst forOfBinding = (cache, viewModel, bindingAttrs) => {\r\n    const dataKey = cache.dataKey;\r\n\r\n    if (!dataKey || dataKey.length > maxDatakeyLength) {\r\n        return;\r\n    }\r\n\r\n    if (!cache.iterator) {\r\n        if (dataKey.length > maxDatakeyLength) {\r\n            return;\r\n        }\r\n        // replace mess spaces with single space\r\n        cache.dataKey = cache.dataKey.replace(REGEX.WHITESPACES, ' ');\r\n        const forExpMatch = dataKey.match(REGEX.FOROF);\r\n\r\n        if (!forExpMatch) {\r\n            return;\r\n        }\r\n\r\n        cache.iterator = {};\r\n        cache.iterator.alias = forExpMatch[1].trim();\r\n\r\n        if (forExpMatch[2]) {\r\n            cache.iterator.dataKey = forExpMatch[2].trim();\r\n            cache.parentElement = cache.el.parentElement;\r\n            cache.previousNonTemplateElement = cache.el.previousSibling;\r\n            cache.nextNonTemplateElement = cache.el.nextSibling;\r\n        }\r\n    }\r\n\r\n    renderForOfBinding({\r\n        bindingData: cache,\r\n        viewModel: viewModel,\r\n        bindingAttrs: bindingAttrs,\r\n    });\r\n};\r\n\r\nexport default forOfBinding;\r\n","import {isEmptyObject} from './util';\r\nimport {renderIteration} from './binder';\r\nimport createBindingCache from './domWalker';\r\nimport {commentSuffix} from './config';\r\nimport {removeElemnetsByCommentWrap, insertRenderedElements} from './commentWrapper';\r\n\r\n/**\r\n * isTargetDomRemoved\r\n * @description check if DOM between 'start' and 'end' comment tag has been removed\r\n * @param {object} bindingData\r\n * @return {boolean}\r\n */\r\nconst isTargetDomRemoved = (bindingData) => {\r\n    let ret = false;\r\n    if (bindingData && bindingData.previousNonTemplateElement) {\r\n        const commentStartTextContent = bindingData.previousNonTemplateElement.textContent;\r\n        const endCommentTag = bindingData.previousNonTemplateElement.nextSibling;\r\n\r\n        if (endCommentTag.nodeType === 8) {\r\n            if (endCommentTag.textContent === commentStartTextContent + commentSuffix) {\r\n                ret = true;\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n};\r\n\r\nconst renderIfBinding = ({bindingData, viewModel, bindingAttrs}) => {\r\n    if (!bindingData.fragment) {\r\n        return;\r\n    }\r\n\r\n    const isDomRemoved = isTargetDomRemoved(bindingData);\r\n    let rootElement = bindingData.el;\r\n\r\n    // remove current old DOM.\r\n    // TODO: try preserve DOM\r\n    if (!isDomRemoved && !bindingData.isOnce) {\r\n        removeIfBinding(bindingData);\r\n        // use fragment for create iterationBindingCache\r\n        rootElement = bindingData.fragment.firstChild.cloneNode(true);\r\n    }\r\n\r\n    // walk clonedElement to create iterationBindingCache once\r\n    if (!bindingData.iterationBindingCache || !bindingData.hasIterationBindingCache) {\r\n        bindingData.iterationBindingCache = createBindingCache({\r\n            rootNode: rootElement,\r\n            bindingAttrs: bindingAttrs,\r\n        });\r\n    }\r\n\r\n    // only render if has iterationBindingCache\r\n    // means has other dataBindings to be render\r\n    if (!isEmptyObject(bindingData.iterationBindingCache)) {\r\n        bindingData.hasIterationBindingCache = true;\r\n        renderIteration({\r\n            elementCache: bindingData.iterationBindingCache,\r\n            iterationVm: viewModel,\r\n            bindingAttrs: bindingAttrs,\r\n            isRegenerate: true,\r\n        });\r\n    }\r\n\r\n    // insert to new rendered DOM\r\n    // TODO: check unnecessary insertion when DOM is preserved\r\n    insertRenderedElements(bindingData, rootElement);\r\n};\r\n\r\nconst removeIfBinding = (bindingData) => {\r\n    removeElemnetsByCommentWrap(bindingData);\r\n    // remove cache.IterationBindingCache to prevent memory leak\r\n    if (bindingData.hasIterationBindingCache) {\r\n        delete bindingData.iterationBindingCache;\r\n        delete bindingData.hasIterationBindingCache;\r\n    }\r\n};\r\n\r\nexport {renderIfBinding, removeIfBinding};\r\n","import {bindingAttrs as configBindingAttrs, constants} from './config';\r\nimport {getViewModelPropValue, removeElement} from './util';\r\nimport {createClonedElementCache, wrapCommentAround} from './commentWrapper';\r\nimport {renderIfBinding, removeIfBinding} from './renderIfBinding';\r\n\r\n/**\r\n * if-Binding\r\n * @description\r\n * DOM decleartive for binding.\r\n * @param {object} cache\r\n * @param {object} viewModel\r\n * @param {object} bindingAttrs\r\n */\r\nconst ifBinding = (cache, viewModel, bindingAttrs) => {\r\n    const dataKey = cache.dataKey;\r\n\r\n    // isOnce only return if there is no child bindings\r\n    if (!dataKey || (cache.isOnce && cache.hasIterationBindingCache === false)) {\r\n        return;\r\n    }\r\n\r\n    cache.elementData = cache.elementData || {};\r\n    cache.type = cache.type || configBindingAttrs.if;\r\n\r\n    const oldViewModelProValue = cache.elementData.viewModelPropValue;\r\n    // getViewModelPropValue could be return undefined or null\r\n    const viewModelPropValue = getViewModelPropValue(viewModel, cache) || false;\r\n\r\n    // do nothing if viewModel value not changed and no child bindings\r\n    if (oldViewModelProValue === viewModelPropValue && !cache.hasIterationBindingCache) {\r\n        return;\r\n    }\r\n\r\n    const shouldRender = Boolean(viewModelPropValue);\r\n\r\n    // remove this cache from parent array\r\n    if (!shouldRender && cache.isOnce && cache.el.parentNode) {\r\n        removeElement(cache.el);\r\n        // delete cache.fragment;\r\n        removeBindingInQueue({\r\n            viewModel: viewModel,\r\n            cache: cache,\r\n        });\r\n        return;\r\n    }\r\n\r\n    // store new show status\r\n    cache.elementData.viewModelPropValue = viewModelPropValue;\r\n\r\n    // only create fragment once\r\n    // wrap comment tag around\r\n    // remove if attribute from original element to allow later dataBind parsing\r\n    if (!cache.fragment) {\r\n        wrapCommentAround(cache, cache.el);\r\n        cache.el.removeAttribute(bindingAttrs.if);\r\n        createClonedElementCache(cache);\r\n    }\r\n\r\n    if (!shouldRender) {\r\n        // remove element\r\n        removeIfBinding(cache);\r\n    } else {\r\n        // render element\r\n        renderIfBinding({\r\n            bindingData: cache,\r\n            viewModel: viewModel,\r\n            bindingAttrs: bindingAttrs,\r\n        });\r\n\r\n        // if render once\r\n        // remove this cache from parent array if no child caches\r\n        if (cache.isOnce && !cache.hasIterationBindingCache) {\r\n            // delete cache.fragment;\r\n            removeBindingInQueue({\r\n                viewModel: viewModel,\r\n                cache: cache,\r\n            });\r\n        }\r\n    }\r\n};\r\n\r\nconst removeBindingInQueue = ({viewModel, cache}) => {\r\n    let ret = false;\r\n    if (viewModel.APP.postProcessQueue) {\r\n        viewModel.APP.postProcessQueue.push(\r\n            ((cache, index) => () => {\r\n                cache[constants.PARENT_REF].splice(index, 1);\r\n            })(cache, cache[constants.PARENT_REF].indexOf(cache))\r\n        );\r\n        ret = true;\r\n    }\r\n    return ret;\r\n};\r\n\r\nexport default ifBinding;\r\n","import * as util from './util';\r\n\r\n/**\r\n *  pubSub\r\n * @description use jQuery object as pubSub\r\n * @example EVENTS object strucure:\r\n *  EVENTS = {\r\n        'EVENT-NAME': [{ 'comp-id': fn }],\r\n        'EVENT-NAME2': [{ 'comp-id': fn }]\r\n    };\r\n */\r\n\r\nconst EVENTS = {};\r\n\r\nconst subscribeEvent = (instance = null, eventName = '', fn, isOnce = false) => {\r\n    if (!instance || !instance.compId || !eventName || typeof fn !== 'function') {\r\n        return;\r\n    }\r\n\r\n    let subscriber;\r\n    let isSubscribed = false;\r\n\r\n    eventName = eventName.replace(util.REGEX.WHITESPACES, '');\r\n    EVENTS[eventName] = EVENTS[eventName] || [];\r\n    // check if already subscribed and update callback fn\r\n    isSubscribed = EVENTS[eventName].some((subscriber) => {\r\n        if (subscriber[instance.compId]) {\r\n            subscriber[instance.compId] = fn.bind(instance.viewModel);\r\n            subscriber.isOnce = isOnce;\r\n            return true;\r\n        }\r\n    });\r\n    // push if not yet subscribe\r\n    if (!isSubscribed) {\r\n        subscriber = {};\r\n        subscriber[instance.compId] = fn.bind(instance.viewModel);\r\n        subscriber.isOnce = isOnce;\r\n        EVENTS[eventName].push(subscriber);\r\n    }\r\n};\r\n\r\nconst subscribeEventOnce = (instance = null, eventName = '', fn) => {\r\n    subscribeEvent(instance, eventName, fn, true);\r\n};\r\n\r\nconst unsubscribeEvent = (compId = '', eventName = '') => {\r\n    if (!compId || !eventName) {\r\n        return;\r\n    }\r\n\r\n    let i = 0;\r\n    let subscribersLength = 0;\r\n    let subscriber;\r\n\r\n    eventName = eventName.replace(util.REGEX.WHITESPACES, '');\r\n\r\n    if (EVENTS[eventName]) {\r\n        subscribersLength = EVENTS[eventName].length;\r\n        for (i = 0; i < subscribersLength; i += 1) {\r\n            subscriber = EVENTS[eventName][i];\r\n            if (subscriber[compId]) {\r\n                EVENTS[eventName].splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    // delete the event if no more subscriber\r\n    if (!EVENTS[eventName].length) {\r\n        delete EVENTS[eventName];\r\n    }\r\n};\r\n\r\n/**\r\n * unsubscribeAllEvent\r\n * @description unsubscribe all event by compId. eg when a component removed\r\n * @param {string} compId\r\n */\r\nconst unsubscribeAllEvent = (compId = '') => {\r\n    if (!compId) {\r\n        return;\r\n    }\r\n    Object.keys(EVENTS).forEach((eventName) => {\r\n        unsubscribeEvent(compId, eventName);\r\n    });\r\n};\r\n\r\nconst publishEvent = (eventName = '', ...args) => {\r\n    if (!eventName || !EVENTS[eventName]) {\r\n        return;\r\n    }\r\n\r\n    eventName = eventName.replace(util.REGEX.WHITESPACES, '');\r\n\r\n    EVENTS[eventName].forEach((subscriber) => {\r\n        Object.keys(subscriber).forEach((compId) => {\r\n            if (typeof subscriber[compId] === 'function') {\r\n                const ret = subscriber[compId](...args);\r\n                if (subscriber.isOnce) {\r\n                    unsubscribeEvent(compId, eventName);\r\n                }\r\n                return ret;\r\n            }\r\n        });\r\n    });\r\n};\r\n\r\nexport {subscribeEvent, subscribeEventOnce, unsubscribeEvent, unsubscribeAllEvent, publishEvent};\r\n","import * as config from './config';\r\nimport {debounceRaf, extend, each, throwErrorMessage} from './util';\r\nimport renderTemplate from './renderTemplate';\r\nimport clickBinding from './clickBinding';\r\nimport dblclickBinding from './dbclickBinding';\r\nimport blurBinding from './blurBinding';\r\nimport focusBinding from './focusBinding';\r\nimport hoverBinding from './hoverBinding';\r\nimport changeBinding from './changeBinding';\r\nimport modelBinding from './modelBinding';\r\nimport submitBinding from './submitBinding';\r\nimport textBinding from './textBinding';\r\nimport showBinding from './showBinding';\r\nimport cssBinding from './cssBinding';\r\nimport attrBinding from './attrBinding';\r\nimport forOfBinding from './forOfBinding';\r\nimport ifBinding from './ifBinding';\r\nimport switchBinding from './switchBinding';\r\nimport createBindingCache from './domWalker';\r\nimport * as pubSub from './pubSub';\r\n\r\nlet compIdIndex = 0;\r\n\r\nclass Binder {\r\n    constructor($rootElement, viewModel, bindingAttrs) {\r\n        if ($rootElement instanceof window.jQuery && $rootElement.length) {\r\n            $rootElement = $rootElement.eq(0)[0];\r\n        }\r\n\r\n        if (!$rootElement || $rootElement.nodeType !== 1 || viewModel === null || typeof viewModel !== 'object') {\r\n            throw new TypeError('$rootElement or viewModel is invalid');\r\n        }\r\n\r\n        this.initRendered = false;\r\n\r\n        this.compId = compIdIndex += 1;\r\n\r\n        this.$rootElement = $rootElement;\r\n\r\n        this.viewModel = viewModel;\r\n\r\n        this.bindingAttrs = bindingAttrs;\r\n\r\n        this.render = debounceRaf(this.render, this);\r\n\r\n        this.isServerRendered = this.$rootElement.getAttribute(config.serverRenderedAttr) !== null;\r\n\r\n        // inject instance into viewModel\r\n        this.viewModel.APP = this;\r\n\r\n        this.viewModel.$root = this.viewModel;\r\n\r\n        this.parseView();\r\n\r\n        // for jquery user set viewModel referece to $rootElement for easy debug\r\n        // otherwise use Expando to attach viewModel to $rootElement\r\n        if (window.jQuery) {\r\n            window.jQuery(this.$rootElement).data(config.bindingDataReference.rootDataKey, this.viewModel);\r\n        } else {\r\n            this.$rootElement[config.bindingDataReference.rootDataKey] = this.viewModel;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * parseView\r\n     * @description\r\n     * @return {this}\r\n     * traver from $rootElement to find each data-bind-* element\r\n     * then apply data binding\r\n     */\r\n    parseView() {\r\n        this.elementCache = createBindingCache({\r\n            rootNode: this.$rootElement,\r\n            bindingAttrs: this.bindingAttrs,\r\n        });\r\n\r\n        // updateElementCache if server rendered on init\r\n        if (this.isServerRendered && !this.initRendered) {\r\n            this.updateElementCache({\r\n                templateCache: true,\r\n            });\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * updateElementCache\r\n     * @param {object} opt\r\n     * @description call createBindingCache to parse view and generate bindingCache\r\n     */\r\n    updateElementCache(opt = {}) {\r\n        const elementCache = opt.elementCache || this.elementCache;\r\n\r\n        if (opt.allCache) {\r\n            // walk dom from root element to regenerate elementCache\r\n            this.elementCache = createBindingCache({\r\n                rootNode: this.$rootElement,\r\n                bindingAttrs: this.bindingAttrs,\r\n            });\r\n        }\r\n        // walk from first rendered template node to create/update child bindingCache\r\n        if (opt.allCache || opt.templateCache) {\r\n            if (elementCache[this.bindingAttrs.tmp] && elementCache[this.bindingAttrs.tmp].length) {\r\n                elementCache[this.bindingAttrs.tmp].forEach((cache) => {\r\n                    // set skipCheck as skipForOfParseFn whenever an node has\r\n                    // both template and forOf bindings\r\n                    // then the template bindingCache should be an empty object\r\n                    let skipForOfParseFn = null;\r\n                    if (cache.el.hasAttribute(this.bindingAttrs.forOf)) {\r\n                        skipForOfParseFn = () => {\r\n                            return true;\r\n                        };\r\n                    }\r\n                    cache.bindingCache = createBindingCache({\r\n                        rootNode: cache.el,\r\n                        bindingAttrs: this.bindingAttrs,\r\n                        skipCheck: skipForOfParseFn,\r\n                        isRenderedTemplate: opt.isRenderedTemplates,\r\n                    });\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    render(opt = {}) {\r\n        let updateOption = {};\r\n        if (!this.initRendered) {\r\n            // only update eventsBinding if server rendered\r\n            if (this.isServerRendered) {\r\n                this.$rootElement.removeAttribute(config.serverRenderedAttr);\r\n                updateOption = createBindingOption(config.bindingUpdateConditions.serverRendered, opt);\r\n            } else {\r\n                updateOption = createBindingOption(config.bindingUpdateConditions.init, opt);\r\n            }\r\n        } else {\r\n            // when called again only update visualBinding options\r\n            updateOption = createBindingOption('', opt);\r\n        }\r\n\r\n        // create postProcessQueue before start rendering\r\n        this.postProcessQueue = [];\r\n\r\n        // render and apply binding to template(s)\r\n        // this is an share function therefore passing 'this' context\r\n        renderTemplatesBinding({\r\n            ctx: this,\r\n            elementCache: this.elementCache,\r\n            updateOption: updateOption,\r\n            bindingAttrs: this.bindingAttrs,\r\n            viewModel: this.viewModel,\r\n        });\r\n\r\n        // apply bindings to rest of the DOM\r\n        Binder.applyBinding({\r\n            ctx: this,\r\n            elementCache: this.elementCache,\r\n            updateOption: updateOption,\r\n            bindingAttrs: this.bindingAttrs,\r\n            viewModel: this.viewModel,\r\n        });\r\n\r\n        // trigger postProcess\r\n        Binder.postProcess(this.postProcessQueue);\r\n        // clear postProcessQueue\r\n        this.postProcessQueue.length = 0;\r\n        delete this.postProcessQueue;\r\n\r\n        this.initRendered = true;\r\n    }\r\n\r\n    static applyBinding({ctx, elementCache, updateOption, bindingAttrs, viewModel}) {\r\n        if (!elementCache || !updateOption) {\r\n            return;\r\n        }\r\n\r\n        // the follow binding should be in order for better efficiency\r\n\r\n        // apply forOf Binding\r\n        if (updateOption.forOfBinding && elementCache[bindingAttrs.forOf] && elementCache[bindingAttrs.forOf].length) {\r\n            elementCache[bindingAttrs.forOf].forEach((cache) => {\r\n                forOfBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\r\n            });\r\n        }\r\n\r\n        // apply attr Binding\r\n        if (updateOption.attrBinding && elementCache[bindingAttrs.attr] && elementCache[bindingAttrs.attr].length) {\r\n            elementCache[bindingAttrs.attr].forEach((cache) => {\r\n                attrBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\r\n            });\r\n        }\r\n\r\n        // apply if Binding\r\n        if (updateOption.ifBinding && elementCache[bindingAttrs.if] && elementCache[bindingAttrs.if].length) {\r\n            elementCache[bindingAttrs.if].forEach((cache) => {\r\n                ifBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\r\n            });\r\n        }\r\n\r\n        // apply show Binding\r\n        if (updateOption.showBinding && elementCache[bindingAttrs.show] && elementCache[bindingAttrs.show].length) {\r\n            elementCache[bindingAttrs.show].forEach((cache) => {\r\n                showBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\r\n            });\r\n        }\r\n\r\n        // apply switch Binding\r\n        if (\r\n            updateOption.switchBinding &&\r\n            elementCache[bindingAttrs.switch] &&\r\n            elementCache[bindingAttrs.switch].length\r\n        ) {\r\n            elementCache[bindingAttrs.switch].forEach((cache) => {\r\n                switchBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\r\n            });\r\n        }\r\n\r\n        // apply text binding\r\n        if (updateOption.textBinding && elementCache[bindingAttrs.text] && elementCache[bindingAttrs.text].length) {\r\n            elementCache[bindingAttrs.text].forEach((cache) => {\r\n                textBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\r\n            });\r\n        }\r\n\r\n        // apply cssBinding\r\n        if (updateOption.cssBinding && elementCache[bindingAttrs.css] && elementCache[bindingAttrs.css].length) {\r\n            elementCache[bindingAttrs.css].forEach((cache) => {\r\n                cssBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\r\n            });\r\n        }\r\n\r\n        // apply model binding\r\n        if (updateOption.modelBinding && elementCache[bindingAttrs.model] && elementCache[bindingAttrs.model].length) {\r\n            elementCache[bindingAttrs.model].forEach((cache) => {\r\n                modelBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\r\n            });\r\n        }\r\n\r\n        // apply change binding\r\n        if (\r\n            updateOption.changeBinding &&\r\n            elementCache[bindingAttrs.change] &&\r\n            elementCache[bindingAttrs.change].length\r\n        ) {\r\n            elementCache[bindingAttrs.change].forEach((cache) => {\r\n                changeBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\r\n            });\r\n        }\r\n\r\n        // apply submit binding\r\n        if (\r\n            updateOption.submitBinding &&\r\n            elementCache[bindingAttrs.submit] &&\r\n            elementCache[bindingAttrs.submit].length\r\n        ) {\r\n            elementCache[bindingAttrs.submit].forEach((cache) => {\r\n                submitBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\r\n            });\r\n        }\r\n\r\n        // apply click binding\r\n        if (updateOption.clickBinding && elementCache[bindingAttrs.click] && elementCache[bindingAttrs.click].length) {\r\n            elementCache[bindingAttrs.click].forEach((cache) => {\r\n                clickBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\r\n            });\r\n        }\r\n\r\n        // apply double click binding\r\n        if (\r\n            updateOption.dblclickBinding &&\r\n            elementCache[bindingAttrs.dblclick] &&\r\n            elementCache[bindingAttrs.dblclick].length\r\n        ) {\r\n            elementCache[bindingAttrs.dblclick].forEach((cache) => {\r\n                dblclickBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\r\n            });\r\n        }\r\n\r\n        // apply blur binding\r\n        if (updateOption.blurBinding && elementCache[bindingAttrs.blur] && elementCache[bindingAttrs.blur].length) {\r\n            elementCache[bindingAttrs.blur].forEach((cache) => {\r\n                blurBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\r\n            });\r\n        }\r\n\r\n        // apply focus binding\r\n        if (updateOption.focusBinding && elementCache[bindingAttrs.focus] && elementCache[bindingAttrs.focus].length) {\r\n            elementCache[bindingAttrs.focus].forEach((cache) => {\r\n                focusBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\r\n            });\r\n        }\r\n\r\n        // apply hover binding\r\n        if (updateOption.hoverBinding && elementCache[bindingAttrs.hover] && elementCache[bindingAttrs.hover].length) {\r\n            elementCache[bindingAttrs.hover].forEach((cache) => {\r\n                hoverBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\r\n            });\r\n        }\r\n    }\r\n\r\n    static postProcess(tasks) {\r\n        if (!tasks || !tasks.length) {\r\n            return;\r\n        }\r\n        each(tasks, (index, task) => {\r\n            if (typeof task === 'function') {\r\n                try {\r\n                    task();\r\n                } catch (err) {\r\n                    throwErrorMessage(err, 'Error postProcess: ' + String(task));\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    subscribe(eventName = '', fn) {\r\n        pubSub.subscribeEvent(this, eventName, fn);\r\n        return this;\r\n    }\r\n\r\n    subscribeOnce(eventName = '', fn) {\r\n        pubSub.subscribeEventOnce(this, eventName, fn);\r\n        return this;\r\n    }\r\n\r\n    unsubscribe(eventName = '') {\r\n        pubSub.unsubscribeEvent(this.compId, eventName);\r\n        return this;\r\n    }\r\n\r\n    unsubscribeAll() {\r\n        pubSub.unsubscribeAllEvent(this.compId);\r\n        return this;\r\n    }\r\n\r\n    publish(eventName = '', ...args) {\r\n        pubSub.publishEvent(eventName, ...args);\r\n        return this;\r\n    }\r\n}\r\n\r\nconst renderTemplatesBinding = ({ctx, elementCache, updateOption, bindingAttrs, viewModel}) => {\r\n    if (!elementCache || !bindingAttrs) {\r\n        return false;\r\n    }\r\n    // render and apply binding to template(s) and forOf DOM\r\n    if (elementCache[bindingAttrs.tmp] && elementCache[bindingAttrs.tmp].length) {\r\n        // when re-render call with {templateBinding: true}\r\n        // template and nested templates\r\n        if (updateOption.templateBinding) {\r\n            // overwrite updateOption with 'init' bindingUpdateConditions\r\n            updateOption = createBindingOption(config.bindingUpdateConditions.init);\r\n\r\n            elementCache[bindingAttrs.tmp].forEach(($element) => {\r\n                renderTemplate($element, viewModel, bindingAttrs, elementCache);\r\n            });\r\n            // update cache after all template(s) rendered\r\n            ctx.updateElementCache({\r\n                templateCache: true,\r\n                elementCache: elementCache,\r\n                isRenderedTemplates: true,\r\n            });\r\n        }\r\n        // enforce render even element is not in DOM tree\r\n        updateOption.forceRender = true;\r\n\r\n        // apply bindings to rendered templates element\r\n        elementCache[bindingAttrs.tmp].forEach((cache) => {\r\n            Binder.applyBinding({\r\n                elementCache: cache.bindingCache,\r\n                updateOption: updateOption,\r\n                bindingAttrs: bindingAttrs,\r\n                viewModel: viewModel,\r\n            });\r\n        });\r\n    }\r\n    return true;\r\n};\r\n\r\n/**\r\n * createBindingOption\r\n * @param {string} condition\r\n * @param {object} opt\r\n * @description\r\n * generate binding update option object by condition\r\n * @return {object} updateOption\r\n */\r\nconst createBindingOption = (condition = '', opt = {}) => {\r\n    const visualBindingOptions = {\r\n        templateBinding: false,\r\n        textBinding: true,\r\n        cssBinding: true,\r\n        ifBinding: true,\r\n        showBinding: true,\r\n        modelBinding: true,\r\n        attrBinding: true,\r\n        forOfBinding: true,\r\n        switchBinding: true,\r\n    };\r\n    const eventsBindingOptions = {\r\n        changeBinding: true,\r\n        clickBinding: true,\r\n        dblclickBinding: true,\r\n        blurBinding: true,\r\n        focusBinding: true,\r\n        hoverBinding: true,\r\n        submitBinding: true,\r\n    };\r\n    // this is visualBindingOptions but everything false\r\n    // concrete declear for performance purpose\r\n    const serverRenderedOptions = {\r\n        templateBinding: false,\r\n        textBinding: false,\r\n        cssBinding: false,\r\n        ifBinding: false,\r\n        showBinding: false,\r\n        modelBinding: false,\r\n        attrBinding: false,\r\n        forOfBinding: false,\r\n        switchBinding: false,\r\n    };\r\n    let updateOption = {};\r\n\r\n    switch (condition) {\r\n    case config.bindingUpdateConditions.serverRendered:\r\n        updateOption = extend({}, eventsBindingOptions, serverRenderedOptions, opt);\r\n        break;\r\n    case config.bindingUpdateConditions.init:\r\n        // flag templateBinding to true to render tempalte(s)\r\n        opt.templateBinding = true;\r\n        updateOption = extend({}, visualBindingOptions, eventsBindingOptions, opt);\r\n        break;\r\n    default:\r\n        // when called again only update visualBinding options\r\n        updateOption = extend({}, visualBindingOptions, opt);\r\n    }\r\n\r\n    return updateOption;\r\n};\r\n\r\n/**\r\n * renderIteration\r\n * @param {object} opt\r\n * @description\r\n * render element's binding by supplied elementCache\r\n * This function is desidned for FoOf, If, switch bindings\r\n */\r\nconst renderIteration = ({elementCache, iterationVm, bindingAttrs, isRegenerate}) => {\r\n    const bindingUpdateOption = isRegenerate\r\n        ? createBindingOption(config.bindingUpdateConditions.init)\r\n        : createBindingOption();\r\n\r\n    // enforce render even element is not in DOM tree\r\n    bindingUpdateOption.forceRender = true;\r\n\r\n    // render and apply binding to template(s)\r\n    // this is an share function therefore passing current APP 'this' context\r\n    // viewModel is a dynamic generated iterationVm\r\n    renderTemplatesBinding({\r\n        ctx: iterationVm.$root ? iterationVm.$root.APP : iterationVm.APP,\r\n        elementCache: elementCache,\r\n        updateOption: bindingUpdateOption,\r\n        bindingAttrs: bindingAttrs,\r\n        viewModel: iterationVm,\r\n    });\r\n\r\n    Binder.applyBinding({\r\n        elementCache: elementCache,\r\n        updateOption: bindingUpdateOption,\r\n        bindingAttrs: bindingAttrs,\r\n        viewModel: iterationVm,\r\n    });\r\n};\r\n\r\nexport {Binder, createBindingOption, renderTemplatesBinding, renderIteration};\r\n","import * as config from './config';\r\nimport {Binder} from './binder';\r\n\r\nlet bindingAttrs = config.bindingAttrs;\r\nlet templateSettings = config.templateSettings;\r\n\r\nconst use = (settings = {}) => {\r\n    if (settings.bindingAttrs) {\r\n        bindingAttrs = $.extend({}, settings.bindingAttrs);\r\n    }\r\n    if (settings.templateSettings) {\r\n        templateSettings = $.extend({}, settings.templateSettings);\r\n    }\r\n};\r\n\r\nconst init = ($rootElement, viewModel = null) => {\r\n    _.templateSettings = templateSettings;\r\n    return new Binder($rootElement, viewModel, bindingAttrs);\r\n};\r\n\r\n// expose to global\r\nwindow.dataBind = {\r\n    use: use,\r\n    init: init,\r\n    version: '@version@',\r\n};\r\n"],"names":["removeUnmatchCases","cases","matchedIndex","forEach","caseData","index","removeIfBinding","hasIterationBindingCache","iterationBindingCache","createCaseData","node","attrName","el","dataKey","getAttribute","type","bindingAttrs","comp","tmp","text","click","dblclick","blur","focus","hover","change","submit","model","show","css","attr","forOf","serverRenderedAttr","commentPrefix","templateSettings","evaluate","interpolate","escape","bindingDataReference","rootDataKey","currentData","currentIndex","mouseEnterHandlerName","mouseLeaveHandlerName","bindingUpdateConditions","serverRendered","init","constants","filters","ONCE","PARENT_REF","_","window","bindingAttrsMap","hasIsArray","Array","isArray","supportPromise","REGEX","FUNCTIONPARAM","WHITESPACES","FOROF","PIPE","obj","Object","prototype","toString","call","isJsObject","_typeof","isPlainObject","ctor","constructor","prot","hasOwnProperty","isEmptyObject","getOwnPropertyNames","length","getViewModelValue","viewModel","prop","get","setViewModelValue","value","set","getViewModelPropValue","bindingCache","paramList","parameters","isInvertBoolean","charAt","substring","ret","viewModelContext","resolveViewModelContext","oldViewModelProValue","elementData","viewModelProValue","args","resolveParamList","concat","apply","Boolean","filtersViewModelPropValue","each","filter","filterFn","err","throwErrorMessage","parseStringToJson","str","replace","JSON","parse","arrayRemoveMatch","toArray","frommArray","indexOf","getFormData","$form","data","serializeArray","map","n","getFunctionParameterList","paramlist","match","split","v","i","trim","extractFilterList","cacheData","isOnceIndex","filterList","shift","config","isOnce","splice","invertObj","sourceObj","keys","reduce","key","createDeferredObj","dfObj","promise","Promise","resolve","reject","$","Deferred","debounceRaf","fn","ctx","rafId","from","arguments","slice","cancelAnimationFrame","requestAnimationFrame","extend","isDeepMerge","target","sources","source","undefined","isMergebleObject","assign","keysLength","isArrayObj","TypeError","item","cloneDomNode","element","cloneNode","insertAfter","parentNode","newNode","referenceNode","refNextElement","nextSibling","insertBefore","datakey","bindingDataContext","param","removeElement","removeChild","errorMessage","message","console","error","log","$domFragment","$templateRoot","nestTemplatesCount","templateCache","compileTemplate","id","templateString","templateElement","templateData","document","getElementById","innerHTML","template","variable","renderTemplate","cache","elementCache","$currentElement","settings","viewData","isAppend","append","isPrepend","prepend","$element","$index","html","children","empty","$nestedTemplates","find","thisTemplateCache","push","afterTemplateRender","clickBinding","forceRender","handlerName","APP","$root","$rootElement","contains","handlerFn","off","on","e","this","dblclickBinding","blurBinding","focusBinding","hoverBinding","inHandlerName","outHandlerName","handlers","changeBinding","modelDataKey","newValue","oldValue","$this","isCheckbox","is","val","modelBinding","isRadio","inputName","name","$radioGroup","submitBinding","textBinding","textContent","showBinding","currentInlineSytle","currentInlineDisplaySytle","shouldShow","oldShowStatus","viewModelPropValue","displayStyle","computedStyle","style","display","computeStyle","getComputedStyle","getPropertyValue","setProperty","removeProperty","removeAttribute","cssBinding","oldCssList","newCssList","vmCssListObj","vmCssListArray","isViewDataObject","isViewDataString","cssList","stringify","domCssList","classList","domCssListLength","k","a","join","setAttribute","attrBinding","oldAttrObj","vmAttrObj","walkDOM","func","firstElementChild","nextElementSibling","getAttributesObject","attributes","checkSkipChildParseBindings","attrObj","rootSkipCheck","tagName","defaultSkipCheck","hasAttribute","populateBindingCache","attrValue","createBindingCache","rootNode","skipCheck","isRenderedTemplate","Node","parseNode","skipNodeCheckFn","isSkipForOfChild","nodeType","hasAttributes","hasSkipChildParseBindings","iterateList","createClonedElementCache","bindingData","clonedElement","fragment","createDocumentFragment","appendChild","setCommentPrefix","dataKeyMarker","util","setDocRangeEndAfter","endTextContent","docRange","setEndBefore","wrapCommentAround","prefix","commentBegin","createComment","commentEnd","firstChild","previousNonTemplateElement","previousSibling","nextNonTemplateElement","parentElement","removeElemnetsByCommentWrap","createRange","setStartBefore","deleteContents","insertRenderedElements","renderForOfBinding","iterationDataLength","iterationData","iterator","isRegenerate","configBindingAttrs","iterationSize","iterationVm","createIterationViewModel","renderIteration","generateForOfElements","alias","clonedItem","forOfBinding","forExpMatch","isTargetDomRemoved","commentStartTextContent","endCommentTag","renderIfBinding","isDomRemoved","rootElement","ifBinding","shouldRender","removeBindingInQueue","postProcessQueue","switchBinding","newExpression","childrenElements","elementLength","isDefault","hasMatch","j","casesLength","newCaseValue","EVENTS","subscribeEvent","instance","eventName","compId","subscriber","some","bind","subscribeEventOnce","unsubscribeEvent","subscribersLength","unsubscribeAllEvent","publishEvent","compIdIndex","Binder","jQuery","eq","initRendered","render","isServerRendered","parseView","updateElementCache","opt","allCache","skipForOfParseFn","_this","isRenderedTemplates","updateOption","createBindingOption","renderTemplatesBinding","applyBinding","postProcess","pubSub","tasks","task","String","templateBinding","condition","visualBindingOptions","eventsBindingOptions","serverRenderedOptions","bindingUpdateOption","use","dataBind","version"],"mappings":"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"}