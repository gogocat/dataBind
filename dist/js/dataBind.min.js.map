{"version":3,"file":"dataBind.min.js","sources":["../../src/config.js","../../src/util.js","../../src/domWalker.js","../../src/renderTemplate.js","../../src/changeBinding.js","../../src/commentWrapper.js","../../src/renderForOfBinding.js","../../src/forOfBinding.js","../../src/renderIfBinding.js","../../src/ifBinding.js","../../src/switchBinding.js","../../src/pubSub.js","../../src/binder.js","../../src/attrBinding.js","../../src/showBinding.js","../../src/textBinding.js","../../src/cssBinding.js","../../src/modelBinding.js","../../src/submitBinding.js","../../src/clickBinding.js","../../src/dbclickBinding.js","../../src/blurBinding.js","../../src/focusBinding.js","../../src/hoverBinding.js","../../src/index.js"],"sourcesContent":["const bindingAttrs = {\n    comp: 'data-jq-comp',\n    tmp: 'data-jq-tmp',\n    text: 'data-jq-text',\n    click: 'data-jq-click',\n    dblclick: 'data-jq-dblclick',\n    blur: 'data-jq-blur',\n    focus: 'data-jq-focus',\n    hover: 'data-jq-hover',\n    change: 'data-jq-change',\n    submit: 'data-jq-submit',\n    model: 'data-jq-model',\n    show: 'data-jq-show',\n    css: 'data-jq-css',\n    attr: 'data-jq-attr',\n    forOf: 'data-jq-for',\n    if: 'data-jq-if',\n    switch: 'data-jq-switch',\n    case: 'data-jq-case',\n    default: 'data-jq-default',\n};\nconst serverRenderedAttr = 'data-server-rendered';\nconst dataIndexAttr = 'data-index';\nconst commentPrefix = {\n    forOf: 'data-forOf_',\n    if: 'data-if_',\n    case: 'data-case_',\n    default: 'data-default_',\n};\nconst commentSuffix = '_end';\n\n// global setting of underscore template inteprolate default token\nconst templateSettings = {\n    evaluate: /<%([\\s\\S]+?)%>/g,\n    interpolate: /\\{\\{=(.+?)\\}\\}/g,\n    escape: /\\{\\{(.+?)\\}\\}/g,\n};\n\nconst bindingDataReference = {\n    rootDataKey: '$root',\n    currentData: '$data',\n    currentIndex: '$index',\n    mouseEnterHandlerName: 'in',\n    mouseLeaveHandlerName: 'out',\n};\n\nconst bindingUpdateConditions = {\n    serverRendered: 'SERVER-RENDERED',\n    init: 'INIT',\n};\n\n// maximum string length before running regex\nconst maxDatakeyLength = 50;\n\nconst constants = {\n    filters: {\n        ONCE: 'once',\n    },\n    PARENT_REF: '_parent',\n};\n\nexport {\n    bindingAttrs,\n    dataIndexAttr,\n    templateSettings,\n    serverRenderedAttr,\n    commentPrefix,\n    commentSuffix,\n    bindingUpdateConditions,\n    bindingDataReference,\n    maxDatakeyLength,\n    constants,\n};\n","import * as config from './config';\n\n// require to use lodash\n_ = window._ || {};\n\nconst hasIsArray = Array.isArray;\n\nconst supportPromise = typeof window['Promise'] === 'function';\n\nconst REGEX = {\n    FUNCTIONPARAM: /\\((.*?)\\)/,\n    WHITESPACES: /\\s+/g,\n    FOROF: /(.*?)\\s+(?:in|of)\\s+(.*)/,\n    PIPE: /\\|/,\n};\n\nconst generateElementCache = (bindingAttrs) => {\n    const elementCache = {};\n    $.each(bindingAttrs, function(k, v) {\n        elementCache[v] = [];\n    });\n    return elementCache;\n};\n\nconst isArray = (obj) => {\n    return hasIsArray ? Array.isArray(obj) : Object.prototype.toString.call(obj) === '[object Array]';\n};\n\nconst isJsObject = (obj) => {\n    return obj !== null && typeof obj === 'object' && Object.prototype.toString.call(obj) === '[object Object]';\n};\n\nconst isPlainObject = (obj) => {\n    if (!isJsObject(obj)) {\n        return false;\n    }\n\n    // If has modified constructor\n    const ctor = obj.constructor;\n    if (typeof ctor !== 'function') return false;\n\n    // If has modified prototype\n    const prot = ctor.prototype;\n    if (isJsObject(prot) === false) return false;\n\n    // If constructor does not have an Object-specific method\n    if (prot.hasOwnProperty('isPrototypeOf') === false) {\n        return false;\n    }\n\n    // Most likely a plain Object\n    return true;\n};\n\nconst isEmptyObject = (obj) => {\n    if (isJsObject(obj)) {\n        return Object.getOwnPropertyNames(obj).length === 0;\n    }\n    return false;\n};\n\n/**\n * getViewModelValue\n * @description walk a object by provided string path. eg 'a.b.c'\n * @param {object} viewModel\n * @param {string} prop\n * @return {object}\n */\nconst getViewModelValue = (viewModel, prop) => {\n    return _.get(viewModel, prop);\n};\n\n/**\n * setViewModelValue\n * @description populate viewModel object by path string\n * @param {object} obj\n * @param {string} prop\n * @param {string} value\n * @return {call} underscore set\n */\nconst setViewModelValue = (obj, prop, value) => {\n    return _.set(obj, prop, value);\n};\n\nconst getViewModelPropValue = (viewModel, bindingCache) => {\n    let dataKey = bindingCache.dataKey;\n    let paramList = bindingCache.parameters;\n    const isInvertBoolean = dataKey.charAt(0) === '!';\n\n    if (isInvertBoolean) {\n        dataKey = isInvertBoolean ? dataKey.substring(1) : dataKey;\n    }\n\n    let ret = getViewModelValue(viewModel, dataKey);\n\n    if (typeof ret === 'function') {\n        const viewModelContext = resolveViewModelContext(viewModel, dataKey);\n        const oldViewModelProValue = bindingCache.elementData ? bindingCache.elementData.viewModelProValue : null;\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n        // let args = [oldViewModelProValue, bindingCache.el].concat(paramList);\n        const args = paramList.concat([oldViewModelProValue, bindingCache.el]);\n        ret = ret.apply(viewModelContext, args);\n    }\n\n    ret = isInvertBoolean ? !Boolean(ret) : ret;\n\n    // call through fitlers to get final value\n    ret = filtersViewModelPropValue({\n        value: ret,\n        viewModel: viewModel,\n        bindingCache: bindingCache,\n    });\n\n    return ret;\n};\n\nconst filtersViewModelPropValue = ({value, viewModel, bindingCache}) => {\n    let ret = value;\n    if (bindingCache.filters) {\n        each(bindingCache.filters, (index, filter) => {\n            const viewModelContext = resolveViewModelContext(viewModel, filter);\n            const filterFn = getViewModelValue.call(viewModelContext, viewModelContext, filter);\n            try {\n                ret = filterFn.call(viewModelContext, ret);\n            } catch (err) {\n                throwErrorMessage(err, `Invalid filter: ${filter}`);\n            }\n        });\n    }\n    return ret;\n};\n\nconst parseStringToJson = (str) => {\n    // fix unquote or single quote keys and replace single quote to double quote\n    const ret = str.replace(/(\\s*?{\\s*?|\\s*?,\\s*?)(['\"])?([a-zA-Z0-9]+)(['\"])?:/g, '$1\"$3\":').replace(/'/g, '\"');\n    return JSON.parse(ret);\n};\n\n/**\n * arrayRemoveMatch\n * @description remove match items in fromArray out of toArray\n * @param {array} toArray\n * @param {array} frommArray\n * @return {boolean}\n */\nconst arrayRemoveMatch = (toArray, frommArray) => {\n    return toArray.filter((value, index) => {\n        return frommArray.indexOf(value) < 0;\n    });\n};\n\nconst getFormData = ($form) => {\n    const sArray = $form.serializeArray();\n    const data = {};\n\n    sArray.map((n) => {\n        data[n['name']] = n['value'];\n    });\n\n    return data;\n};\n\n/**\n * getFunctionParameterList\n * @description convert parameter string to arrary\n * eg. '(\"a\",\"b\",\"c\")' > [\"a\",\"b\",\"c\"]\n * @param {string} str\n * @return {array} paramlist\n */\nconst getFunctionParameterList = (str) => {\n    if (!str || str.length > config.maxDatakeyLength) {\n        return;\n    }\n    let paramlist = str.match(REGEX.FUNCTIONPARAM);\n\n    if (paramlist && paramlist[1]) {\n        paramlist = paramlist[1].split(',');\n        paramlist.forEach(function(v, i) {\n            paramlist[i] = v.trim();\n        });\n    }\n    return paramlist;\n};\n\nconst extractFilterList = (cacheData) => {\n    if (!cacheData || !cacheData.dataKey || cacheData.dataKey.length > config.maxDatakeyLength) {\n        return cacheData;\n    }\n    const filterList = cacheData.dataKey.split(REGEX.PIPE);\n    let isOnceIndex;\n    cacheData.dataKey = filterList[0].trim();\n    if (filterList.length > 1) {\n        filterList.shift(0);\n        filterList.forEach(function(v, i) {\n            filterList[i] = v.trim();\n            if (filterList[i] === config.constants.filters.ONCE) {\n                cacheData.isOnce = true;\n                isOnceIndex = i;\n            }\n        });\n        // don't store filter 'once' - because it is internal logic not a property from viewModel\n        if (isOnceIndex >= 0) {\n            filterList.splice(isOnceIndex, 1);\n        }\n        cacheData.filters = filterList;\n    }\n    return cacheData;\n};\n\nconst invertObj = (sourceObj) => {\n    return Object.keys(sourceObj).reduce(function(obj, key) {\n        obj[sourceObj[key]] = key;\n        return obj;\n    }, {});\n};\n\nconst createDeferredObj = () => {\n    let dfObj = {};\n    if (supportPromise) {\n        dfObj.promise = new Promise((resolve, reject) => {\n            dfObj.resolve = resolve;\n            dfObj.reject = reject;\n        });\n    } else {\n        dfObj = $.Deferred(); // eslint-disable-line new-cap\n    }\n    return dfObj;\n};\n\n/**\n * debounce\n * @description decorate a function to be debounce using requestAnimationFrame\n * @param {function} fn\n * @param {context} ctx\n * @return {function}\n */\nconst debounceRaf = (fn, ctx = null) => {\n    return (function(fn, ctx) {\n        let dfObj = createDeferredObj();\n        let rafId = 0;\n\n        // return decorated fn\n        return function() {\n            /* eslint-disable prefer-rest-params */\n            const args = Array.from ? Array.from(arguments) : Array.prototype.slice.call(arguments);\n\n            window.cancelAnimationFrame(rafId);\n            rafId = window.requestAnimationFrame(() => {\n                try {\n                    // fn is Binder.render function\n                    fn.apply(ctx, args);\n                    // dfObj.resolve is function provided in .then promise chain\n                    // ctx is the current component\n                    dfObj.resolve(ctx);\n                } catch (err) {\n                    dfObj.reject(ctx, err);\n                }\n\n                // reset dfObj - otherwise then callbacks will not be in execution order\n                // example:\n                // myApp.render().then(function(){console.log('ok1')});\n                // myApp.render().then(function(){console.log('ok2')});\n                // myApp.render().then(function(){console.log('ok3')});\n                // >> ok1, ok2, ok3\n                dfObj = createDeferredObj();\n\n                window.cancelAnimationFrame(rafId);\n            });\n\n            /* eslint-enable prefer-rest-params */\n            return supportPromise ? dfObj.promise : dfObj.promise();\n        };\n    })(fn, ctx);\n};\n\n/**\n * getNodeAttrObj\n * @description convert Node attributes object to a json object\n * @param {object} node\n * @param {array} skipList\n * @return {object}\n */\nconst getNodeAttrObj = (node, skipList) => {\n    let attributesLength = 0;\n    let skipArray;\n\n    if (!node || node.nodeType !== 1 || !node.hasAttributes()) {\n        return;\n    }\n    if (skipList) {\n        skipArray = [];\n        skipArray = typeof skipList === 'string' ? skipArray.push(skipList) : skipList;\n    }\n    const attrObj = {};\n    attributesLength = node.attributes.length;\n\n    if (attributesLength) {\n        for (let i = 0; i < attributesLength; i += 1) {\n            const attribute = node.attributes.item(i);\n            attrObj[attribute.nodeName] = attribute.nodeValue;\n        }\n    }\n\n    if (isArray(skipArray)) {\n        skipArray.forEach((item) => {\n            if (attrObj[item]) {\n                delete attrObj[item];\n            }\n        });\n    }\n    return attrObj;\n};\n\n/**\n * extend\n * @param {boolean} isDeepMerge\n * @param {object} target\n * @param {object} sources\n * @return {object} merged object\n */\nconst extend = (isDeepMerge = false, target, ...sources) => {\n    if (!sources.length) {\n        return target;\n    }\n    const source = sources.shift();\n    if (source === undefined) {\n        return target;\n    }\n\n    if (!isDeepMerge) {\n        return Object.assign(target, ...sources);\n    }\n\n    if (isMergebleObject(target) && isMergebleObject(source)) {\n        Object.keys(source).forEach((key) => {\n            if (isMergebleObject(source[key])) {\n                if (!target[key]) {\n                    target[key] = {};\n                }\n                extend(target[key], source[key]);\n            } else {\n                target[key] = source[key];\n            }\n        });\n    }\n\n    return extend(true, target, ...sources);\n};\n\nconst each = (obj, fn) => {\n    if (typeof obj !== 'object' || typeof fn !== 'function') {\n        return;\n    }\n    let keys = [];\n    let keysLength = 0;\n    const isArrayObj = isArray(obj);\n    let key;\n    let value;\n    let i = 0;\n\n    if (isArrayObj) {\n        keysLength = obj.length;\n    } else if (isJsObject(obj)) {\n        keys = Object.keys(obj);\n        keysLength = keys.length;\n    } else {\n        throw new TypeError('Object is not an array or object');\n    }\n\n    for (i = 0; i < keysLength; i += 1) {\n        if (isArrayObj) {\n            key = i;\n            value = obj[i];\n        } else {\n            key = keys[i];\n            value = obj[key];\n        }\n        fn(key, value);\n    }\n};\n\nconst isMergebleObject = (item) => {\n    return isJsObject(item) && !isArray(item);\n};\n\n/**\n * cloneDomNode\n * @param {object} element\n * @return {object} cloned element\n * @description helper function to clone node\n */\nconst cloneDomNode = (element) => {\n    return element.cloneNode(true);\n};\n\n/**\n * insertAfter\n * @param {object} parentNode\n * @param {object} newNode\n * @param {object} referenceNode\n * @return {object} node\n * @description helper function to insert new node before the reference node\n */\nconst insertAfter = (parentNode, newNode, referenceNode) => {\n    const refNextElement = referenceNode && referenceNode.nextSibling ? referenceNode.nextSibling : null;\n    return parentNode.insertBefore(newNode, refNextElement);\n};\n\nconst resolveViewModelContext = (viewModel, datakey) => {\n    let ret = viewModel;\n    if (typeof datakey !== 'string') {\n        return ret;\n    }\n    const bindingDataContext = datakey.split('.');\n    if (bindingDataContext.length > 1) {\n        if (bindingDataContext[0] === config.bindingDataReference.rootDataKey) {\n            ret = viewModel[config.bindingDataReference.rootDataKey] || viewModel;\n        } else if (bindingDataContext[0] === config.bindingDataReference.currentData) {\n            ret = viewModel[config.bindingDataReference.currentData] || viewModel;\n        }\n    }\n    return ret;\n};\n\nconst resolveParamList = (viewModel, paramList) => {\n    if (!viewModel || !isArray(paramList)) {\n        return;\n    }\n    return paramList.map((param) => {\n        param = param.trim();\n\n        if (param === config.bindingDataReference.currentIndex) {\n            // convert '$index' to value\n            param = viewModel[config.bindingDataReference.currentIndex];\n        } else if (param === config.bindingDataReference.currentData) {\n            // convert '$data' to value or current viewModel\n            param = viewModel[config.bindingDataReference.currentData] || viewModel;\n        } else if (param === config.bindingDataReference.rootDataKey) {\n            // convert '$root' to root viewModel\n            param = viewModel[config.bindingDataReference.rootDataKey] || viewModel;\n        }\n        return param;\n    });\n};\n\nconst removeElement = (el) => {\n    if (el && el.parentNode) {\n        el.parentNode.removeChild(el);\n    }\n};\n\nconst throwErrorMessage = (err = null, errorMessage = '') => {\n    const message = err && err.message ? err.message : errorMessage;\n    if (typeof console.error === 'function') {\n        return console.error(message);\n    }\n    return console.log(message);\n};\n\nexport {\n    REGEX,\n    arrayRemoveMatch,\n    cloneDomNode,\n    debounceRaf,\n    each,\n    extend,\n    extractFilterList,\n    generateElementCache,\n    getFormData,\n    getFunctionParameterList,\n    getNodeAttrObj,\n    getViewModelPropValue,\n    getViewModelValue,\n    insertAfter,\n    invertObj,\n    isArray,\n    isEmptyObject,\n    isJsObject,\n    isPlainObject,\n    parseStringToJson,\n    removeElement,\n    resolveParamList,\n    resolveViewModelContext,\n    setViewModelValue,\n    throwErrorMessage,\n};\n","import {invertObj, extractFilterList, getFunctionParameterList, REGEX} from './util';\nimport {constants} from './config';\n\nlet bindingAttrsMap;\n\n/**\n * walkDOM\n * @description by Douglas Crockford - walk each DOM node and calls provided callback function\n * start walk from firstChild\n * @param {object} node\n * @param {function} func\n */\nconst walkDOM = (node, func) => {\n    let parseChildNode = true;\n    node = node.firstElementChild;\n    while (node) {\n        parseChildNode = func(node);\n        if (parseChildNode) {\n            walkDOM(node, func);\n        }\n        node = node.nextElementSibling;\n    }\n};\n\nconst getAttributesObject = (node) => {\n    const ret = {};\n    Array.prototype.slice.call(node.attributes).forEach((item) => {\n        ret[item.name] = item.value;\n    });\n    return ret;\n};\n\nconst checkSkipChildParseBindings = (attrObj = {}, bindingAttrs) => {\n    return [bindingAttrs.forOf, bindingAttrs.if, bindingAttrs.case, bindingAttrs.default].filter((type) => {\n        return typeof attrObj[type] !== 'undefined';\n    });\n};\n\nconst rootSkipCheck = (node) => {\n    return node.tagName === 'SVG';\n};\n\nconst defaultSkipCheck = (node, bindingAttrs) => {\n    return node.tagName === 'SVG' || node.hasAttribute(bindingAttrs.comp);\n};\n\nconst populateBindingCache = ({node, attrObj, bindingCache, type}) => {\n    let attrValue;\n    let cacheData;\n\n    if (bindingAttrsMap && bindingAttrsMap[type] && typeof attrObj[type] !== 'undefined') {\n        bindingCache[type] = bindingCache[type] || [];\n        attrValue = attrObj[type].trim();\n        cacheData = {\n            el: node,\n            dataKey: attrValue,\n        };\n\n        // populate cacheData.filters. update filterList first item as dataKey\n        cacheData = extractFilterList(cacheData);\n\n        // populate cacheData.parameters\n        // for store function call parameters eg. '$index', '$root'\n        // useful with DOM for-loop template as reference to binding data\n        const paramList = getFunctionParameterList(cacheData.dataKey);\n        if (paramList) {\n            cacheData.parameters = paramList;\n            cacheData.dataKey = cacheData.dataKey.replace(REGEX.FUNCTIONPARAM, '').trim();\n        }\n        // store parent array reference to cacheData\n        cacheData[constants.PARENT_REF] = bindingCache[type];\n        bindingCache[type].push(cacheData);\n    }\n    return bindingCache;\n};\n\nconst createBindingCache = ({rootNode = null, bindingAttrs = {}, skipCheck, isRenderedTemplate = false}) => {\n    let bindingCache = {};\n\n    if (!rootNode instanceof window.Node) {\n        throw new TypeError('walkDOM: Expected a DOM node');\n    }\n\n    bindingAttrsMap = bindingAttrsMap || invertObj(bindingAttrs);\n\n    const parseNode = (node, skipNodeCheckFn = defaultSkipCheck) => {\n        let isSkipForOfChild = false;\n\n        if (node.nodeType !== 1 || !node.hasAttributes()) {\n            return true;\n        }\n        if (skipNodeCheckFn(node, bindingAttrs) || (typeof skipCheck === 'function' && skipCheck(node))) {\n            return false;\n        }\n\n        // when creating sub bindingCache if is for tmp binding\n        // skip same element that has forOf binding the  forOf is alredy parsed\n        const attrObj = getAttributesObject(node);\n        const hasSkipChildParseBindings = checkSkipChildParseBindings(attrObj, bindingAttrs);\n        let iterateList = [];\n\n        if (hasSkipChildParseBindings.length) {\n            isSkipForOfChild = true;\n            iterateList = hasSkipChildParseBindings;\n        } else if (isRenderedTemplate && attrObj[bindingAttrs.tmp]) {\n            // skip current node parse if was called by node has template binding and already rendered\n            return true;\n        } else {\n            iterateList = Object.keys(attrObj);\n        }\n\n        iterateList.forEach((key) => {\n            // skip for switch case and default bining\n            if (key !== bindingAttrs.case && key !== bindingAttrs.default) {\n                bindingCache = populateBindingCache({\n                    node: node,\n                    attrObj: attrObj,\n                    bindingCache: bindingCache,\n                    type: key,\n                });\n            }\n        });\n\n        // after cache forOf skip parse child nodes\n        if (isSkipForOfChild) {\n            return false;\n        }\n\n        return true;\n    };\n\n    if (parseNode(rootNode, rootSkipCheck)) {\n        walkDOM(rootNode, parseNode);\n    }\n    return bindingCache;\n};\n\nexport default createBindingCache;\n","import {dataIndexAttr} from './config';\nimport {parseStringToJson, getViewModelPropValue} from './util';\n\nlet $domFragment = null;\nlet $templateRoot = null;\nlet nestTemplatesCount = 0;\nconst templateCache = {};\n\n/**\n * compileTemplate\n * @description compile underscore template and store in templateCache\n * @param {string} id\n * @param {object} templateData\n * @return {string} rendered html string\n */\nconst compileTemplate = (id, templateData = null) => {\n    let templateString;\n    let templateElement;\n\n    if (!templateCache[id]) {\n        templateElement = document.getElementById(id);\n        templateString = templateElement ? templateElement.innerHTML : '';\n        templateCache[id] = _.template(templateString, {\n            variable: 'data',\n        });\n    }\n\n    return templateCache[id](templateData);\n};\n\n/**\n * renderTemplate\n * @description\n * get template setting from DOM attribute then call compileTemplate\n * to render and append to target DOM\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {object} elementCache\n */\nconst renderTemplate = (cache, viewModel, bindingAttrs, elementCache) => {\n    const settings = typeof cache.dataKey === 'string' ? parseStringToJson(cache.dataKey) : cache.dataKey;\n    let viewData = settings.data;\n    const isAppend = settings.append;\n    const isPrepend = settings.prepend;\n    let $currentElement;\n\n    cache.dataKey = settings;\n\n    viewData =\n        typeof viewData === 'undefined' || viewData === '$root'\n            ? viewModel\n            : getViewModelPropValue(viewModel, {\n                dataKey: settings.data,\n                parameters: cache.parameters,\n            });\n\n    if (!viewData) {\n        return;\n    }\n\n    const $element = $(cache.el);\n    const $index = typeof viewModel.$index !== 'undefined' ? viewModel.$index : $element.attr(dataIndexAttr);\n    if (typeof $index !== 'undefined') {\n        viewData.$index = $index;\n    }\n    $domFragment = $domFragment ? $domFragment : $('<div/>');\n    $templateRoot = $templateRoot ? $templateRoot : $element;\n    const html = compileTemplate(settings.id, viewData);\n\n    // domFragment should be empty in first run\n    // append rendered html\n    if (!$domFragment.children().length) {\n        $currentElement = $domFragment;\n        $domFragment.append(html);\n    } else {\n        $currentElement = $element;\n        if (!isAppend && !isPrepend) {\n            $currentElement.empty();\n        }\n        if (isPrepend) {\n            $currentElement.prepend(html);\n        } else {\n            $currentElement.append(html);\n        }\n    }\n\n    // check if there are nested template then recurisive render them\n    const $nestedTemplates = $currentElement.find('[' + bindingAttrs.tmp + ']');\n\n    if ($nestedTemplates.length) {\n        nestTemplatesCount += $nestedTemplates.length;\n        $nestedTemplates.each(function(index, element) {\n            const thisTemplateCache = {\n                el: element,\n                dataKey: element.getAttribute(bindingAttrs.tmp),\n            };\n            elementCache[bindingAttrs.tmp].push(thisTemplateCache);\n            // recursive template render\n            renderTemplate(thisTemplateCache, viewModel, bindingAttrs, elementCache);\n            nestTemplatesCount -= 1;\n        });\n    }\n\n    // no more nested tempalted to render, start to append $domFragment into $templateRoot\n    if (nestTemplatesCount === 0) {\n        // append to DOM once\n        if (!isAppend && !isPrepend) {\n            $templateRoot.empty();\n        }\n        if (isPrepend) {\n            $templateRoot.prepend($domFragment.html());\n        } else {\n            $templateRoot.append($domFragment.html());\n        }\n        // clear cached fragment\n        $domFragment = $templateRoot = null;\n        // trigger callback if provided\n        if (typeof viewModel.afterTemplateRender === 'function') {\n            viewModel.afterTemplateRender(viewData);\n        }\n    }\n};\n\nexport default renderTemplate;\n","/* eslint-disable no-invalid-this */\nimport {getViewModelValue, setViewModelValue, resolveViewModelContext, resolveParamList} from './util';\n\n/**\n * changeBinding\n * @description input element on change event binding. DOM -> viewModel update\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {boolean} forceRender\n */\nconst changeBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n    const handlerName = cache.dataKey;\n    let paramList = cache.parameters;\n    const modelDataKey = cache.el.getAttribute(bindingAttrs.model);\n    let newValue = '';\n    let oldValue = '';\n    let viewModelContext;\n    const APP = viewModel.APP || viewModel.$root.APP;\n\n    if (!handlerName || (!forceRender && !APP.$rootElement.contains(cache.el))) {\n        return;\n    }\n\n    const handlerFn = getViewModelValue(viewModel, handlerName);\n\n    if (typeof handlerFn === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n\n        // assing on change event\n        $(cache.el)\n            .off('change.databind')\n            .on('change.databind', function(e) {\n                const $this = $(this);\n                const isCheckbox = $this.is(':checkbox');\n                newValue = isCheckbox ? $this.prop('checked') : _.escape($this.val());\n                // set data to viewModel\n                if (modelDataKey) {\n                    oldValue = getViewModelValue(viewModel, modelDataKey);\n                    setViewModelValue(viewModel, modelDataKey, newValue);\n                }\n                const args = [e, $this, newValue, oldValue].concat(paramList);\n                handlerFn.apply(viewModelContext, args);\n                oldValue = newValue;\n            });\n    }\n};\n\nexport default changeBinding;\n","/* eslint-disable no-invalid-this */\nimport * as config from './config';\nimport * as util from './util';\n\nconst createClonedElementCache = (bindingData) => {\n    const clonedElement = bindingData.el.cloneNode(true);\n    bindingData.fragment = document.createDocumentFragment();\n    bindingData.fragment.appendChild(clonedElement);\n    return bindingData;\n};\n\nconst setCommentPrefix = (bindingData) => {\n    if (!bindingData || !bindingData.type) {\n        return;\n    }\n    let commentPrefix = '';\n    const dataKeyMarker = bindingData.dataKey ? bindingData.dataKey.replace(util.REGEX.WHITESPACES, '_') : '';\n\n    switch (bindingData.type) {\n    case config.bindingAttrs.forOf:\n        commentPrefix = config.commentPrefix.forOf;\n        break;\n    case config.bindingAttrs.if:\n        commentPrefix = config.commentPrefix.if;\n        break;\n    case config.bindingAttrs.case:\n        commentPrefix = config.commentPrefix.case;\n        break;\n    case config.bindingAttrs.default:\n        commentPrefix = config.commentPrefix.default;\n        break;\n    }\n    bindingData.commentPrefix = commentPrefix + dataKeyMarker;\n    return bindingData;\n};\n\n/**\n * setDocRangeEndAfter\n * @param {object} node\n * @param {object} bindingData\n * @description\n * recursive execution to find last wrapping comment node\n * and set as bindingData.docRange.setEndAfter\n * if not found deleteContents will has no operation\n * @return {undefined}\n */\nconst setDocRangeEndAfter = (node, bindingData) => {\n    if (!bindingData.commentPrefix) {\n        setCommentPrefix(bindingData);\n    }\n    const startTextContent = bindingData.commentPrefix;\n    const endTextContent = startTextContent + config.commentSuffix;\n    node = node.nextSibling;\n\n    // check last wrap comment node\n    if (node) {\n        if (node.nodeType === 8 && node.textContent === endTextContent) {\n            return bindingData.docRange.setEndBefore(node);\n        }\n        setDocRangeEndAfter(node, bindingData);\n    }\n};\n\n/**\n * wrapCommentAround\n * @param {object} bindingData\n * @param {Node} node\n * @return {object} DOM fragment\n * @description\n * wrap frament with comment node\n */\nconst wrapCommentAround = (bindingData, node) => {\n    let prefix = '';\n    if (!bindingData.commentPrefix) {\n        setCommentPrefix(bindingData);\n    }\n    prefix = bindingData.commentPrefix;\n    const commentBegin = document.createComment(prefix);\n    const commentEnd = document.createComment(prefix + config.commentSuffix);\n    // document fragment - logic for ForOf binding\n    // check node.parentNode because node could be from cache and no longer in DOM\n    if (node.nodeType === 11) {\n        node.insertBefore(commentBegin, node.firstChild);\n        node.appendChild(commentEnd);\n    } else if (node.parentNode) {\n        node.parentNode.insertBefore(commentBegin, node);\n        util.insertAfter(node.parentNode, commentEnd, node);\n        // update bindingData details\n        bindingData.previousNonTemplateElement = node.previousSibling;\n        bindingData.nextNonTemplateElement = node.nextSibling;\n        bindingData.parentElement = node.previousSibling.parentElement;\n    }\n\n    return node;\n};\n\n/**\n * removeElemnetsByCommentWrap\n * @param {object} bindingData\n * @return {undefined}\n * @description remove elments by range\n */\nconst removeElemnetsByCommentWrap = (bindingData) => {\n    if (!bindingData.docRange) {\n        bindingData.docRange = document.createRange();\n    }\n    try {\n        if (bindingData.previousNonTemplateElement) {\n            // update docRange start and end match the wrapped comment node\n            bindingData.docRange.setStartBefore(bindingData.previousNonTemplateElement.nextSibling);\n            setDocRangeEndAfter(bindingData.previousNonTemplateElement.nextSibling, bindingData);\n        } else {\n            // insert before next non template element\n            bindingData.docRange.setStartBefore(bindingData.parentElement.firstChild);\n            setDocRangeEndAfter(bindingData.parentElement.firstChild, bindingData);\n        }\n    } catch (err) {\n        console.log('error removeElemnetsByCommentWrap: ', err.message);\n    }\n\n    return bindingData.docRange.deleteContents();\n};\n\n/**\n * removeDomTemplateElement\n * @param {object} bindingData\n * @return {object} null\n */\nconst removeDomTemplateElement = (bindingData) => {\n    // first render - forElement is live DOM element so has parentNode\n    if (bindingData.el.parentNode) {\n        return bindingData.el.parentNode.removeChild(bindingData.el);\n    }\n    removeElemnetsByCommentWrap(bindingData);\n};\n\nconst insertRenderedElements = (bindingData, fragment) => {\n    // insert rendered fragment after the previousNonTemplateElement\n    if (bindingData.previousNonTemplateElement) {\n        util.insertAfter(bindingData.parentElement, fragment, bindingData.previousNonTemplateElement);\n    } else {\n        // insert before next non template element\n        if (bindingData.nextNonTemplateElement) {\n            bindingData.parentElement.insertBefore(fragment, bindingData.nextNonTemplateElement);\n        } else if (bindingData.parentElement) {\n            // insert from parent\n            bindingData.parentElement.appendChild(fragment);\n        }\n    }\n};\n\nexport {\n    createClonedElementCache,\n    setCommentPrefix,\n    wrapCommentAround,\n    removeElemnetsByCommentWrap,\n    removeDomTemplateElement,\n    setDocRangeEndAfter,\n    insertRenderedElements,\n};\n","/* eslint-disable no-invalid-this */\nimport {bindingAttrs as configBindingAttrs, bindingDataReference} from './config';\nimport {getViewModelPropValue, isArray, isPlainObject, throwErrorMessage, cloneDomNode, isEmptyObject} from './util';\nimport createBindingCache from './domWalker';\nimport {renderIteration} from './binder';\nimport {wrapCommentAround, removeElemnetsByCommentWrap, insertRenderedElements} from './commentWrapper';\n\nconst renderForOfBinding = ({bindingData, viewModel, bindingAttrs}) => {\n    if (!bindingData || !viewModel || !bindingAttrs) {\n        return;\n    }\n    let keys;\n    let iterationDataLength;\n    const iterationData = getViewModelPropValue(viewModel, bindingData.iterator);\n    let isRegenerate = false;\n\n    // check iterationData and set iterationDataLength\n    if (isArray(iterationData)) {\n        iterationDataLength = iterationData.length;\n    } else if (isPlainObject(iterationData)) {\n        keys = Object.keys(iterationData);\n        iterationDataLength = keys.length;\n    } else {\n        // throw error but let script contince to run\n        return throwErrorMessage(null, 'iterationData is not an plain object or array');\n    }\n\n    // flag as pared for-of logic with bindingData.type\n    if (!bindingData.type) {\n        bindingData.type = configBindingAttrs.forOf;\n        wrapCommentAround(bindingData, bindingData.el);\n    }\n\n    // assign forOf internal id to bindingData once\n    if (typeof bindingData.iterationSize === 'undefined') {\n        // store iterationDataLength\n        bindingData.iterationSize = iterationDataLength;\n        // remove orignal node for-of attributes\n        bindingData.el.removeAttribute(bindingAttrs.forOf);\n        isRegenerate = true;\n    } else {\n        // only regenerate cache if iterationDataLength changed\n        isRegenerate = bindingData.iterationSize !== iterationDataLength;\n        // update iterationSize\n        bindingData.iterationSize = iterationDataLength;\n    }\n\n    if (!isRegenerate) {\n        bindingData.iterationBindingCache.forEach(function(elementCache, i) {\n            if (!isEmptyObject(elementCache)) {\n                const iterationVm = createIterationViewModel({\n                    bindingData: bindingData,\n                    viewModel: viewModel,\n                    iterationData: iterationData,\n                    keys: keys,\n                    index: i,\n                });\n                renderIteration({\n                    elementCache: elementCache,\n                    iterationVm: iterationVm,\n                    bindingAttrs: bindingAttrs,\n                    isRegenerate: false,\n                });\n            }\n        });\n\n        return;\n    }\n\n    // generate forOfBinding elements into fragment\n    const fragment = generateForOfElements(bindingData, viewModel, bindingAttrs, iterationData, keys);\n\n    removeElemnetsByCommentWrap(bindingData);\n\n    // insert fragment content into DOM\n    return insertRenderedElements(bindingData, fragment);\n};\n\nconst createIterationViewModel = ({bindingData, viewModel, iterationData, keys, index}) => {\n    const iterationVm = {};\n    iterationVm[bindingData.iterator.alias] = keys ? iterationData[keys[index]] : iterationData[index];\n    // populate common binding data reference\n    iterationVm[bindingDataReference.rootDataKey] = viewModel.$root || viewModel;\n    iterationVm[bindingDataReference.currentData] = iterationVm[bindingData.iterator.alias];\n    iterationVm[bindingDataReference.currentIndex] = index;\n    return iterationVm;\n};\n\nconst generateForOfElements = (bindingData, viewModel, bindingAttrs, iterationData, keys) => {\n    const fragment = document.createDocumentFragment();\n    const iterationDataLength = bindingData.iterationSize;\n    let clonedItem;\n    let iterationVm;\n    let iterationBindingCache;\n    let i = 0;\n\n    // create or clear exisitng iterationBindingCache\n    if (isArray(bindingData.iterationBindingCache)) {\n        bindingData.iterationBindingCache.length = 0;\n    } else {\n        bindingData.iterationBindingCache = [];\n    }\n\n    // generate forOf and append to DOM\n    for (i = 0; i < iterationDataLength; i += 1) {\n        clonedItem = cloneDomNode(bindingData.el);\n\n        // create bindingCache per iteration\n        iterationBindingCache = createBindingCache({\n            rootNode: clonedItem,\n            bindingAttrs: bindingAttrs,\n        });\n\n        bindingData.iterationBindingCache.push(iterationBindingCache);\n\n        if (!isEmptyObject(iterationBindingCache)) {\n            // create an iterationVm match iterator alias\n            iterationVm = createIterationViewModel({\n                bindingData: bindingData,\n                viewModel: viewModel,\n                iterationData: iterationData,\n                keys: keys,\n                index: i,\n            });\n\n            renderIteration({\n                elementCache: bindingData.iterationBindingCache[i],\n                iterationVm: iterationVm,\n                bindingAttrs: bindingAttrs,\n                isRegenerate: true,\n            });\n        }\n\n        fragment.appendChild(clonedItem);\n    }\n\n    return fragment;\n};\n\nexport default renderForOfBinding;\n","import {maxDatakeyLength} from './config';\nimport {REGEX} from './util';\nimport renderForOfBinding from './renderForOfBinding';\n\n/**\n * forOfBinding\n * @description\n * DOM decleartive for binding.\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n */\nconst forOfBinding = (cache, viewModel, bindingAttrs) => {\n    const dataKey = cache.dataKey;\n\n    if (!dataKey || dataKey.length > maxDatakeyLength) {\n        return;\n    }\n\n    if (!cache.iterator) {\n        if (dataKey.length > maxDatakeyLength) {\n            return;\n        }\n        // replace mess spaces with single space\n        cache.dataKey = cache.dataKey.replace(REGEX.WHITESPACES, ' ');\n        const forExpMatch = dataKey.match(REGEX.FOROF);\n\n        if (!forExpMatch) {\n            return;\n        }\n\n        cache.iterator = {};\n        cache.iterator.alias = forExpMatch[1].trim();\n\n        if (forExpMatch[2]) {\n            cache.iterator.dataKey = forExpMatch[2].trim();\n            cache.parentElement = cache.el.parentElement;\n            cache.previousNonTemplateElement = cache.el.previousSibling;\n            cache.nextNonTemplateElement = cache.el.nextSibling;\n        }\n    }\n\n    renderForOfBinding({\n        bindingData: cache,\n        viewModel: viewModel,\n        bindingAttrs: bindingAttrs,\n    });\n};\n\nexport default forOfBinding;\n","import {isEmptyObject} from './util';\nimport {renderIteration} from './binder';\nimport createBindingCache from './domWalker';\nimport {commentSuffix} from './config';\nimport {removeElemnetsByCommentWrap, insertRenderedElements} from './commentWrapper';\n\n/**\n * isTargetDomRemoved\n * @description check if DOM between 'start' and 'end' comment tag has been removed\n * @param {object} bindingData\n * @return {boolean}\n */\nconst isTargetDomRemoved = (bindingData) => {\n    let ret = false;\n    if (bindingData && bindingData.previousNonTemplateElement) {\n        const commentStartTextContent = bindingData.previousNonTemplateElement.textContent;\n        const endCommentTag = bindingData.previousNonTemplateElement.nextSibling;\n\n        if (endCommentTag.nodeType === 8) {\n            if (endCommentTag.textContent === commentStartTextContent + commentSuffix) {\n                ret = true;\n            }\n        }\n    }\n    return ret;\n};\n\nconst renderIfBinding = ({bindingData, viewModel, bindingAttrs}) => {\n    if (!bindingData.fragment) {\n        return;\n    }\n\n    const isDomRemoved = isTargetDomRemoved(bindingData);\n    let rootElement = bindingData.el;\n\n    // remove current old DOM.\n    // TODO: try preserve DOM\n    if (!isDomRemoved && !bindingData.isOnce) {\n        removeIfBinding(bindingData);\n        // use fragment for create iterationBindingCache\n        rootElement = bindingData.fragment.firstChild.cloneNode(true);\n    }\n\n    // walk clonedElement to create iterationBindingCache once\n    if (!bindingData.iterationBindingCache || !bindingData.hasIterationBindingCache) {\n        bindingData.iterationBindingCache = createBindingCache({\n            rootNode: rootElement,\n            bindingAttrs: bindingAttrs,\n        });\n    }\n\n    // only render if has iterationBindingCache\n    // means has other dataBindings to be render\n    if (!isEmptyObject(bindingData.iterationBindingCache)) {\n        bindingData.hasIterationBindingCache = true;\n        renderIteration({\n            elementCache: bindingData.iterationBindingCache,\n            iterationVm: viewModel,\n            bindingAttrs: bindingAttrs,\n            isRegenerate: true,\n        });\n    }\n\n    // insert to new rendered DOM\n    // TODO: check unnecessary insertion when DOM is preserved\n    insertRenderedElements(bindingData, rootElement);\n};\n\nconst removeIfBinding = (bindingData) => {\n    removeElemnetsByCommentWrap(bindingData);\n    // remove cache.IterationBindingCache to prevent memory leak\n    if (bindingData.hasIterationBindingCache) {\n        delete bindingData.iterationBindingCache;\n        delete bindingData.hasIterationBindingCache;\n    }\n};\n\nexport {renderIfBinding, removeIfBinding};\n","import {bindingAttrs as configBindingAttrs, constants} from './config';\nimport {getViewModelPropValue, removeElement} from './util';\nimport {createClonedElementCache, wrapCommentAround} from './commentWrapper';\nimport {renderIfBinding, removeIfBinding} from './renderIfBinding';\n\n/**\n * if-Binding\n * @description\n * DOM decleartive for binding.\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n */\nconst ifBinding = (cache, viewModel, bindingAttrs) => {\n    const dataKey = cache.dataKey;\n\n    // isOnce only return if there is no child bindings\n    if (!dataKey || (cache.isOnce && cache.hasIterationBindingCache === false)) {\n        return;\n    }\n\n    cache.elementData = cache.elementData || {};\n    cache.type = cache.type || configBindingAttrs.if;\n\n    const oldViewModelProValue = cache.elementData.viewModelPropValue;\n    // getViewModelPropValue could be return undefined or null\n    const viewModelPropValue = getViewModelPropValue(viewModel, cache) || false;\n\n    // do nothing if viewModel value not changed and no child bindings\n    if (oldViewModelProValue === viewModelPropValue && !cache.hasIterationBindingCache) {\n        return;\n    }\n\n    const shouldRender = Boolean(viewModelPropValue);\n\n    // remove this cache from parent array\n    if (!shouldRender && cache.isOnce && cache.el.parentNode) {\n        removeElement(cache.el);\n        // delete cache.fragment;\n        removeBindingInQueue({\n            viewModel: viewModel,\n            cache: cache,\n        });\n        return;\n    }\n\n    // store new show status\n    cache.elementData.viewModelPropValue = viewModelPropValue;\n\n    // only create fragment once\n    // wrap comment tag around\n    // remove if attribute from original element to allow later dataBind parsing\n    if (!cache.fragment) {\n        wrapCommentAround(cache, cache.el);\n        cache.el.removeAttribute(bindingAttrs.if);\n        createClonedElementCache(cache);\n    }\n\n    if (!shouldRender) {\n        // remove element\n        removeIfBinding(cache);\n    } else {\n        // render element\n        renderIfBinding({\n            bindingData: cache,\n            viewModel: viewModel,\n            bindingAttrs: bindingAttrs,\n        });\n\n        // if render once\n        // remove this cache from parent array if no child caches\n        if (cache.isOnce && !cache.hasIterationBindingCache) {\n            // delete cache.fragment;\n            removeBindingInQueue({\n                viewModel: viewModel,\n                cache: cache,\n            });\n        }\n    }\n};\n\nconst removeBindingInQueue = ({viewModel, cache}) => {\n    let ret = false;\n    if (viewModel.APP.postProcessQueue) {\n        viewModel.APP.postProcessQueue.push(\n            ((cache, index) => () => {\n                cache[constants.PARENT_REF].splice(index, 1);\n            })(cache, cache[constants.PARENT_REF].indexOf(cache))\n        );\n        ret = true;\n    }\n    return ret;\n};\n\nexport default ifBinding;\n","import {getViewModelPropValue} from './util';\nimport {createClonedElementCache, wrapCommentAround} from './commentWrapper';\nimport {renderIfBinding, removeIfBinding} from './renderIfBinding';\n/**\n * switch-Binding\n * @description\n * DOM decleartive switch binding.\n * switch parent element wrap direct child with case bindings\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n */\nconst switchBinding = (cache, viewModel, bindingAttrs) => {\n    const dataKey = cache.dataKey;\n\n    if (!dataKey) {\n        return;\n    }\n\n    cache.elementData = cache.elementData || {};\n\n    const newExpression = getViewModelPropValue(viewModel, cache);\n\n    if (newExpression === cache.elementData.viewModelPropValue) {\n        return;\n    }\n\n    cache.elementData.viewModelPropValue = newExpression;\n\n    // build switch cases if not yet defined\n    if (!cache.cases) {\n        const childrenElements = cache.el.children;\n        if (!childrenElements.length) {\n            return;\n        }\n        cache.cases = [];\n        for (let i = 0, elementLength = childrenElements.length; i < elementLength; i += 1) {\n            let caseData = null;\n            if (childrenElements[i].hasAttribute(bindingAttrs.case)) {\n                caseData = createCaseData(childrenElements[i], bindingAttrs.case);\n            } else if (childrenElements[i].hasAttribute(bindingAttrs.default)) {\n                caseData = createCaseData(childrenElements[i], bindingAttrs.default);\n                caseData.isDefault = true;\n            }\n            // create fragment by clone node\n            // wrap with comment tag\n            if (caseData) {\n                wrapCommentAround(caseData, caseData.el);\n                // remove binding attribute for later dataBind parse\n                if (caseData.isDefault) {\n                    caseData.el.removeAttribute(bindingAttrs.default);\n                } else {\n                    caseData.el.removeAttribute(bindingAttrs.case);\n                }\n                createClonedElementCache(caseData);\n                cache.cases.push(caseData);\n            }\n        }\n    }\n\n    if (cache.cases.length) {\n        let hasMatch = false;\n        // do switch operation - reuse if binding logic\n        for (let j = 0, casesLength = cache.cases.length; j < casesLength; j += 1) {\n            let newCaseValue;\n            if (cache.cases[j].dataKey) {\n                // set back to dataKey if nothing found in viewModel\n                newCaseValue = getViewModelPropValue(viewModel, cache.cases[j]) || cache.cases[j].dataKey;\n            }\n\n            if (newCaseValue === cache.elementData.viewModelPropValue || cache.cases[j].isDefault) {\n                hasMatch = true;\n                // render element\n                renderIfBinding({\n                    bindingData: cache.cases[j],\n                    viewModel: viewModel,\n                    bindingAttrs: bindingAttrs,\n                });\n\n                // remove other elements\n                removeUnmatchCases(cache.cases, j);\n                break;\n            }\n        }\n        // no match remove all cases\n        if (!hasMatch) {\n            removeUnmatchCases(cache.cases);\n        }\n    }\n};\n\nfunction removeUnmatchCases(cases, matchedIndex) {\n    cases.forEach((caseData, index) => {\n        if (index !== matchedIndex || typeof matchedIndex === 'undefined') {\n            removeIfBinding(caseData);\n            // remove cache.IterationBindingCache to prevent memory leak\n            if (caseData.hasIterationBindingCache) {\n                caseData.iterationBindingCache = null;\n                caseData.hasIterationBindingCache = false;\n            }\n        }\n    });\n}\n\nfunction createCaseData(node, attrName) {\n    const caseData = {\n        el: node,\n        dataKey: node.getAttribute(attrName),\n        type: attrName,\n    };\n    return caseData;\n}\n\nexport default switchBinding;\n","import * as util from './util';\n\n/**\n *  pubSub\n * @description use jQuery object as pubSub\n * @example EVENTS object strucure:\n *  EVENTS = {\n        'EVENT-NAME': [{ 'comp-id': fn }],\n        'EVENT-NAME2': [{ 'comp-id': fn }]\n    };\n */\n\nconst EVENTS = {};\n\nconst subscribeEvent = (instance = null, eventName = '', fn, isOnce = false) => {\n    if (!instance || !instance.compId || !eventName || typeof fn !== 'function') {\n        return;\n    }\n\n    let subscriber;\n    let isSubscribed = false;\n\n    eventName = eventName.replace(util.REGEX.WHITESPACES, '');\n    EVENTS[eventName] = EVENTS[eventName] || [];\n    // check if already subscribed and update callback fn\n    isSubscribed = EVENTS[eventName].some((subscriber) => {\n        if (subscriber[instance.compId]) {\n            subscriber[instance.compId] = fn.bind(instance.viewModel);\n            subscriber.isOnce = isOnce;\n            return true;\n        }\n    });\n    // push if not yet subscribe\n    if (!isSubscribed) {\n        subscriber = {};\n        subscriber[instance.compId] = fn.bind(instance.viewModel);\n        subscriber.isOnce = isOnce;\n        EVENTS[eventName].push(subscriber);\n    }\n};\n\nconst subscribeEventOnce = (instance = null, eventName = '', fn) => {\n    subscribeEvent(instance, eventName, fn, true);\n};\n\nconst unsubscribeEvent = (compId = '', eventName = '') => {\n    if (!compId || !eventName) {\n        return;\n    }\n\n    let i = 0;\n    let subscribersLength = 0;\n    let subscriber;\n\n    eventName = eventName.replace(util.REGEX.WHITESPACES, '');\n\n    if (EVENTS[eventName]) {\n        subscribersLength = EVENTS[eventName].length;\n        for (i = 0; i < subscribersLength; i += 1) {\n            subscriber = EVENTS[eventName][i];\n            if (subscriber[compId]) {\n                EVENTS[eventName].splice(i, 1);\n                break;\n            }\n        }\n    }\n    // delete the event if no more subscriber\n    if (!EVENTS[eventName].length) {\n        delete EVENTS[eventName];\n    }\n};\n\n/**\n * unsubscribeAllEvent\n * @description unsubscribe all event by compId. eg when a component removed\n * @param {string} compId\n */\nconst unsubscribeAllEvent = (compId = '') => {\n    if (!compId) {\n        return;\n    }\n    Object.keys(EVENTS).forEach((eventName) => {\n        unsubscribeEvent(compId, eventName);\n    });\n};\n\nconst publishEvent = (eventName = '', ...args) => {\n    if (!eventName || !EVENTS[eventName]) {\n        return;\n    }\n\n    eventName = eventName.replace(util.REGEX.WHITESPACES, '');\n\n    EVENTS[eventName].forEach((subscriber) => {\n        Object.keys(subscriber).forEach((compId) => {\n            if (typeof subscriber[compId] === 'function') {\n                const ret = subscriber[compId](...args);\n                if (subscriber.isOnce) {\n                    unsubscribeEvent(compId, eventName);\n                }\n                return ret;\n            }\n        });\n    });\n};\n\nexport {subscribeEvent, subscribeEventOnce, unsubscribeEvent, unsubscribeAllEvent, publishEvent};\n","import * as config from './config';\nimport {debounceRaf, extend, each, throwErrorMessage} from './util';\nimport renderTemplate from './renderTemplate';\nimport clickBinding from './clickBinding';\nimport dblclickBinding from './dbclickBinding';\nimport blurBinding from './blurBinding';\nimport focusBinding from './focusBinding';\nimport hoverBinding from './hoverBinding';\nimport changeBinding from './changeBinding';\nimport modelBinding from './modelBinding';\nimport submitBinding from './submitBinding';\nimport textBinding from './textBinding';\nimport showBinding from './showBinding';\nimport cssBinding from './cssBinding';\nimport attrBinding from './attrBinding';\nimport forOfBinding from './forOfBinding';\nimport ifBinding from './ifBinding';\nimport switchBinding from './switchBinding';\nimport createBindingCache from './domWalker';\nimport * as pubSub from './pubSub';\n\nlet compIdIndex = 0;\n\nclass Binder {\n    constructor($rootElement, viewModel, bindingAttrs) {\n        if ($rootElement instanceof window.jQuery && $rootElement.length) {\n            $rootElement = $rootElement.eq(0)[0];\n        }\n\n        if (!$rootElement || $rootElement.nodeType !== 1 || viewModel === null || typeof viewModel !== 'object') {\n            throw new TypeError('$rootElement or viewModel is invalid');\n        }\n\n        this.initRendered = false;\n\n        this.compId = compIdIndex += 1;\n\n        this.$rootElement = $rootElement;\n\n        this.viewModel = viewModel;\n\n        this.bindingAttrs = bindingAttrs;\n\n        this.render = debounceRaf(this.render, this);\n\n        this.isServerRendered = this.$rootElement.getAttribute(config.serverRenderedAttr) !== null;\n\n        // inject instance into viewModel\n        this.viewModel.APP = this;\n\n        this.viewModel.$root = this.viewModel;\n\n        this.parseView();\n\n        // for jquery user set viewModel referece to $rootElement for easy debug\n        // otherwise use Expando to attach viewModel to $rootElement\n        if (window.jQuery) {\n            window.jQuery(this.$rootElement).data(config.bindingDataReference.rootDataKey, this.viewModel);\n        } else {\n            this.$rootElement[config.bindingDataReference.rootDataKey] = this.viewModel;\n        }\n\n        return this;\n    }\n\n    /**\n     * parseView\n     * @description\n     * @return {this}\n     * traver from $rootElement to find each data-bind-* element\n     * then apply data binding\n     */\n    parseView() {\n        this.elementCache = createBindingCache({\n            rootNode: this.$rootElement,\n            bindingAttrs: this.bindingAttrs,\n        });\n\n        // updateElementCache if server rendered on init\n        if (this.isServerRendered && !this.initRendered) {\n            this.updateElementCache({\n                templateCache: true,\n            });\n        }\n        return this;\n    }\n\n    /**\n     * updateElementCache\n     * @param {object} opt\n     * @description call createBindingCache to parse view and generate bindingCache\n     */\n    updateElementCache(opt = {}) {\n        const elementCache = opt.elementCache || this.elementCache;\n\n        if (opt.allCache) {\n            // walk dom from root element to regenerate elementCache\n            this.elementCache = createBindingCache({\n                rootNode: this.$rootElement,\n                bindingAttrs: this.bindingAttrs,\n            });\n        }\n        // walk from first rendered template node to create/update child bindingCache\n        if (opt.allCache || opt.templateCache) {\n            if (elementCache[this.bindingAttrs.tmp] && elementCache[this.bindingAttrs.tmp].length) {\n                elementCache[this.bindingAttrs.tmp].forEach((cache) => {\n                    // set skipCheck as skipForOfParseFn whenever an node has\n                    // both template and forOf bindings\n                    // then the template bindingCache should be an empty object\n                    let skipForOfParseFn = null;\n                    if (cache.el.hasAttribute(this.bindingAttrs.forOf)) {\n                        skipForOfParseFn = () => {\n                            return true;\n                        };\n                    }\n                    cache.bindingCache = createBindingCache({\n                        rootNode: cache.el,\n                        bindingAttrs: this.bindingAttrs,\n                        skipCheck: skipForOfParseFn,\n                        isRenderedTemplate: opt.isRenderedTemplates,\n                    });\n                });\n            }\n        }\n    }\n\n    render(opt = {}) {\n        let updateOption = {};\n        if (!this.initRendered) {\n            // only update eventsBinding if server rendered\n            if (this.isServerRendered) {\n                this.$rootElement.removeAttribute(config.serverRenderedAttr);\n                updateOption = createBindingOption(config.bindingUpdateConditions.serverRendered, opt);\n            } else {\n                updateOption = createBindingOption(config.bindingUpdateConditions.init, opt);\n            }\n        } else {\n            // when called again only update visualBinding options\n            updateOption = createBindingOption('', opt);\n        }\n\n        // create postProcessQueue before start rendering\n        this.postProcessQueue = [];\n\n        // render and apply binding to template(s)\n        // this is an share function therefore passing 'this' context\n        renderTemplatesBinding({\n            ctx: this,\n            elementCache: this.elementCache,\n            updateOption: updateOption,\n            bindingAttrs: this.bindingAttrs,\n            viewModel: this.viewModel,\n        });\n\n        // apply bindings to rest of the DOM\n        Binder.applyBinding({\n            ctx: this,\n            elementCache: this.elementCache,\n            updateOption: updateOption,\n            bindingAttrs: this.bindingAttrs,\n            viewModel: this.viewModel,\n        });\n\n        // trigger postProcess\n        Binder.postProcess(this.postProcessQueue);\n        // clear postProcessQueue\n        this.postProcessQueue.length = 0;\n        delete this.postProcessQueue;\n\n        this.initRendered = true;\n    }\n\n    static applyBinding({ctx, elementCache, updateOption, bindingAttrs, viewModel}) {\n        if (!elementCache || !updateOption) {\n            return;\n        }\n\n        // the follow binding should be in order for better efficiency\n\n        // apply forOf Binding\n        if (updateOption.forOfBinding && elementCache[bindingAttrs.forOf] && elementCache[bindingAttrs.forOf].length) {\n            elementCache[bindingAttrs.forOf].forEach((cache) => {\n                forOfBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n            });\n        }\n\n        // apply attr Binding\n        if (updateOption.attrBinding && elementCache[bindingAttrs.attr] && elementCache[bindingAttrs.attr].length) {\n            elementCache[bindingAttrs.attr].forEach((cache) => {\n                attrBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n            });\n        }\n\n        // apply if Binding\n        if (updateOption.ifBinding && elementCache[bindingAttrs.if] && elementCache[bindingAttrs.if].length) {\n            elementCache[bindingAttrs.if].forEach((cache) => {\n                ifBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n            });\n        }\n\n        // apply show Binding\n        if (updateOption.showBinding && elementCache[bindingAttrs.show] && elementCache[bindingAttrs.show].length) {\n            elementCache[bindingAttrs.show].forEach((cache) => {\n                showBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n            });\n        }\n\n        // apply switch Binding\n        if (\n            updateOption.switchBinding &&\n            elementCache[bindingAttrs.switch] &&\n            elementCache[bindingAttrs.switch].length\n        ) {\n            elementCache[bindingAttrs.switch].forEach((cache) => {\n                switchBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n            });\n        }\n\n        // apply text binding\n        if (updateOption.textBinding && elementCache[bindingAttrs.text] && elementCache[bindingAttrs.text].length) {\n            elementCache[bindingAttrs.text].forEach((cache) => {\n                textBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n            });\n        }\n\n        // apply cssBinding\n        if (updateOption.cssBinding && elementCache[bindingAttrs.css] && elementCache[bindingAttrs.css].length) {\n            elementCache[bindingAttrs.css].forEach((cache) => {\n                cssBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n            });\n        }\n\n        // apply model binding\n        if (updateOption.modelBinding && elementCache[bindingAttrs.model] && elementCache[bindingAttrs.model].length) {\n            elementCache[bindingAttrs.model].forEach((cache) => {\n                modelBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n            });\n        }\n\n        // apply change binding\n        if (\n            updateOption.changeBinding &&\n            elementCache[bindingAttrs.change] &&\n            elementCache[bindingAttrs.change].length\n        ) {\n            elementCache[bindingAttrs.change].forEach((cache) => {\n                changeBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n            });\n        }\n\n        // apply submit binding\n        if (\n            updateOption.submitBinding &&\n            elementCache[bindingAttrs.submit] &&\n            elementCache[bindingAttrs.submit].length\n        ) {\n            elementCache[bindingAttrs.submit].forEach((cache) => {\n                submitBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n            });\n        }\n\n        // apply click binding\n        if (updateOption.clickBinding && elementCache[bindingAttrs.click] && elementCache[bindingAttrs.click].length) {\n            elementCache[bindingAttrs.click].forEach((cache) => {\n                clickBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n            });\n        }\n\n        // apply double click binding\n        if (\n            updateOption.dblclickBinding &&\n            elementCache[bindingAttrs.dblclick] &&\n            elementCache[bindingAttrs.dblclick].length\n        ) {\n            elementCache[bindingAttrs.dblclick].forEach((cache) => {\n                dblclickBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n            });\n        }\n\n        // apply blur binding\n        if (updateOption.blurBinding && elementCache[bindingAttrs.blur] && elementCache[bindingAttrs.blur].length) {\n            elementCache[bindingAttrs.blur].forEach((cache) => {\n                blurBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n            });\n        }\n\n        // apply focus binding\n        if (updateOption.focusBinding && elementCache[bindingAttrs.focus] && elementCache[bindingAttrs.focus].length) {\n            elementCache[bindingAttrs.focus].forEach((cache) => {\n                focusBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n            });\n        }\n\n        // apply hover binding\n        if (updateOption.hoverBinding && elementCache[bindingAttrs.hover] && elementCache[bindingAttrs.hover].length) {\n            elementCache[bindingAttrs.hover].forEach((cache) => {\n                hoverBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n            });\n        }\n    }\n\n    static postProcess(tasks) {\n        if (!tasks || !tasks.length) {\n            return;\n        }\n        each(tasks, (index, task) => {\n            if (typeof task === 'function') {\n                try {\n                    task();\n                } catch (err) {\n                    throwErrorMessage(err, 'Error postProcess: ' + String(task));\n                }\n            }\n        });\n    }\n\n    subscribe(eventName = '', fn) {\n        pubSub.subscribeEvent(this, eventName, fn);\n        return this;\n    }\n\n    subscribeOnce(eventName = '', fn) {\n        pubSub.subscribeEventOnce(this, eventName, fn);\n        return this;\n    }\n\n    unsubscribe(eventName = '') {\n        pubSub.unsubscribeEvent(this.compId, eventName);\n        return this;\n    }\n\n    unsubscribeAll() {\n        pubSub.unsubscribeAllEvent(this.compId);\n        return this;\n    }\n\n    publish(eventName = '', ...args) {\n        pubSub.publishEvent(eventName, ...args);\n        return this;\n    }\n}\n\nconst renderTemplatesBinding = ({ctx, elementCache, updateOption, bindingAttrs, viewModel}) => {\n    if (!elementCache || !bindingAttrs) {\n        return false;\n    }\n    // render and apply binding to template(s) and forOf DOM\n    if (elementCache[bindingAttrs.tmp] && elementCache[bindingAttrs.tmp].length) {\n        // when re-render call with {templateBinding: true}\n        // template and nested templates\n        if (updateOption.templateBinding) {\n            // overwrite updateOption with 'init' bindingUpdateConditions\n            updateOption = createBindingOption(config.bindingUpdateConditions.init);\n\n            elementCache[bindingAttrs.tmp].forEach(($element) => {\n                renderTemplate($element, viewModel, bindingAttrs, elementCache);\n            });\n            // update cache after all template(s) rendered\n            ctx.updateElementCache({\n                templateCache: true,\n                elementCache: elementCache,\n                isRenderedTemplates: true,\n            });\n        }\n        // enforce render even element is not in DOM tree\n        updateOption.forceRender = true;\n\n        // apply bindings to rendered templates element\n        elementCache[bindingAttrs.tmp].forEach((cache) => {\n            Binder.applyBinding({\n                elementCache: cache.bindingCache,\n                updateOption: updateOption,\n                bindingAttrs: bindingAttrs,\n                viewModel: viewModel,\n            });\n        });\n    }\n    return true;\n};\n\n/**\n * createBindingOption\n * @param {string} condition\n * @param {object} opt\n * @description\n * generate binding update option object by condition\n * @return {object} updateOption\n */\nconst createBindingOption = (condition = '', opt = {}) => {\n    const visualBindingOptions = {\n        templateBinding: false,\n        textBinding: true,\n        cssBinding: true,\n        ifBinding: true,\n        showBinding: true,\n        modelBinding: true,\n        attrBinding: true,\n        forOfBinding: true,\n        switchBinding: true,\n    };\n    const eventsBindingOptions = {\n        changeBinding: true,\n        clickBinding: true,\n        dblclickBinding: true,\n        blurBinding: true,\n        focusBinding: true,\n        hoverBinding: true,\n        submitBinding: true,\n    };\n    // this is visualBindingOptions but everything false\n    // concrete declear for performance purpose\n    const serverRenderedOptions = {\n        templateBinding: false,\n        textBinding: false,\n        cssBinding: false,\n        ifBinding: false,\n        showBinding: false,\n        modelBinding: false,\n        attrBinding: false,\n        forOfBinding: false,\n        switchBinding: false,\n    };\n    let updateOption = {};\n\n    switch (condition) {\n    case config.bindingUpdateConditions.serverRendered:\n        updateOption = extend({}, eventsBindingOptions, serverRenderedOptions, opt);\n        break;\n    case config.bindingUpdateConditions.init:\n        // flag templateBinding to true to render tempalte(s)\n        opt.templateBinding = true;\n        updateOption = extend({}, visualBindingOptions, eventsBindingOptions, opt);\n        break;\n    default:\n        // when called again only update visualBinding options\n        updateOption = extend({}, visualBindingOptions, opt);\n    }\n\n    return updateOption;\n};\n\n/**\n * renderIteration\n * @param {object} opt\n * @description\n * render element's binding by supplied elementCache\n * This function is desidned for FoOf, If, switch bindings\n */\nconst renderIteration = ({elementCache, iterationVm, bindingAttrs, isRegenerate}) => {\n    const bindingUpdateOption = isRegenerate\n        ? createBindingOption(config.bindingUpdateConditions.init)\n        : createBindingOption();\n\n    // enforce render even element is not in DOM tree\n    bindingUpdateOption.forceRender = true;\n\n    // render and apply binding to template(s)\n    // this is an share function therefore passing current APP 'this' context\n    // viewModel is a dynamic generated iterationVm\n    renderTemplatesBinding({\n        ctx: iterationVm.$root ? iterationVm.$root.APP : iterationVm.APP,\n        elementCache: elementCache,\n        updateOption: bindingUpdateOption,\n        bindingAttrs: bindingAttrs,\n        viewModel: iterationVm,\n    });\n\n    Binder.applyBinding({\n        elementCache: elementCache,\n        updateOption: bindingUpdateOption,\n        bindingAttrs: bindingAttrs,\n        viewModel: iterationVm,\n    });\n};\n\nexport {Binder, createBindingOption, renderTemplatesBinding, renderIteration};\n","import {getViewModelPropValue, isPlainObject, isEmptyObject, each} from './util';\n\n/**\n * attrBinding\n * @description\n * DOM decleartive attr binding. update elenment attributes\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n */\nconst attrBinding = (cache, viewModel, bindingAttrs) => {\n    const dataKey = cache.dataKey;\n\n    if (!dataKey) {\n        return;\n    }\n\n    cache.elementData = cache.elementData || {};\n    cache.elementData.viewModelProValue = cache.elementData.viewModelProValue || {};\n\n    const oldAttrObj = cache.elementData.viewModelProValue;\n    const vmAttrObj = getViewModelPropValue(viewModel, cache);\n\n    if (!isPlainObject(vmAttrObj)) {\n        return;\n    }\n\n    // reject if nothing changed\n    if (JSON.stringify(oldAttrObj) === JSON.stringify(vmAttrObj)) {\n        return;\n    }\n\n    // reset old data and update it\n    cache.elementData.viewModelProValue = {};\n\n    if (isEmptyObject(oldAttrObj)) {\n        each(vmAttrObj, (key, value)=> {\n            cache.el.setAttribute(key, value);\n            // populate with vmAttrObj data\n            cache.elementData.viewModelProValue[key] = value;\n        });\n    } else {\n        each(oldAttrObj, (key, value)=> {\n            if (typeof vmAttrObj[key] === 'undefined') {\n                // remove attribute if not present in current vm\n                cache.el.removeAttribute(key);\n            }\n        });\n\n        each(vmAttrObj, (key, value)=> {\n            if (oldAttrObj[key] !== vmAttrObj[key]) {\n                // update attribute if value changed\n                cache.el.setAttribute(key, vmAttrObj[key]);\n            }\n            // populate with vmAttrObj data\n            cache.elementData.viewModelProValue[key] = value;\n        });\n    }\n};\n\nexport default attrBinding;\n","import {getViewModelPropValue} from './util';\n\n/**\n * showBinding\n * @description\n * DOM decleartive show binding. Make binding show/hide according to viewModel data (boolean)\n * viewModel data can function but must return boolean\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n */\nconst showBinding = (cache, viewModel, bindingAttrs) => {\n    const dataKey = cache.dataKey;\n    let currentInlineSytle = {};\n    let currentInlineDisplaySytle = '';\n    let shouldShow = true;\n\n    if (!dataKey) {\n        return;\n    }\n\n    cache.elementData = cache.elementData || {};\n\n    const oldShowStatus = cache.elementData.viewModelPropValue;\n\n    // store current element display default style once only\n    if (\n        typeof cache.elementData.displayStyle === 'undefined' ||\n        typeof cache.elementData.computedStyle === 'undefined'\n    ) {\n        currentInlineSytle = cache.el.style;\n        currentInlineDisplaySytle = currentInlineSytle.display;\n        // use current inline style if defined\n        if (currentInlineDisplaySytle) {\n            // set to 'block' if is 'none'\n            cache.elementData.displayStyle = currentInlineDisplaySytle === 'none' ? 'block' : currentInlineDisplaySytle;\n            cache.elementData.computedStyle = null;\n        } else {\n            const computeStyle = window.getComputedStyle(cache.el, null).getPropertyValue('display');\n            cache.elementData.displayStyle = null;\n            cache.elementData.computedStyle = computeStyle;\n        }\n    }\n\n    shouldShow = getViewModelPropValue(viewModel, cache);\n\n    // treat undefined || null as false.\n    // eg if property doesn't exsits in viewModel, it will treat as false to hide element\n    shouldShow = Boolean(shouldShow);\n\n    // reject if nothing changed\n    if (oldShowStatus === shouldShow) {\n        return;\n    }\n\n    if (!shouldShow) {\n        if (cache.el.style.display !== 'none') {\n            cache.el.style.setProperty('display', 'none');\n        }\n    } else {\n        if (cache.elementData.computedStyle || cache.el.style.display === 'none') {\n            if (cache.elementData.computedStyle === 'none') {\n                // default display is none in css rule, so use display 'block'\n                cache.el.style.setProperty('display', 'block');\n            } else {\n                // has default displayable type so just remove inline display 'none'\n                if (currentInlineSytle.length > 1) {\n                    cache.el.style.removeProperty('display');\n                } else {\n                    cache.el.removeAttribute('style');\n                }\n            }\n        } else {\n            // element default display was inline style, so restore it\n            cache.el.style.setProperty('display', cache.elementData.displayStyle);\n        }\n    }\n\n    // store new show status\n    cache.elementData.viewModelPropValue = shouldShow;\n};\n\nexport default showBinding;\n","import {getViewModelPropValue} from './util';\n\n/**\n * textBinding\n * * @description\n * DOM decleartive text binding update dom textnode with viewModel data\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {boolean} forceRender\n */\nconst textBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n    const dataKey = cache.dataKey;\n    const APP = viewModel.APP || viewModel.$root.APP;\n\n    // NOTE: this doesn't work for for-of, if and switch bindings because element was not in DOM\n    if (!dataKey || (!forceRender && !APP.$rootElement.contains(cache.el))) {\n        return;\n    }\n\n    const newValue = getViewModelPropValue(viewModel, cache);\n    const oldValue = cache.el.textContent;\n\n    if (typeof newValue !== 'undefined' && typeof newValue !== 'object' && newValue !== null) {\n        if (newValue !== oldValue) {\n            cache.el.textContent = newValue;\n        }\n    }\n};\n\nexport default textBinding;\n","import {getViewModelPropValue, isPlainObject, arrayRemoveMatch, each} from './util';\n\n/**\n * cssBinding\n * @description\n * DOM decleartive css binding. update classlist.\n * viewModel data can function but must return JSOL.\n * added css class if value is true\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {boolean} forceRender\n */\nconst cssBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n    const dataKey = cache.dataKey;\n    const APP = viewModel.APP || viewModel.$root.APP;\n\n    if (!dataKey || (!forceRender && !APP.$rootElement.contains(cache.el))) {\n        return;\n    }\n\n    cache.elementData = cache.elementData || {};\n    cache.elementData.viewModelPropValue = cache.elementData.viewModelPropValue || '';\n\n    // let $element = $(cache.el);\n    const oldCssList = cache.elementData.viewModelPropValue;\n    let newCssList = '';\n    const vmCssListObj = getViewModelPropValue(viewModel, cache);\n    let vmCssListArray = [];\n    let isViewDataObject = false;\n    let isViewDataString = false;\n    let cssList = [];\n\n    if (typeof vmCssListObj === 'string') {\n        isViewDataString = true;\n    } else if (isPlainObject(vmCssListObj)) {\n        isViewDataObject = true;\n    } else {\n        // reject if vmCssListObj is not an object or string\n        return;\n    }\n\n    if (isViewDataObject) {\n        newCssList = JSON.stringify(vmCssListObj);\n    } else {\n        newCssList = vmCssListObj.replace(/\\s\\s+/g, ' ').trim();\n        vmCssListArray = newCssList.split(' ');\n    }\n    // reject if nothing changed\n    if (oldCssList === newCssList) {\n        return;\n    }\n\n    // get current css classes from element\n    const domCssList = cache.el.classList;\n    // clone domCssList as new array\n    const domCssListLength = domCssList.length;\n    for (let i = 0; i < domCssListLength; i += 1) {\n        cssList.push(domCssList[i]);\n    }\n\n    if (isViewDataObject) {\n        each(vmCssListObj, function(k, v) {\n            const i = cssList.indexOf(k);\n            if (v === true) {\n                cssList.push(k);\n            } else if (i !== -1) {\n                cssList.splice(i, 1);\n            }\n        });\n    } else if (isViewDataString) {\n        // remove oldCssList items from cssList\n        cssList = arrayRemoveMatch(cssList, oldCssList);\n        cssList = cssList.concat(vmCssListArray);\n    }\n\n    // unique cssList array\n    cssList = cssList.filter((v, i, a) => {\n        return a.indexOf(v) === i;\n    });\n\n    cssList = cssList.join(' ');\n    // update element data\n    cache.elementData.viewModelPropValue = newCssList;\n    // replace all css classes\n    cache.el.setAttribute('class', cssList);\n};\n\nexport default cssBinding;\n","import {getViewModelValue} from './util';\n\n/**\n * modelBinding\n * @description input element data binding. viewModel -> DOM update\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {boolean} forceRender\n */\nconst modelBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n    const dataKey = cache.dataKey;\n    let newValue = '';\n    const APP = viewModel.APP || viewModel.$root.APP;\n\n    if (!dataKey || (!forceRender && !APP.$rootElement.contains(cache.el))) {\n        return;\n    }\n\n    newValue = getViewModelValue(viewModel, dataKey);\n\n    if (typeof newValue !== 'undefined' && newValue !== null) {\n        const $element = $(cache.el);\n        const isCheckbox = $element.is(':checkbox');\n        const isRadio = $element.is(':radio');\n        const inputName = $element[0].name;\n        const $radioGroup = isRadio ? $('input[name=\"' + inputName + '\"]') : null;\n        const oldValue = isCheckbox ? $element.prop('checked') : $element.val();\n\n        // update element value\n        if (newValue !== oldValue) {\n            if (isCheckbox) {\n                $element.prop('checked', Boolean(newValue));\n            } else if (isRadio) {\n                $radioGroup.val([newValue]);\n            } else {\n                $element.val(newValue);\n            }\n        }\n    }\n};\n\nexport default modelBinding;\n","import {getViewModelValue, resolveViewModelContext, resolveParamList, getFormData} from './util';\n\n/**\n * submitBinding\n * @description on form submit binding. pass current form data as json object to handler\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {boolean} forceRender\n */\nconst submitBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n    const handlerName = cache.dataKey;\n    let paramList = cache.parameters;\n    let viewModelContext;\n    const APP = viewModel.APP || viewModel.$root.APP;\n\n    if (!handlerName || (!forceRender && !APP.$rootElement.contains(cache.el))) {\n        return;\n    }\n\n    const handlerFn = getViewModelValue(viewModel, handlerName);\n    const $element = $(cache.el);\n\n    if (typeof handlerFn === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n        // assing on change event\n        $element.off('submit.databind').on('submit.databind', function(e) {\n            const args = [e, $element, getFormData($element)].concat(paramList);\n            handlerFn.apply(viewModelContext, args);\n        });\n    }\n};\n\nexport default submitBinding;\n","/* eslint-disable no-invalid-this */\nimport {getViewModelValue, resolveViewModelContext, resolveParamList} from './util';\n\n/**\n * clickBinding\n * @description\n * DOM decleartive click event binding\n * event handler bind to viewModel method according to the DOM attribute\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {boolean} forceRender\n */\nconst clickBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n    const handlerName = cache.dataKey;\n    let paramList = cache.parameters;\n    let viewModelContext;\n    const APP = viewModel.APP || viewModel.$root.APP;\n\n    if (!handlerName || (!forceRender && !APP.$rootElement.contains(cache.el))) {\n        return;\n    }\n\n    const handlerFn = getViewModelValue(viewModel, handlerName);\n\n    if (typeof handlerFn === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n        $(cache.el)\n            .off('click.databind')\n            .on('click.databind', function(e) {\n                const args = [e, $(this)].concat(paramList);\n                handlerFn.apply(viewModelContext, args);\n            });\n    }\n};\n\nexport default clickBinding;\n","/* eslint-disable no-invalid-this */\nimport {getViewModelValue, resolveViewModelContext, resolveParamList} from './util';\n\n/**\n * dblclickBinding\n * DOM decleartive double click event binding\n * event handler bind to viewModel method according to the DOM attribute\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {boolean} forceRender\n */\nconst dblclickBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n    const handlerName = cache.dataKey;\n    let paramList = cache.parameters;\n    let viewModelContext;\n    const APP = viewModel.APP || viewModel.$root.APP;\n\n    if (!handlerName || (!forceRender && !APP.$rootElement.contains(cache.el))) {\n        return;\n    }\n\n    const handlerFn = getViewModelValue(viewModel, handlerName);\n\n    if (typeof handlerFn === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n        $(cache.el)\n            .off('dblclick.databind')\n            .on('dblclick.databind', function(e) {\n                const args = [e, $(this)].concat(paramList);\n                handlerFn.apply(viewModelContext, args);\n            });\n    }\n};\n\nexport default dblclickBinding;\n","/* eslint-disable no-invalid-this */\nimport {getViewModelValue, resolveViewModelContext, resolveParamList} from './util';\n\n/**\n * blurBinding\n * DOM decleartive on blur event binding\n * event handler bind to viewModel method according to the DOM attribute\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {boolean} forceRender\n */\nconst blurBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n    const handlerName = cache.dataKey;\n    let paramList = cache.parameters;\n    let viewModelContext;\n    const APP = viewModel.APP || viewModel.$root.APP;\n\n    if (!handlerName || (!forceRender && !APP.$rootElement.contains(cache.el))) {\n        return;\n    }\n\n    const handlerFn = getViewModelValue(viewModel, handlerName);\n\n    if (typeof handlerFn === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n\n        $(cache.el)\n            .off('blur.databind')\n            .on('blur.databind', function(e) {\n                const args = [e, $(this)].concat(paramList);\n                handlerFn.apply(viewModelContext, args);\n            });\n    }\n};\n\nexport default blurBinding;\n","/* eslint-disable no-invalid-this */\nimport {getViewModelValue, resolveViewModelContext, resolveParamList} from './util';\n\n/**\n * focusBinding\n * DOM decleartive on focus event binding\n * event handler bind to viewModel method according to the DOM attribute\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {boolean} forceRender\n */\nconst focusBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n    const handlerName = cache.dataKey;\n    let paramList = cache.parameters;\n    let viewModelContext;\n    const APP = viewModel.APP || viewModel.$root.APP;\n\n    if (!handlerName || (!forceRender && !APP.$rootElement.contains(cache.el))) {\n        return;\n    }\n\n    const handlerFn = getViewModelValue(viewModel, handlerName);\n\n    if (typeof handlerFn === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n        $(cache.el)\n            .off('focus.databind')\n            .on('focus.databind', function(e) {\n                const args = [e, $(this)].concat(paramList);\n                handlerFn.apply(viewModelContext, args);\n            });\n    }\n};\n\nexport default focusBinding;\n","/* eslint-disable no-invalid-this */\nimport {bindingDataReference} from './config';\nimport {getViewModelValue, resolveViewModelContext, resolveParamList} from './util';\n\n/**\n * blurBinding\n * DOM decleartive on blur event binding\n * event handler bind to viewModel method according to the DOM attribute\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {boolean} forceRender\n */\nconst hoverBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n    const handlerName = cache.dataKey;\n    let paramList = cache.parameters;\n    const inHandlerName = bindingDataReference.mouseEnterHandlerName;\n    const outHandlerName = bindingDataReference.mouseLeaveHandlerName;\n    let viewModelContext;\n    const APP = viewModel.APP || viewModel.$root.APP;\n\n    cache.elementData = cache.elementData || {};\n\n    if (!handlerName || (!forceRender && !APP.$rootElement.contains(cache.el))) {\n        return;\n    }\n\n    const handlers = getViewModelValue(viewModel, handlerName);\n\n    if (handlers && typeof handlers[inHandlerName] === 'function' && typeof handlers[outHandlerName] === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n\n        $(cache.el)\n            .off('mouseenter.databind mouseleave.databind')\n            .hover(\n                function enter(e) {\n                    const args = [e, cache.el].concat(paramList);\n                    handlers[inHandlerName].apply(viewModelContext, args);\n                },\n                function leave(e) {\n                    const args = [e, cache.el].concat(paramList);\n                    handlers[outHandlerName].apply(viewModelContext, args);\n                }\n            );\n    }\n};\n\nexport default hoverBinding;\n","import * as config from './config';\nimport {Binder} from './binder';\n\nlet bindingAttrs = config.bindingAttrs;\nlet templateSettings = config.templateSettings;\n\nconst use = (settings = {}) => {\n    if (settings.bindingAttrs) {\n        bindingAttrs = $.extend({}, settings.bindingAttrs);\n    }\n    if (settings.templateSettings) {\n        templateSettings = $.extend({}, settings.templateSettings);\n    }\n};\n\nconst init = ($rootElement, viewModel = null) => {\n    _.templateSettings = templateSettings;\n    return new Binder($rootElement, viewModel, bindingAttrs);\n};\n\n// expose to global\nwindow.dataBind = {\n    use: use,\n    init: init,\n    version: '@version@',\n};\n"],"names":["bindingAttrs","comp","tmp","text","click","dblclick","blur","focus","hover","change","submit","model","show","css","attr","forOf","serverRenderedAttr","commentPrefix","commentSuffix","bindingDataReference","bindingUpdateConditions","constants","ONCE","_","window","bindingAttrsMap","hasIsArray","Array","isArray","supportPromise","REGEX","obj","Object","prototype","toString","call","isJsObject","_typeof","isPlainObject","ctor","constructor","prot","hasOwnProperty","isEmptyObject","getOwnPropertyNames","length","getViewModelValue","viewModel","prop","get","getViewModelPropValue","bindingCache","dataKey","paramList","parameters","isInvertBoolean","charAt","substring","ret","viewModelContext","resolveViewModelContext","oldViewModelProValue","elementData","viewModelProValue","args","resolveParamList","concat","el","apply","Boolean","filtersViewModelPropValue","value","filters","each","index","filter","filterFn","err","throwErrorMessage","createDeferredObj","dfObj","promise","Promise","resolve","reject","$","Deferred","extend","isDeepMerge","target","sources","source","shift","undefined","isMergebleObject","keys","forEach","key","assign","fn","keysLength","isArrayObj","i","TypeError","item","insertAfter","parentNode","newNode","referenceNode","refNextElement","nextSibling","insertBefore","datakey","bindingDataContext","split","config","map","param","trim","errorMessage","message","console","error","log","$domFragment","$templateRoot","nestTemplatesCount","templateCache","renderTemplate","cache","elementCache","str","$currentElement","settings","replace","JSON","parse","viewData","data","isAppend","append","isPrepend","prepend","$element","$index","html","id","templateString","templateElement","templateData","document","getElementById","innerHTML","template","variable","compileTemplate","children","empty","$nestedTemplates","find","element","thisTemplateCache","getAttribute","push","afterTemplateRender","changeBinding","forceRender","handlerName","modelDataKey","newValue","oldValue","APP","$root","$rootElement","contains","handlerFn","off","on","e","$this","this","isCheckbox","is","escape","val","set","rootSkipCheck","node","tagName","defaultSkipCheck","hasAttribute","populateBindingCache","cacheData","attrObj","type","paramlist","match","v","getFunctionParameterList","isOnceIndex","filterList","isOnce","splice","extractFilterList","createBindingCache","sourceObj","rootNode","skipCheck","isRenderedTemplate","Node","reduce","parseNode","skipNodeCheckFn","isSkipForOfChild","nodeType","hasAttributes","slice","attributes","name","hasSkipChildParseBindings","checkSkipChildParseBindings","iterateList","walkDOM","func","firstElementChild","nextElementSibling","createClonedElementCache","bindingData","clonedElement","cloneNode","fragment","createDocumentFragment","appendChild","setCommentPrefix","dataKeyMarker","util","setDocRangeEndAfter","endTextContent","textContent","docRange","setEndBefore","wrapCommentAround","prefix","commentBegin","createComment","commentEnd","firstChild","previousNonTemplateElement","previousSibling","nextNonTemplateElement","parentElement","removeElemnetsByCommentWrap","createRange","setStartBefore","deleteContents","insertRenderedElements","createIterationViewModel","iterationData","iterationVm","iterator","alias","generateForOfElements","clonedItem","iterationBindingCache","iterationDataLength","iterationSize","renderIteration","isRegenerate","forOfBinding","forExpMatch","configBindingAttrs","removeAttribute","renderForOfBinding","renderIfBinding","isDomRemoved","commentStartTextContent","endCommentTag","isTargetDomRemoved","rootElement","removeIfBinding","hasIterationBindingCache","removeBindingInQueue","postProcessQueue","indexOf","removeUnmatchCases","cases","matchedIndex","caseData","createCaseData","attrName","EVENTS","subscribeEvent","instance","eventName","compId","subscriber","some","bind","subscribeEventOnce","unsubscribeEvent","subscribersLength","unsubscribeAllEvent","publishEvent","compIdIndex","Binder","jQuery","eq","initRendered","render","ctx","rafId","from","arguments","cancelAnimationFrame","requestAnimationFrame","debounceRaf","isServerRendered","parseView","updateOption","attrBinding","oldAttrObj","vmAttrObj","stringify","setAttribute","ifBinding","viewModelPropValue","shouldRender","removeChild","showBinding","currentInlineSytle","currentInlineDisplaySytle","shouldShow","oldShowStatus","displayStyle","computedStyle","style","display","computeStyle","getComputedStyle","getPropertyValue","setProperty","removeProperty","switchBinding","newExpression","childrenElements","elementLength","isDefault","hasMatch","j","casesLength","newCaseValue","textBinding","cssBinding","oldCssList","newCssList","vmCssListObj","vmCssListArray","isViewDataObject","isViewDataString","cssList","frommArray","domCssList","classList","domCssListLength","k","a","join","modelBinding","isRadio","inputName","$radioGroup","submitBinding","$form","sArray","serializeArray","n","clickBinding","dblclickBinding","blurBinding","focusBinding","hoverBinding","inHandlerName","outHandlerName","handlers","tasks","task","String","updateElementCache","opt","allCache","skipForOfParseFn","_this","isRenderedTemplates","createBindingOption","renderTemplatesBinding","applyBinding","postProcess","pubSub","templateBinding","condition","visualBindingOptions","eventsBindingOptions","bindingUpdateOption","templateSettings","evaluate","interpolate","dataBind","use","init","version"],"mappings":"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"}