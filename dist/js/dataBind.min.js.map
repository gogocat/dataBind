{"version":3,"file":"dataBind.min.js","sources":["../../src/config.js","../../src/util.js","../../src/domWalker.js","../../src/createBindingOption.js","../../src/_escape.js","../../src/changeBinding.js","../../src/attrBinding.js","../../src/renderTemplate.js","../../src/renderTemplatesBinding.js","../../src/renderIteration.js","../../src/commentWrapper.js","../../src/renderForOfBinding.js","../../src/forOfBinding.js","../../src/renderIfBinding.js","../../src/ifBinding.js","../../src/switchBinding.js","../../src/createEventBinding.js","../../src/applyBinding.js","../../src/showBinding.js","../../src/textBinding.js","../../src/cssBinding.js","../../src/modelBinding.js","../../src/hoverBinding.js","../../src/pubSub.js","../../src/binder.js","../../src/postProcess.js","../../src/index.js"],"sourcesContent":["const bindingAttrs = {\n    comp: 'data-bind-comp',\n    tmp: 'data-bind-tmp',\n    text: 'data-bind-text',\n    click: 'data-bind-click',\n    dblclick: 'data-bind-dblclick',\n    blur: 'data-bind-blur',\n    focus: 'data-bind-focus',\n    hover: 'data-bind-hover',\n    input: 'data-bind-input',\n    change: 'data-bind-change',\n    submit: 'data-bind-submit',\n    model: 'data-bind-model',\n    show: 'data-bind-show',\n    css: 'data-bind-css',\n    attr: 'data-bind-attr',\n    forOf: 'data-bind-for',\n    if: 'data-bind-if',\n    switch: 'data-bind-switch',\n    case: 'data-bind-case',\n    default: 'data-bind-default',\n};\nconst serverRenderedAttr = 'data-server-rendered';\nconst dataIndexAttr = 'data-index';\nconst commentPrefix = {\n    forOf: 'data-forOf_',\n    if: 'data-if_',\n    case: 'data-case_',\n    default: 'data-default_',\n};\nconst commentSuffix = '_end';\n\nconst bindingDataReference = {\n    rootDataKey: '$root',\n    currentData: '$data',\n    currentIndex: '$index',\n    mouseEnterHandlerName: 'in',\n    mouseLeaveHandlerName: 'out',\n};\n\nconst bindingUpdateConditions = {\n    serverRendered: 'SERVER-RENDERED',\n    init: 'INIT',\n};\n\n// maximum string length before running regex\nconst maxDatakeyLength = 250;\n\nconst constants = {\n    filters: {\n        ONCE: 'once',\n    },\n    PARENT_REF: '_parent',\n};\n\nexport {\n    bindingAttrs,\n    dataIndexAttr,\n    serverRenderedAttr,\n    commentPrefix,\n    commentSuffix,\n    bindingUpdateConditions,\n    bindingDataReference,\n    maxDatakeyLength,\n    constants,\n};\n","import * as config from './config';\r\n\r\nconst hasIsArray = Array.isArray;\r\n\r\nconst REGEX = {\r\n    BAD_TAGS: /<(script|del)(?=[\\s>])[\\w\\W]*?<\\/\\1\\s*>/ig,\r\n    FOR_OF: /(.*?)\\s+(?:in|of)\\s+(.*)/,\r\n    FUNCTION_PARAM: /\\((.*?)\\)/,\r\n    HTML_TAG: /^[\\s]*<([a-z][^\\/\\s>]+)/i,\r\n    OBJECT_LITERAL: /^\\{.+\\}$/,\r\n    PIPE: /\\|/,\r\n    WHITE_SPACES: /\\s+/g,\r\n    LINE_BREAKS_TABS: /(\\r\\n|\\n|\\r|\\t)/gm,\r\n};\r\n\r\nconst IS_SUPPORT_TEMPLATE = 'content' in document.createElement('template');\r\n\r\nconst WRAP_MAP = {\r\n    div: ['div', '<div>', '</div>'],\r\n    thead: ['table', '<table>', '</table>'],\r\n    col: ['colgroup', '<table><colgroup>', '</colgroup></table>'],\r\n    tr: ['tbody', '<table><tbody>', '</tbody></table>'],\r\n    td: ['tr', '<table><tr>', '</tr></table>'],\r\n};\r\nWRAP_MAP.caption = WRAP_MAP.colgroup = WRAP_MAP.tbody = WRAP_MAP.tfoot = WRAP_MAP.thead;\r\nWRAP_MAP.th = WRAP_MAP.td;\r\n\r\nconst isArray = (obj) => {\r\n    return hasIsArray ? Array.isArray(obj) : Object.prototype.toString.call(obj) === '[object Array]';\r\n};\r\n\r\nconst isJsObject = (obj) => {\r\n    return obj !== null && typeof obj === 'object' && Object.prototype.toString.call(obj) === '[object Object]';\r\n};\r\n\r\nconst isPlainObject = (obj) => {\r\n    if (!isJsObject(obj)) {\r\n        return false;\r\n    }\r\n\r\n    // If has modified constructor\r\n    const ctor = obj.constructor;\r\n    if (typeof ctor !== 'function') return false;\r\n\r\n    // If has modified prototype\r\n    const prot = ctor.prototype;\r\n    if (isJsObject(prot) === false) return false;\r\n\r\n    // If constructor does not have an Object-specific method\r\n    if (prot.hasOwnProperty('isPrototypeOf') === false) {\r\n        return false;\r\n    }\r\n\r\n    // Most likely a plain Object\r\n    return true;\r\n};\r\n\r\n// test if string contains '{...}'. string must not contains tab, line breaks\r\nconst isObjectLiteralString = (str = '') => {\r\n    return REGEX.OBJECT_LITERAL.test(str);\r\n};\r\n\r\nconst isEmptyObject = (obj) => {\r\n    if (isJsObject(obj)) {\r\n        return Object.getOwnPropertyNames(obj).length === 0;\r\n    }\r\n    return false;\r\n};\r\n\r\nfunction getFirstHtmlStringTag(htmlString) {\r\n    const match = htmlString.match(REGEX.HTML_TAG);\r\n    if (match) {\r\n        return match[1];\r\n    }\r\n    return null;\r\n}\r\n\r\nfunction removeBadTags(htmlString = '') {\r\n    return htmlString.replace(REGEX.BAD_TAGS, '');\r\n}\r\n\r\nfunction createHtmlFragment(htmlString) {\r\n    if (typeof htmlString !== 'string') {\r\n        return null;\r\n    }\r\n    // use template element\r\n    if (IS_SUPPORT_TEMPLATE) {\r\n        const template = document.createElement('template');\r\n        template.innerHTML = removeBadTags(htmlString);\r\n        return template.content;\r\n    }\r\n    // use document fragment with wrap html tag for tr, td etc.\r\n    const fragment = document.createDocumentFragment();\r\n    const queryContainer = document.createElement('div');\r\n    const firstTag = getFirstHtmlStringTag(htmlString);\r\n    const wrap = WRAP_MAP[firstTag || 'div'];\r\n\r\n    if (wrap[0] === 'div') {\r\n        return document.createRange().createContextualFragment(htmlString);\r\n    }\r\n\r\n    queryContainer.insertAdjacentHTML('beforeend', `${wrap[1]}${htmlString}${wrap[2]}`);\r\n\r\n    const query = queryContainer.querySelector(wrap[0]);\r\n\r\n    while (query.firstChild) {\r\n        fragment.appendChild(query.firstChild);\r\n    }\r\n\r\n    return fragment;\r\n}\r\n\r\nconst generateElementCache = (bindingAttrs) => {\r\n    const elementCache = {};\r\n\r\n    for (const i in bindingAttrs) {\r\n        if (bindingAttrs.hasOwnProperty(i)) {\r\n            if (isArray(bindingAttrs)) {\r\n                elementCache[bindingAttrs[i]] = [];\r\n            } else {\r\n                elementCache[i] = [];\r\n            }\r\n        }\r\n    }\r\n\r\n    return elementCache;\r\n};\r\n\r\n\r\n// simplified version of Lodash _.get\r\nconst _get = function get(obj, path, def) {\r\n    function everyFunc(step) {\r\n        return !(step && (obj = obj[step]) === undefined);\r\n    }\r\n    const fullPath = path\r\n        .replace(/\\[/g, '.')\r\n        .replace(/]/g, '')\r\n        .split('.')\r\n        .filter(Boolean);\r\n\r\n    return fullPath.every(everyFunc) ? obj : def;\r\n};\r\n\r\n/**\r\n * getViewModelValue\r\n * @description walk a object by provided string path. eg 'a.b.c'\r\n * @param {object} viewModel\r\n * @param {string} prop\r\n * @return {object}\r\n */\r\nconst getViewModelValue = (viewModel, prop) => {\r\n    return _get(viewModel, prop);\r\n};\r\n\r\n// simplified version of Lodash _.set\r\n// https://stackoverflow.com/questions/54733539/javascript-implementation-of-lodash-set-method\r\nconst _set = (obj, path, value) => {\r\n    if (Object(obj) !== obj) return obj; // When obj is not an object\r\n    // If not yet an array, get the keys from the string-path\r\n    if (!Array.isArray(path)) path = path.toString().match(/[^.[\\]]+/g) || [];\r\n\r\n    // Iterate all of them except the last one\r\n    path.slice(0, -1).reduce((a, c, i) =>\r\n        Object(a[c]) === a[c] ? // Does the key exist and is its value an object?\r\n        // Yes: then follow that path\r\n            a[c] :\r\n        // No: create the key. Is the next key a potential array-index?\r\n            a[c] = Math.abs(path[i+1])>>0 === +path[i+1] ?\r\n                [] : // Yes: assign a new array object\r\n                {}, // No: assign a new plain object\r\n    obj)[path[path.length-1]] = value; // Finally assign the value to the last key\r\n\r\n    // Return the top-level object to allow chaining\r\n    return obj;\r\n};\r\n\r\n/**\r\n * setViewModelValue\r\n * @description populate viewModel object by path string\r\n * @param {object} obj\r\n * @param {string} prop\r\n * @param {string} value\r\n * @return {call} underscore set\r\n */\r\nconst setViewModelValue = (obj, prop, value) => {\r\n    return _set(obj, prop, value);\r\n};\r\n\r\nconst getViewModelPropValue = (viewModel, bindingCache) => {\r\n    let dataKey = bindingCache.dataKey;\r\n    let paramList = bindingCache.parameters;\r\n    const isInvertBoolean = dataKey.charAt(0) === '!';\r\n\r\n    if (isInvertBoolean) {\r\n        dataKey = isInvertBoolean ? dataKey.substring(1) : dataKey;\r\n    }\r\n\r\n    let ret = getViewModelValue(viewModel, dataKey);\r\n\r\n    if (typeof ret === 'function') {\r\n        const viewModelContext = resolveViewModelContext(viewModel, dataKey);\r\n        const oldViewModelProValue = bindingCache.elementData ? bindingCache.elementData.viewModelPropValue : null;\r\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\r\n        // let args = [oldViewModelProValue, bindingCache.el].concat(paramList);\r\n        const args = paramList.concat([oldViewModelProValue, bindingCache.el]);\r\n        ret = ret.apply(viewModelContext, args);\r\n    }\r\n\r\n    ret = isInvertBoolean ? !ret : ret;\r\n\r\n    // call through fitlers to get final value\r\n    ret = filtersViewModelPropValue({\r\n        value: ret,\r\n        viewModel: viewModel,\r\n        bindingCache: bindingCache,\r\n    });\r\n\r\n    return ret;\r\n};\r\n\r\nconst filtersViewModelPropValue = ({value, viewModel, bindingCache}) => {\r\n    let ret = value;\r\n    if (bindingCache.filters) {\r\n        each(bindingCache.filters, (index, filter) => {\r\n            const viewModelContext = resolveViewModelContext(viewModel, filter);\r\n            const filterFn = getViewModelValue.call(viewModelContext, viewModelContext, filter);\r\n            try {\r\n                ret = filterFn.call(viewModelContext, ret);\r\n            } catch (err) {\r\n                throwErrorMessage(err, `Invalid filter: ${filter}`);\r\n            }\r\n        });\r\n    }\r\n    return ret;\r\n};\r\n\r\nconst parseStringToJson = (str) => {\r\n    // fix unquote or single quote keys and replace single quote to double quote\r\n    const ret = str.replace(/(\\s*?{\\s*?|\\s*?,\\s*?)(['\"])?([a-zA-Z0-9]+)(['\"])?:/g, '$1\"$3\":').replace(/'/g, '\"');\r\n    return JSON.parse(ret);\r\n};\r\n\r\n/**\r\n * arrayRemoveMatch\r\n * @description remove match items in fromArray out of toArray\r\n * @param {array} toArray\r\n * @param {array} frommArray\r\n * @return {boolean}\r\n */\r\nconst arrayRemoveMatch = (toArray, frommArray) => {\r\n    return toArray.filter((value, index) => {\r\n        return frommArray.indexOf(value) < 0;\r\n    });\r\n};\r\n\r\nconst getFormData = ($form) => {\r\n    const data = {};\r\n\r\n    if (!$form instanceof HTMLFormElement) {\r\n        return data;\r\n    }\r\n\r\n    const formData = new FormData($form);\r\n\r\n    formData.forEach((value, key) => {\r\n        if (!Object.prototype.hasOwnProperty.call( Object, key ) ) {\r\n            data[key] = value;\r\n            return;\r\n        }\r\n        if (!Array.isArray(data[key])) {\r\n            data[key] = [data[key]];\r\n        }\r\n        data[key].push(value);\r\n    });\r\n\r\n    return data;\r\n};\r\n\r\n/**\r\n * getFunctionParameterList\r\n * @description convert parameter string to arrary\r\n * eg. '(\"a\",\"b\",\"c\")' > [\"a\",\"b\",\"c\"]\r\n * @param {string} str\r\n * @return {array} paramlist\r\n */\r\nconst getFunctionParameterList = (str) => {\r\n    if (!str || str.length > config.maxDatakeyLength) {\r\n        return;\r\n    }\r\n    let paramlist = str.match(REGEX.FUNCTION_PARAM);\r\n\r\n    if (paramlist && paramlist[1]) {\r\n        paramlist = paramlist[1].split(',');\r\n        paramlist.forEach(function(v, i) {\r\n            paramlist[i] = v.trim();\r\n        });\r\n    }\r\n    return paramlist;\r\n};\r\n\r\nconst extractFilterList = (cacheData) => {\r\n    if (!cacheData || !cacheData.dataKey || cacheData.dataKey.length > config.maxDatakeyLength) {\r\n        return cacheData;\r\n    }\r\n    const filterList = cacheData.dataKey.split(REGEX.PIPE);\r\n    let isOnceIndex;\r\n    cacheData.dataKey = filterList[0].trim();\r\n    if (filterList.length > 1) {\r\n        filterList.shift(0);\r\n        filterList.forEach(function(v, i) {\r\n            filterList[i] = v.trim();\r\n            if (filterList[i] === config.constants.filters.ONCE) {\r\n                cacheData.isOnce = true;\r\n                isOnceIndex = i;\r\n            }\r\n        });\r\n        // don't store filter 'once' - because it is internal logic not a property from viewModel\r\n        if (isOnceIndex >= 0) {\r\n            filterList.splice(isOnceIndex, 1);\r\n        }\r\n        cacheData.filters = filterList;\r\n    }\r\n    return cacheData;\r\n};\r\n\r\nconst invertObj = (sourceObj) => {\r\n    return Object.keys(sourceObj).reduce(function(obj, key) {\r\n        obj[sourceObj[key]] = key;\r\n        return obj;\r\n    }, {});\r\n};\r\n\r\nconst createDeferredObj = () => {\r\n    const dfObj = {};\r\n\r\n    dfObj.promise = new Promise((resolve, reject) => {\r\n        dfObj.resolve = resolve;\r\n        dfObj.reject = reject;\r\n    });\r\n\r\n    return dfObj;\r\n};\r\n\r\n/**\r\n * debounce\r\n * @description decorate a function to be debounce using requestAnimationFrame\r\n * @param {function} fn\r\n * @param {context} ctx\r\n * @return {function}\r\n */\r\nconst debounceRaf = (fn, ctx = null) => {\r\n    return (function(fn, ctx) {\r\n        let dfObj = createDeferredObj();\r\n        let rafId = 0;\r\n\r\n        // return decorated fn\r\n        return function() {\r\n             \r\n            const args = Array.from ? Array.from(arguments) : Array.prototype.slice.call(arguments);\r\n\r\n            window.cancelAnimationFrame(rafId);\r\n            rafId = window.requestAnimationFrame(() => {\r\n                try {\r\n                    // fn is Binder.render function\r\n                    fn.apply(ctx, args);\r\n                    // dfObj.resolve is function provided in .then promise chain\r\n                    // ctx is the current component\r\n                    dfObj.resolve(ctx);\r\n                } catch (err) {\r\n                    console.error('error in rendering: ', err);\r\n                    dfObj.reject(err);\r\n                }\r\n\r\n                // reset dfObj - otherwise then callbacks will not be in execution order\r\n                // example:\r\n                // myApp.render().then(function(){console.log('ok1')});\r\n                // myApp.render().then(function(){console.log('ok2')});\r\n                // myApp.render().then(function(){console.log('ok3')});\r\n                // >> ok1, ok2, ok3\r\n                dfObj = createDeferredObj();\r\n\r\n                window.cancelAnimationFrame(rafId);\r\n            });\r\n\r\n            return dfObj.promise;\r\n        };\r\n    })(fn, ctx);\r\n};\r\n\r\n/**\r\n * getNodeAttrObj\r\n * @description convert Node attributes object to a json object\r\n * @param {object} node\r\n * @param {array} skipList\r\n * @return {object}\r\n */\r\nconst getNodeAttrObj = (node, skipList) => {\r\n    let attributesLength = 0;\r\n    let skipArray;\r\n\r\n    if (!node || node.nodeType !== 1 || !node.hasAttributes()) {\r\n        return;\r\n    }\r\n    if (skipList) {\r\n        skipArray = [];\r\n        skipArray = typeof skipList === 'string' ? skipArray.push(skipList) : skipList;\r\n    }\r\n    const attrObj = {};\r\n    attributesLength = node.attributes.length;\r\n\r\n    if (attributesLength) {\r\n        for (let i = 0; i < attributesLength; i += 1) {\r\n            const attribute = node.attributes.item(i);\r\n            attrObj[attribute.nodeName] = attribute.nodeValue;\r\n        }\r\n    }\r\n\r\n    if (isArray(skipArray)) {\r\n        skipArray.forEach((item) => {\r\n            if (attrObj[item]) {\r\n                delete attrObj[item];\r\n            }\r\n        });\r\n    }\r\n    return attrObj;\r\n};\r\n\r\n/**\r\n * extend\r\n * @param {boolean} isDeepMerge\r\n * @param {object} target\r\n * @param {object} sources\r\n * @return {object} merged object\r\n */\r\nconst extend = (isDeepMerge = false, target, ...sources) => {\r\n    if (!sources.length) {\r\n        return target;\r\n    }\r\n    const source = sources.shift();\r\n    if (source === undefined) {\r\n        return target;\r\n    }\r\n\r\n    if (!isDeepMerge) {\r\n        return Object.assign(target, ...sources);\r\n    }\r\n\r\n    if (isMergebleObject(target) && isMergebleObject(source)) {\r\n        Object.keys(source).forEach((key) => {\r\n            if (isMergebleObject(source[key])) {\r\n                if (!target[key]) {\r\n                    target[key] = {};\r\n                }\r\n                extend(target[key], source[key]);\r\n            } else {\r\n                target[key] = source[key];\r\n            }\r\n        });\r\n    }\r\n\r\n    return extend(true, target, ...sources);\r\n};\r\n\r\nconst each = (obj, fn) => {\r\n    if (typeof obj !== 'object' || typeof fn !== 'function') {\r\n        return;\r\n    }\r\n    let keys = [];\r\n    let keysLength = 0;\r\n    const isArrayObj = isArray(obj);\r\n    let key;\r\n    let value;\r\n    let i = 0;\r\n\r\n    if (isArrayObj) {\r\n        keysLength = obj.length;\r\n    } else if (isJsObject(obj)) {\r\n        keys = Object.keys(obj);\r\n        keysLength = keys.length;\r\n    } else {\r\n        throw new TypeError('Object is not an array or object');\r\n    }\r\n\r\n    for (i = 0; i < keysLength; i += 1) {\r\n        if (isArrayObj) {\r\n            key = i;\r\n            value = obj[i];\r\n        } else {\r\n            key = keys[i];\r\n            value = obj[key];\r\n        }\r\n        fn(key, value);\r\n    }\r\n};\r\n\r\nconst isMergebleObject = (item) => {\r\n    return isJsObject(item) && !isArray(item);\r\n};\r\n\r\n/**\r\n * cloneDomNode\r\n * @param {object} element\r\n * @return {object} cloned element\r\n * @description helper function to clone node\r\n */\r\nconst cloneDomNode = (element) => {\r\n    return element.cloneNode(true);\r\n};\r\n\r\n/**\r\n * insertAfter\r\n * @param {object} parentNode\r\n * @param {object} newNode\r\n * @param {object} referenceNode\r\n * @return {object} node\r\n * @description helper function to insert new node before the reference node\r\n */\r\nconst insertAfter = (parentNode, newNode, referenceNode) => {\r\n    const refNextElement = referenceNode && referenceNode.nextSibling ? referenceNode.nextSibling : null;\r\n    return parentNode.insertBefore(newNode, refNextElement);\r\n};\r\n\r\nconst resolveViewModelContext = (viewModel, datakey) => {\r\n    let ret = viewModel;\r\n    if (typeof datakey !== 'string') {\r\n        return ret;\r\n    }\r\n    const bindingDataContext = datakey.split('.');\r\n    if (bindingDataContext.length > 1) {\r\n        if (bindingDataContext[0] === config.bindingDataReference.rootDataKey) {\r\n            ret = viewModel[config.bindingDataReference.rootDataKey] || viewModel;\r\n        } else if (bindingDataContext[0] === config.bindingDataReference.currentData) {\r\n            ret = viewModel[config.bindingDataReference.currentData] || viewModel;\r\n        }\r\n    }\r\n    return ret;\r\n};\r\n\r\nconst resolveParamList = (viewModel, paramList) => {\r\n    if (!viewModel || !isArray(paramList)) {\r\n        return;\r\n    }\r\n    return paramList.map((param) => {\r\n        param = param.trim();\r\n\r\n        if (param === config.bindingDataReference.currentIndex) {\r\n            // convert '$index' to value\r\n            param = viewModel[config.bindingDataReference.currentIndex];\r\n        } else if (param === config.bindingDataReference.currentData) {\r\n            // convert '$data' to value or current viewModel\r\n            param = viewModel[config.bindingDataReference.currentData] || viewModel;\r\n        } else if (param === config.bindingDataReference.rootDataKey) {\r\n            // convert '$root' to root viewModel\r\n            param = viewModel[config.bindingDataReference.rootDataKey] || viewModel;\r\n        }\r\n        return param;\r\n    });\r\n};\r\n\r\nconst removeElement = (el) => {\r\n    if (el && el.parentNode) {\r\n        el.parentNode.removeChild(el);\r\n    }\r\n};\r\n\r\nconst emptyElement = (node) => {\r\n    if (node && node.firstChild) {\r\n        while (node.firstChild) {\r\n            node.removeChild(node.firstChild);\r\n        }\r\n    }\r\n    return node;\r\n};\r\n\r\nconst throwErrorMessage = (err = null, errorMessage = '') => {\r\n    const message = err && err.message ? err.message : errorMessage;\r\n    if (typeof console.error === 'function') {\r\n        return console.error(message);\r\n    }\r\n    return console.log(message);\r\n};\r\n\r\n/**\r\n * parseBindingObjectString\r\n * @description parse bining object string to object with value always stringify\r\n * @param {string} str - eg '{ id: $data.id, name: $data.name }'\r\n * @return {object} - eg { id: '$data.id', name: '$data.name'}\r\n */\r\nconst parseBindingObjectString = (str = '') => {\r\n    let objectLiteralString = str.trim();\r\n    const ret = {};\r\n\r\n    if (!REGEX.OBJECT_LITERAL.test(str)) {\r\n        return null;\r\n    }\r\n\r\n    // clearn up line breaks and remove first { character\r\n    objectLiteralString = objectLiteralString\r\n        .replace(REGEX.LINE_BREAKS_TABS, '')\r\n        .substring(1);\r\n\r\n    // remove last } character\r\n    objectLiteralString = objectLiteralString.substring(0, objectLiteralString.length - 1);\r\n\r\n    objectLiteralString.split(',').forEach((item) => {\r\n        const keyVal = item.trim();\r\n        // ignore if last empty item - eg split last comma in object literal\r\n        if (keyVal) {\r\n            const prop = keyVal.split(':');\r\n            const key = prop[0].trim();\r\n            ret[key] = `${prop[1]}`.trim();\r\n        }\r\n    });\r\n\r\n    return ret;\r\n};\r\n\r\nexport {\r\n    REGEX,\r\n    arrayRemoveMatch,\r\n    cloneDomNode,\r\n    createHtmlFragment,\r\n    debounceRaf,\r\n    each,\r\n    emptyElement,\r\n    extend,\r\n    extractFilterList,\r\n    generateElementCache,\r\n    getFormData,\r\n    getFunctionParameterList,\r\n    getNodeAttrObj,\r\n    getViewModelPropValue,\r\n    getViewModelValue,\r\n    insertAfter,\r\n    invertObj,\r\n    isArray,\r\n    isEmptyObject,\r\n    isJsObject,\r\n    isPlainObject,\r\n    isObjectLiteralString,\r\n    parseStringToJson,\r\n    parseBindingObjectString,\r\n    removeElement,\r\n    resolveParamList,\r\n    resolveViewModelContext,\r\n    setViewModelValue,\r\n    throwErrorMessage,\r\n};\r\n","import {invertObj, extractFilterList, getFunctionParameterList, REGEX} from './util';\nimport {constants} from './config';\n\nlet bindingAttrsMap;\n\n/**\n * walkDOM\n * @description by Douglas Crockford - walk each DOM node and calls provided callback function\n * start walk from firstChild\n * @param {object} node\n * @param {function} func\n */\nconst walkDOM = (node, func) => {\n    let parseChildNode = true;\n    node = node.firstElementChild;\n    while (node) {\n        parseChildNode = func(node);\n        if (parseChildNode) {\n            walkDOM(node, func);\n        }\n        node = node.nextElementSibling;\n    }\n};\n\nconst getAttributesObject = (node) => {\n    const ret = {};\n    Array.prototype.slice.call(node.attributes).forEach((item) => {\n        ret[item.name] = item.value;\n    });\n    return ret;\n};\n\nconst checkSkipChildParseBindings = (attrObj = {}, bindingAttrs) => {\n    return [bindingAttrs.forOf, bindingAttrs.if, bindingAttrs.case, bindingAttrs.default].filter((type) => {\n        return typeof attrObj[type] !== 'undefined';\n    });\n};\n\nconst rootSkipCheck = (node) => {\n    return node.tagName === 'SVG';\n};\n\nconst defaultSkipCheck = (node, bindingAttrs) => {\n    return node.tagName === 'SVG' || node.hasAttribute(bindingAttrs.comp);\n};\n\nconst populateBindingCache = ({node, attrObj, bindingCache, type}) => {\n    let attrValue;\n    let cacheData;\n\n    if (bindingAttrsMap && bindingAttrsMap[type] && typeof attrObj[type] !== 'undefined') {\n        bindingCache[type] = bindingCache[type] || [];\n        attrValue = attrObj[type] || '';\n\n        if (attrValue) {\n            attrValue = attrValue.replace(REGEX.LINE_BREAKS_TABS, '').replace(REGEX.WHITE_SPACES, ' ').trim();\n        }\n\n        cacheData = {\n            el: node,\n            dataKey: attrValue,\n        };\n\n        // populate cacheData.filters. update filterList first item as dataKey\n        cacheData = extractFilterList(cacheData);\n\n        // populate cacheData.parameters\n        // for store function call parameters eg. '$index', '$root'\n        // useful with DOM for-loop template as reference to binding data\n        const paramList = getFunctionParameterList(cacheData.dataKey);\n        if (paramList) {\n            cacheData.parameters = paramList;\n            cacheData.dataKey = cacheData.dataKey.replace(REGEX.FUNCTION_PARAM, '').trim();\n        }\n        // store parent array reference to cacheData\n        cacheData[constants.PARENT_REF] = bindingCache[type];\n        bindingCache[type].push(cacheData);\n    }\n    return bindingCache;\n};\n\nconst createBindingCache = ({rootNode = null, bindingAttrs = {}, skipCheck, isRenderedTemplate = false}) => {\n    let bindingCache = {};\n\n    if (!rootNode instanceof window.Node) {\n        throw new TypeError('walkDOM: Expected a DOM node');\n    }\n\n    bindingAttrsMap = bindingAttrsMap || invertObj(bindingAttrs);\n\n    const parseNode = (node, skipNodeCheckFn = defaultSkipCheck) => {\n        let isSkipForOfChild = false;\n\n        if (node.nodeType !== 1 || !node.hasAttributes()) {\n            return true;\n        }\n        if (skipNodeCheckFn(node, bindingAttrs) || (typeof skipCheck === 'function' && skipCheck(node))) {\n            return false;\n        }\n\n        // when creating sub bindingCache if is for tmp binding\n        // skip same element that has forOf binding the  forOf is alredy parsed\n        const attrObj = getAttributesObject(node);\n        const hasSkipChildParseBindings = checkSkipChildParseBindings(attrObj, bindingAttrs);\n        let iterateList = [];\n\n        if (hasSkipChildParseBindings.length) {\n            isSkipForOfChild = true;\n            iterateList = hasSkipChildParseBindings;\n        } else if (isRenderedTemplate && attrObj[bindingAttrs.tmp]) {\n            // skip current node parse if was called by node has template binding and already rendered\n            return true;\n        } else {\n            iterateList = Object.keys(attrObj);\n        }\n\n        iterateList.forEach((key) => {\n            // skip for switch case and default bining\n            if (key !== bindingAttrs.case && key !== bindingAttrs.default) {\n                bindingCache = populateBindingCache({\n                    node: node,\n                    attrObj: attrObj,\n                    bindingCache: bindingCache,\n                    type: key,\n                });\n            }\n        });\n\n        // after cache forOf skip parse child nodes\n        if (isSkipForOfChild) {\n            return false;\n        }\n\n        return true;\n    };\n\n    if (parseNode(rootNode, rootSkipCheck)) {\n        walkDOM(rootNode, parseNode);\n    }\n    return bindingCache;\n};\n\nexport default createBindingCache;\n","import {\n    bindingUpdateConditions,\n} from './config';\nimport {extend} from './util';\n/**\n * createBindingOption\n * @param {string} condition\n * @param {object} opt\n * @description\n * generate binding update option object by condition\n * @return {object} updateOption\n */\nfunction createBindingOption(condition = '', opt = {}) {\n    const visualBindingOptions = {\n        templateBinding: false,\n        textBinding: true,\n        cssBinding: true,\n        ifBinding: true,\n        showBinding: true,\n        modelBinding: true,\n        attrBinding: true,\n        forOfBinding: true,\n        switchBinding: true,\n    };\n    const eventsBindingOptions = {\n        changeBinding: true,\n        clickBinding: true,\n        dblclickBinding: true,\n        blurBinding: true,\n        focusBinding: true,\n        hoverBinding: true,\n        inputBinding: true,\n        submitBinding: true,\n    };\n    // this is visualBindingOptions but everything false\n    // concrete declear for performance purpose\n    const serverRenderedOptions = {\n        templateBinding: false,\n        textBinding: false,\n        cssBinding: false,\n        ifBinding: false,\n        showBinding: false,\n        modelBinding: false,\n        attrBinding: false,\n        forOfBinding: false,\n        switchBinding: false,\n    };\n    let updateOption = {};\n\n    switch (condition) {\n    case bindingUpdateConditions.serverRendered:\n        updateOption = extend({}, eventsBindingOptions, serverRenderedOptions, opt);\n        break;\n    case bindingUpdateConditions.init:\n        // flag templateBinding to true to render tempalte(s)\n        opt.templateBinding = true;\n        opt.forceRender = true;\n        updateOption = extend({}, visualBindingOptions, eventsBindingOptions, opt);\n        break;\n    default:\n        // when called again only update visualBinding options\n        updateOption = extend({}, visualBindingOptions, opt);\n    }\n\n    return updateOption;\n}\n\nexport default createBindingOption;\n","/**\n * _escape\n * @description\n * https://github.com/lodash/lodash/blob/master/escape.js\n */\n\nfunction baseToString(value) {\n    if (typeof value == 'string') {\n        return value;\n    }\n    return value == null ? '' : `${value}`;\n}\n\n/** Used to match HTML entities and HTML characters. */\nconst reUnescapedHtml = /[&<>\"'`]/g;\nconst reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n/** Used to map characters to HTML entities. */\nconst htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    '\\'': '&#39;',\n    '`': '&#96;',\n};\n\n/**\n   * escapeHtmlChar\n   * @description convert characters to HTML entities.\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @return {string} Returns the escaped character.\n   */\nfunction escapeHtmlChar(chr) {\n    return htmlEscapes[chr];\n}\n\n/**\n * Converts the characters \"&\", \"<\", \">\", '\"', \"'\", and \"\\`\", in `string` to\n * their corresponding HTML entities.\n * @param {string} string\n * @return {string} string\n */\nexport default function escape(string) {\n    // Reset `lastIndex` because in IE < 9 `String#replace` does not.\n    string = baseToString(string);\n    return (string && reHasUnescapedHtml.test(string)) ?\n        string.replace(reUnescapedHtml, escapeHtmlChar) :\n        string;\n}\n"," \nimport {\n    getViewModelValue,\n    setViewModelValue,\n    resolveViewModelContext,\n    resolveParamList,\n} from './util';\nimport _escape from './_escape';\n\n/**\n * changeBinding\n * @description input element on change event binding. DOM -> viewModel update\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {boolean} forceRender\n */\nconst changeBinding = ({\n    cache,\n    viewModel,\n    bindingAttrs,\n    forceRender,\n    type = 'change',\n}) => {\n    const handlerName = cache.dataKey;\n    let paramList = cache.parameters;\n    const modelDataKey = cache.el.getAttribute(bindingAttrs.model);\n    let newValue = '';\n    let oldValue = '';\n    let viewModelContext;\n    const APP = viewModel.APP || viewModel.$root.APP;\n\n    if (!handlerName || (!forceRender && !APP.$rootElement.contains(cache.el))) {\n        return;\n    }\n\n    const handlerFn = getViewModelValue(viewModel, handlerName);\n\n    if (typeof handlerFn === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n\n        function changeHandler(e) {\n            const $this = this;\n            const isCheckbox = $this.type === 'checkbox';\n            newValue = isCheckbox ? $this.checked : _escape($this.value);\n            // set data to viewModel\n            if (modelDataKey) {\n                oldValue = getViewModelValue(viewModel, modelDataKey);\n                setViewModelValue(viewModel, modelDataKey, newValue);\n            }\n            const args = [e, e.currentTarget, newValue, oldValue].concat(paramList);\n            handlerFn.apply(viewModelContext, args);\n            oldValue = newValue;\n        }\n\n        // assing on change event\n        cache.el.removeEventListener(type, changeHandler, false);\n        cache.el.addEventListener(type, changeHandler, false);\n    }\n};\n\nexport default changeBinding;\n","import {\n    extend,\n    getViewModelPropValue,\n    isPlainObject,\n    isEmptyObject,\n    isObjectLiteralString,\n    parseBindingObjectString,\n    each,\n} from './util';\n\n/**\n * attrBinding\n * @description\n * DOM decleartive attr binding. update elenment attributes\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n */\nconst attrBinding = (cache = {}, viewModel) => {\n    if (!cache.dataKey) {\n        return;\n    }\n    // check if Object Literal String style dataKey\n    const isObjLiteralStr = isObjectLiteralString(cache.dataKey);\n\n    // resolve vmAttrObj, when Object Literal String style if will be object without resolve each value\n    // otherwise, resolve value from viewModel\n    const vmAttrObj = isObjLiteralStr ? parseBindingObjectString(cache.dataKey) : getViewModelPropValue(viewModel, cache);\n\n    // vmAttrObj must be a plain object\n    if (!isPlainObject(vmAttrObj)) {\n        return;\n    }\n\n    // populate cache.elementData if not exits\n    // check and set default cache.elementData.viewModelPropValue\n    cache.elementData = cache.elementData || {};\n    cache.elementData.viewModelPropValue = cache.elementData.viewModelPropValue || {};\n\n    // start diff comparison\n    // reject if nothing changed by comparing\n    // cache.elementData.viewModelPropValue (previous render) vs vmAttrObj(current render)\n    if (JSON.stringify(cache.elementData.viewModelPropValue) === JSON.stringify(vmAttrObj)) {\n        return;\n    }\n\n    if (isObjLiteralStr) {\n        // resolve each value in vmAttrObj\n        each(vmAttrObj, (key, value)=> {\n            // resolve value from viewModel including $data and $root\n            // from viewModel.$data or viewModel.$root\n            vmAttrObj[key] = getViewModelPropValue(viewModel, {dataKey: value});\n        });\n    }\n\n    // shortcut for reading cache.elementData.viewModelPropValue\n    const oldAttrObj = cache.elementData.viewModelPropValue;\n\n    // start set element attribute - oldAttrObj is empty meaning no previous render\n    if (isEmptyObject(oldAttrObj)) {\n        each(vmAttrObj, (key, value)=> {\n            if (typeof value !== 'undefined') {\n                cache.el.setAttribute(key, value);\n                // populate cache.elementData.viewModelPropValue for future comparison\n                if (!isObjLiteralStr) {\n                    cache.elementData.viewModelPropValue[key] = value;\n                }\n            }\n        });\n    } else {\n        // loop oldAttrObj, remove attribute not present in current vmAttrObj\n        each(oldAttrObj, (key, value)=> {\n            if (typeof vmAttrObj[key] === 'undefined') {\n                cache.el.removeAttribute(key);\n            }\n        });\n\n        // loop vmAttrObj, set attribute not present in oldAttrObj\n        each(vmAttrObj, (key, value)=> {\n            if (typeof value !== 'undefined') {\n                if (oldAttrObj[key] !== vmAttrObj[key]) {\n                    cache.el.setAttribute(key, vmAttrObj[key]);\n                    // populate cache.elementData.viewModelPropValue for future comparison\n                    if (!isObjLiteralStr) {\n                        cache.elementData.viewModelPropValue[key] = value;\n                    }\n                }\n            }\n        });\n    }\n\n    // for object literal style binding\n    // set viewModelPropValue for future diff comaprison\n    // note: vmAttrObj is a not fully resolve object, each value is still string unresloved\n    if (isObjLiteralStr) {\n        cache.elementData.viewModelPropValue = extend({}, vmAttrObj);\n    }\n};\n\nexport default attrBinding;\n","import {dataIndexAttr} from './config';\nimport {\n    createHtmlFragment,\n    emptyElement,\n    getViewModelPropValue,\n    parseStringToJson,\n} from './util';\n\nlet $domFragment = null;\nlet $templateRoot = null;\nlet $templateRootPrepend = false;\nlet $templateRootAppend = false;\nlet nestTemplatesCount = 0;\n\n/**\n * getTemplateString\n * @description get Template tag innerHTML string\n * @param {string} id\n * @return {string} rendered html string\n */\nconst getTemplateString = (id) => {\n    const templateElement = document.getElementById(id);\n\n    return templateElement ? templateElement.innerHTML : '';\n};\n\n/**\n * renderTemplate\n * @description\n * get template setting from DOM attribute then call compileTemplate\n * to render and append to target DOM\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {object} elementCache\n */\nconst renderTemplate = (cache, viewModel, bindingAttrs, elementCache) => {\n    const settings = typeof cache.dataKey === 'string' ? parseStringToJson(cache.dataKey) : cache.dataKey;\n    let viewData = settings.data;\n    const isAppend = settings.append;\n    const isPrepend = settings.prepend;\n    let $currentElement;\n\n    cache.dataKey = settings;\n\n    viewData = (typeof viewData === 'undefined' || viewData === '$root') ?\n        viewModel :\n        getViewModelPropValue(viewModel, {\n            dataKey: settings.data,\n            parameters: cache.parameters,\n        });\n\n    if (!viewData) {\n        return;\n    }\n\n    const $element = cache.el;\n    const $index = typeof viewModel.$index !== 'undefined' ? viewModel.$index : $element.getAttribute(dataIndexAttr);\n\n    if (typeof $index !== 'undefined') {\n        viewData.$index = $index;\n    }\n\n    $domFragment = $domFragment || document.createDocumentFragment();\n\n    if (!$templateRoot) {\n        $templateRoot = $element;\n        // Store the prepend/append flags from the root template only\n        $templateRootPrepend = isPrepend;\n        $templateRootAppend = isAppend;\n    }\n\n    const htmlString = getTemplateString(settings.id);\n\n    const htmlFragment = createHtmlFragment(htmlString);\n\n    // append rendered html\n    if (!$domFragment.childNodes.length) {\n        // domFragment should be empty in first run\n        $currentElement = $domFragment; // copy of $domFragment for later find nested template check\n        $domFragment.appendChild(htmlFragment);\n    } else {\n        // during recursive run keep append to current fragment\n        $currentElement = $element; // reset to current nested template element\n        if (!isAppend && !isPrepend) {\n            $currentElement = emptyElement($currentElement);\n        }\n        if (isPrepend) {\n            $currentElement.insertBefore(htmlFragment, $currentElement.firstChild);\n        } else {\n            $currentElement.appendChild(htmlFragment);\n        }\n    }\n\n    // check if there are nested template then recurisive render them\n    const $nestedTemplates = $currentElement.querySelectorAll('[' + bindingAttrs.tmp + ']');\n\n    const nestedTemplatesLength = $nestedTemplates.length;\n\n    if (nestedTemplatesLength) {\n        nestTemplatesCount += nestedTemplatesLength;\n\n        for (let i=0; i < nestedTemplatesLength; i+=1) {\n            const thisTemplateCache = {\n                el: $nestedTemplates[i],\n                dataKey: $nestedTemplates[i].getAttribute(bindingAttrs.tmp),\n            };\n            elementCache[bindingAttrs.tmp].push(thisTemplateCache);\n            // recursive template render\n            renderTemplate(thisTemplateCache, viewModel, bindingAttrs, elementCache);\n            nestTemplatesCount -= 1;\n        }\n    }\n\n    // no more nested tempalted to render, start to append $domFragment into $templateRoot\n    if (nestTemplatesCount === 0) {\n        // append to DOM once\n        // Use the prepend/append flags from the root template, not the current nested template\n        if (!$templateRootAppend && !$templateRootPrepend) {\n            $templateRoot = emptyElement($templateRoot);\n        }\n        if ($templateRootPrepend) {\n            $templateRoot.insertBefore($domFragment, $templateRoot.firstChild);\n        } else {\n            $templateRoot.appendChild($domFragment);\n        }\n        // clear cached fragment and flags\n        $domFragment = $templateRoot = null;\n        $templateRootPrepend = $templateRootAppend = false;\n        // trigger callback if provided\n        if (typeof viewModel.afterTemplateRender === 'function') {\n            viewModel.afterTemplateRender(viewData);\n        }\n    }\n};\n\nexport default renderTemplate;\n","import {bindingUpdateConditions} from './config';\nimport * as applyBindingModule from './applyBinding.js';\nimport createBindingOption from './createBindingOption';\nimport renderTemplate from './renderTemplate';\n\nconst renderTemplatesBinding = ({ctx, elementCache, updateOption, bindingAttrs, viewModel}) => {\n    if (!elementCache || !bindingAttrs) {\n        return false;\n    }\n    // render and apply binding to template(s) and forOf DOM\n    if (elementCache[bindingAttrs.tmp] && elementCache[bindingAttrs.tmp].length) {\n        // when re-render call with {templateBinding: true}\n        // template and nested templates\n        if (updateOption.templateBinding) {\n            // overwrite updateOption with 'init' bindingUpdateConditions\n            updateOption = createBindingOption(bindingUpdateConditions.init);\n\n            // forEach is correct here - nested templates are added to array but rendered recursively\n            // We don't want the loop to re-render templates that were already rendered via recursion\n            elementCache[bindingAttrs.tmp].forEach(($element) => {\n                renderTemplate($element, viewModel, bindingAttrs, elementCache);\n            });\n            // update cache after all template(s) rendered\n            ctx.updateElementCache({\n                templateCache: true,\n                elementCache: elementCache,\n                isRenderedTemplates: true,\n            });\n        }\n        // enforce render even element is not in DOM tree\n        updateOption.forceRender = true;\n\n        // apply bindings to rendered templates element\n        // Use namespace import to access the function at runtime,\n        // which breaks the circular dependency during module initialization\n        // Use for loop to handle templates added during rendering\n        for (let i = 0; i < elementCache[bindingAttrs.tmp].length; i++) {\n            applyBindingModule.default({\n                elementCache: elementCache[bindingAttrs.tmp][i].bindingCache,\n                updateOption: updateOption,\n                bindingAttrs: bindingAttrs,\n                viewModel: viewModel,\n            });\n        }\n    }\n    return true;\n};\n\nexport default renderTemplatesBinding;\n","import {bindingUpdateConditions} from './config';\nimport createBindingOption from './createBindingOption';\nimport renderTemplatesBinding from './renderTemplatesBinding';\nimport * as applyBindingModule from './applyBinding.js';\n\n/**\n * renderIteration\n * @param {object} opt\n * @description\n * render element's binding by supplied elementCache\n * This function is desidned for FoOf, If, switch bindings\n */\nconst renderIteration = ({elementCache, iterationVm, bindingAttrs, isRegenerate}) => {\n    const bindingUpdateOption = isRegenerate ? createBindingOption(bindingUpdateConditions.init) : createBindingOption();\n\n    // enforce render even element is not in DOM tree\n    bindingUpdateOption.forceRender = true;\n\n    // render and apply binding to template(s)\n    // this is an share function therefore passing current APP 'this' context\n    // viewModel is a dynamic generated iterationVm\n    renderTemplatesBinding({\n        ctx: iterationVm.$root ? iterationVm.$root.APP : iterationVm.APP,\n        elementCache: elementCache,\n        updateOption: bindingUpdateOption,\n        bindingAttrs: bindingAttrs,\n        viewModel: iterationVm,\n    });\n\n    // Use namespace import to access the function at runtime,\n    // which breaks the circular dependency during module initialization\n    applyBindingModule.default({\n        elementCache: elementCache,\n        updateOption: bindingUpdateOption,\n        bindingAttrs: bindingAttrs,\n        viewModel: iterationVm,\n    });\n};\n\nexport default renderIteration;\n"," \nimport * as config from './config';\nimport * as util from './util';\n\nconst createClonedElementCache = (bindingData) => {\n    const clonedElement = bindingData.el.cloneNode(true);\n    bindingData.fragment = document.createDocumentFragment();\n    bindingData.fragment.appendChild(clonedElement);\n    return bindingData;\n};\n\nconst setCommentPrefix = (bindingData) => {\n    if (!bindingData || !bindingData.type) {\n        return bindingData;\n    }\n    let commentPrefix = '';\n    const dataKeyMarker = bindingData.dataKey ? bindingData.dataKey.replace(util.REGEX.WHITE_SPACES, '_') : '';\n\n    switch (bindingData.type) {\n    case config.bindingAttrs.forOf:\n        commentPrefix = config.commentPrefix.forOf;\n        break;\n    case config.bindingAttrs.if:\n        commentPrefix = config.commentPrefix.if;\n        break;\n    case config.bindingAttrs.case:\n        commentPrefix = config.commentPrefix.case;\n        break;\n    case config.bindingAttrs.default:\n        commentPrefix = config.commentPrefix.default;\n        break;\n    }\n    bindingData.commentPrefix = commentPrefix + dataKeyMarker;\n    return bindingData;\n};\n\n/**\n * setDocRangeEndAfter\n * @param {object} node\n * @param {object} bindingData\n * @description\n * recursive execution to find last wrapping comment node\n * and set as bindingData.docRange.setEndAfter\n * if not found deleteContents will has no operation\n * @return {undefined}\n */\nconst setDocRangeEndAfter = (node, bindingData) => {\n    if (!bindingData.commentPrefix) {\n        setCommentPrefix(bindingData);\n    }\n    const startTextContent = bindingData.commentPrefix;\n    const endTextContent = startTextContent + config.commentSuffix;\n    node = node.nextSibling;\n\n    // check last wrap comment node\n    if (node) {\n        if (node.nodeType === 8 && node.textContent === endTextContent) {\n            return bindingData.docRange.setEndBefore(node);\n        }\n        setDocRangeEndAfter(node, bindingData);\n    }\n};\n\n/**\n * wrapCommentAround\n * @param {object} bindingData\n * @param {Node} node\n * @return {object} DOM fragment\n * @description\n * wrap frament with comment node\n */\nconst wrapCommentAround = (bindingData, node) => {\n    let prefix = '';\n    if (!bindingData.commentPrefix) {\n        setCommentPrefix(bindingData);\n    }\n    prefix = bindingData.commentPrefix;\n    const commentBegin = document.createComment(prefix);\n    const commentEnd = document.createComment(prefix + config.commentSuffix);\n    // document fragment - logic for ForOf binding\n    // check node.parentNode because node could be from cache and no longer in DOM\n    if (node.nodeType === 11) {\n        node.insertBefore(commentBegin, node.firstChild);\n        node.appendChild(commentEnd);\n    } else if (node.parentNode) {\n        node.parentNode.insertBefore(commentBegin, node);\n        util.insertAfter(node.parentNode, commentEnd, node);\n        // update bindingData details\n        bindingData.previousNonTemplateElement = node.previousSibling;\n        bindingData.nextNonTemplateElement = node.nextSibling;\n        bindingData.parentElement = node.previousSibling.parentElement;\n    }\n\n    return node;\n};\n\n/**\n * removeElemnetsByCommentWrap\n * @param {object} bindingData\n * @return {undefined}\n * @description remove elments by range\n */\nconst removeElemnetsByCommentWrap = (bindingData) => {\n    if (!bindingData.docRange) {\n        bindingData.docRange = document.createRange();\n    }\n    try {\n        if (bindingData.previousNonTemplateElement) {\n            // update docRange start and end match the wrapped comment node\n            bindingData.docRange.setStartBefore(bindingData.previousNonTemplateElement.nextSibling);\n            setDocRangeEndAfter(bindingData.previousNonTemplateElement.nextSibling, bindingData);\n        } else {\n            // insert before next non template element\n            bindingData.docRange.setStartBefore(bindingData.parentElement.firstChild);\n            setDocRangeEndAfter(bindingData.parentElement.firstChild, bindingData);\n        }\n    } catch (err) {\n        console.log('error removeElemnetsByCommentWrap: ', err.message);\n    }\n\n    return bindingData.docRange.deleteContents();\n};\n\n/**\n * removeDomTemplateElement\n * @param {object} bindingData\n * @return {object} null\n */\nconst removeDomTemplateElement = (bindingData) => {\n    // first render - forElement is live DOM element so has parentNode\n    if (bindingData.el.parentNode) {\n        return bindingData.el.parentNode.removeChild(bindingData.el);\n    }\n    removeElemnetsByCommentWrap(bindingData);\n};\n\nconst insertRenderedElements = (bindingData, fragment) => {\n    // insert rendered fragment after the previousNonTemplateElement\n    if (bindingData.previousNonTemplateElement) {\n        util.insertAfter(bindingData.parentElement, fragment, bindingData.previousNonTemplateElement);\n    } else {\n        // insert before next non template element\n        if (bindingData.nextNonTemplateElement) {\n            bindingData.parentElement.insertBefore(fragment, bindingData.nextNonTemplateElement);\n        } else if (bindingData.parentElement) {\n            // insert from parent\n            bindingData.parentElement.appendChild(fragment);\n        }\n    }\n};\n\nexport {\n    createClonedElementCache,\n    setCommentPrefix,\n    wrapCommentAround,\n    removeElemnetsByCommentWrap,\n    removeDomTemplateElement,\n    setDocRangeEndAfter,\n    insertRenderedElements,\n};\n"," \nimport {bindingAttrs as configBindingAttrs, bindingDataReference} from './config';\nimport {\n    getViewModelPropValue,\n    isArray,\n    isPlainObject,\n    throwErrorMessage,\n    cloneDomNode,\n    isEmptyObject,\n} from './util';\nimport createBindingCache from './domWalker';\nimport renderIteration from './renderIteration';\nimport {\n    wrapCommentAround,\n    removeElemnetsByCommentWrap,\n    insertRenderedElements,\n} from './commentWrapper';\n\nconst renderForOfBinding = ({bindingData, viewModel, bindingAttrs}) => {\n    if (!bindingData || !viewModel || !bindingAttrs) {\n        return;\n    }\n    let keys;\n    let iterationDataLength;\n    const iterationData = getViewModelPropValue(viewModel, bindingData.iterator);\n    let isRegenerate = false;\n\n    // check iterationData and set iterationDataLength\n    if (isArray(iterationData)) {\n        iterationDataLength = iterationData.length;\n    } else if (isPlainObject(iterationData)) {\n        keys = Object.keys(iterationData);\n        iterationDataLength = keys.length;\n    } else {\n        // throw error but let script contince to run\n        return throwErrorMessage(null, 'iterationData is not an plain object or array');\n    }\n\n    // flag as pared for-of logic with bindingData.type\n    if (!bindingData.type) {\n        bindingData.type = configBindingAttrs.forOf;\n        wrapCommentAround(bindingData, bindingData.el);\n    }\n\n    // assign forOf internal id to bindingData once\n    if (typeof bindingData.iterationSize === 'undefined') {\n        // store iterationDataLength\n        bindingData.iterationSize = iterationDataLength;\n        // remove orignal node for-of attributes\n        bindingData.el.removeAttribute(bindingAttrs.forOf);\n        isRegenerate = true;\n    } else {\n        // only regenerate cache if iterationDataLength changed\n        isRegenerate = bindingData.iterationSize !== iterationDataLength;\n        // update iterationSize\n        bindingData.iterationSize = iterationDataLength;\n    }\n\n    if (!isRegenerate) {\n        bindingData.iterationBindingCache.forEach(function(elementCache, i) {\n            if (!isEmptyObject(elementCache)) {\n                const iterationVm = createIterationViewModel({\n                    bindingData: bindingData,\n                    viewModel: viewModel,\n                    iterationData: iterationData,\n                    keys: keys,\n                    index: i,\n                });\n                renderIteration({\n                    elementCache: elementCache,\n                    iterationVm: iterationVm,\n                    bindingAttrs: bindingAttrs,\n                    isRegenerate: false,\n                });\n            }\n        });\n\n        return;\n    }\n\n    // generate forOfBinding elements into fragment\n    const fragment = generateForOfElements(bindingData, viewModel, bindingAttrs, iterationData, keys);\n\n    removeElemnetsByCommentWrap(bindingData);\n\n    // insert fragment content into DOM\n    return insertRenderedElements(bindingData, fragment);\n};\n\n/**\n * createIterationViewModel\n * @description\n * create an virtual viewModel for render binding while in loop iteration\n * $data is the current data in the loop eg. data in array\n * $root is point to top level viewModel\n * $index is the current loop index\n * @param {*} param0\n * @return {object} virtual viewModel\n */\nconst createIterationViewModel = ({bindingData, viewModel, iterationData, keys, index}) => {\n    const iterationVm = {};\n    iterationVm[bindingData.iterator.alias] = keys ? iterationData[keys[index]] : iterationData[index];\n    // populate common binding data reference\n    iterationVm[bindingDataReference.rootDataKey] = viewModel.$root || viewModel;\n    iterationVm[bindingDataReference.currentData] = iterationVm[bindingData.iterator.alias];\n    iterationVm[bindingDataReference.currentIndex] = index;\n    return iterationVm;\n};\n\nconst generateForOfElements = (bindingData, viewModel, bindingAttrs, iterationData, keys) => {\n    const fragment = document.createDocumentFragment();\n    const iterationDataLength = bindingData.iterationSize;\n    let clonedItem;\n    let iterationVm;\n    let iterationBindingCache;\n    let i = 0;\n\n    // create or clear exisitng iterationBindingCache\n    if (isArray(bindingData.iterationBindingCache)) {\n        bindingData.iterationBindingCache.length = 0;\n    } else {\n        bindingData.iterationBindingCache = [];\n    }\n\n    // generate forOf and append to DOM\n    for (i = 0; i < iterationDataLength; i += 1) {\n        clonedItem = cloneDomNode(bindingData.el);\n\n        // create bindingCache per iteration\n        iterationBindingCache = createBindingCache({\n            rootNode: clonedItem,\n            bindingAttrs: bindingAttrs,\n        });\n\n        bindingData.iterationBindingCache.push(iterationBindingCache);\n\n        if (!isEmptyObject(iterationBindingCache)) {\n            // create an iterationVm match iterator alias\n            iterationVm = createIterationViewModel({\n                bindingData: bindingData,\n                viewModel: viewModel,\n                iterationData: iterationData,\n                keys: keys,\n                index: i,\n            });\n\n            renderIteration({\n                elementCache: bindingData.iterationBindingCache[i],\n                iterationVm: iterationVm,\n                bindingAttrs: bindingAttrs,\n                isRegenerate: true,\n            });\n        }\n\n        fragment.appendChild(clonedItem);\n    }\n\n    return fragment;\n};\n\nexport default renderForOfBinding;\n","import {maxDatakeyLength} from './config';\nimport {REGEX} from './util';\nimport renderForOfBinding from './renderForOfBinding';\n\n/**\n * forOfBinding\n * @description\n * DOM decleartive for binding.\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n */\nconst forOfBinding = (cache, viewModel, bindingAttrs) => {\n    const dataKey = cache.dataKey;\n\n    if (!dataKey || dataKey.length > maxDatakeyLength) {\n        return;\n    }\n\n    if (!cache.iterator) {\n        if (dataKey.length > maxDatakeyLength) {\n            return;\n        }\n        // replace mess spaces with single space\n        cache.dataKey = cache.dataKey.replace(REGEX.WHITE_SPACES, ' ');\n        const forExpMatch = dataKey.match(REGEX.FOR_OF);\n\n        if (!forExpMatch) {\n            return;\n        }\n\n        cache.iterator = {};\n        cache.iterator.alias = forExpMatch[1].trim();\n\n        if (forExpMatch[2]) {\n            cache.iterator.dataKey = forExpMatch[2].trim();\n            cache.parentElement = cache.el.parentElement;\n            cache.previousNonTemplateElement = cache.el.previousSibling;\n            cache.nextNonTemplateElement = cache.el.nextSibling;\n        }\n    }\n\n    renderForOfBinding({\n        bindingData: cache,\n        viewModel: viewModel,\n        bindingAttrs: bindingAttrs,\n    });\n};\n\nexport default forOfBinding;\n","import {isEmptyObject} from './util';\nimport renderIteration from './renderIteration';\nimport createBindingCache from './domWalker';\nimport {commentSuffix} from './config';\nimport {removeElemnetsByCommentWrap, insertRenderedElements} from './commentWrapper';\n\n/**\n * isTargetDomRemoved\n * @description check if DOM between 'start' and 'end' comment tag has been removed\n * @param {object} bindingData\n * @return {boolean}\n */\nconst isTargetDomRemoved = (bindingData) => {\n    let ret = false;\n    if (bindingData && bindingData.previousNonTemplateElement) {\n        const commentStartTextContent = bindingData.previousNonTemplateElement.textContent;\n        const endCommentTag = bindingData.previousNonTemplateElement.nextSibling;\n\n        if (endCommentTag.nodeType === 8) {\n            if (endCommentTag.textContent === commentStartTextContent + commentSuffix) {\n                ret = true;\n            }\n        }\n    }\n    return ret;\n};\n\nconst renderIfBinding = ({bindingData, viewModel, bindingAttrs}) => {\n    if (!bindingData.fragment) {\n        return;\n    }\n\n    const isDomRemoved = isTargetDomRemoved(bindingData);\n    let rootElement = bindingData.el;\n\n    // remove current old DOM.\n    // TODO: try preserve DOM\n    if (!isDomRemoved && !bindingData.isOnce) {\n        removeIfBinding(bindingData);\n        // use fragment for create iterationBindingCache\n        rootElement = bindingData.fragment.firstChild.cloneNode(true);\n    }\n\n    // walk clonedElement to create iterationBindingCache once\n    if (!bindingData.iterationBindingCache || !bindingData.hasIterationBindingCache) {\n        bindingData.iterationBindingCache = createBindingCache({\n            rootNode: rootElement,\n            bindingAttrs: bindingAttrs,\n        });\n    }\n\n    // only render if has iterationBindingCache\n    // means has other dataBindings to be render\n    if (!isEmptyObject(bindingData.iterationBindingCache)) {\n        bindingData.hasIterationBindingCache = true;\n        renderIteration({\n            elementCache: bindingData.iterationBindingCache,\n            iterationVm: viewModel,\n            bindingAttrs: bindingAttrs,\n            isRegenerate: true,\n        });\n    }\n\n    // insert to new rendered DOM\n    // TODO: check unnecessary insertion when DOM is preserved\n    insertRenderedElements(bindingData, rootElement);\n};\n\nconst removeIfBinding = (bindingData) => {\n    removeElemnetsByCommentWrap(bindingData);\n    // remove cache.IterationBindingCache to prevent memory leak\n    if (bindingData.hasIterationBindingCache) {\n        delete bindingData.iterationBindingCache;\n        delete bindingData.hasIterationBindingCache;\n    }\n};\n\nexport {\n    renderIfBinding,\n    removeIfBinding,\n};\n","import {bindingAttrs as configBindingAttrs, constants} from './config';\nimport {getViewModelPropValue, removeElement} from './util';\nimport {createClonedElementCache, wrapCommentAround} from './commentWrapper';\nimport {renderIfBinding, removeIfBinding} from './renderIfBinding';\n\n/**\n * if-Binding\n * @description\n * DOM decleartive for binding.\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n */\nconst ifBinding = (cache, viewModel, bindingAttrs) => {\n    const dataKey = cache.dataKey;\n\n    // isOnce only return if there is no child bindings\n    if (!dataKey || (cache.isOnce && cache.hasIterationBindingCache === false)) {\n        return;\n    }\n\n    cache.elementData = cache.elementData || {};\n    cache.type = cache.type || configBindingAttrs.if;\n\n    const oldViewModelProValue = cache.elementData.viewModelPropValue;\n    // getViewModelPropValue could be return undefined or null\n    const viewModelPropValue = getViewModelPropValue(viewModel, cache) || false;\n\n    // do nothing if viewModel value not changed and no child bindings\n    if (oldViewModelProValue === viewModelPropValue && !cache.hasIterationBindingCache) {\n        return;\n    }\n\n    const shouldRender = Boolean(viewModelPropValue);\n\n    // remove this cache from parent array\n    if (!shouldRender && cache.isOnce && cache.el.parentNode) {\n        removeElement(cache.el);\n        // delete cache.fragment;\n        removeBindingInQueue({\n            viewModel: viewModel,\n            cache: cache,\n        });\n        return;\n    }\n\n    // store new show status\n    cache.elementData.viewModelPropValue = viewModelPropValue;\n\n    // only create fragment once\n    // wrap comment tag around\n    // remove if attribute from original element to allow later dataBind parsing\n    if (!cache.fragment) {\n        wrapCommentAround(cache, cache.el);\n        cache.el.removeAttribute(bindingAttrs.if);\n        createClonedElementCache(cache);\n    }\n\n    if (!shouldRender) {\n        // remove element\n        removeIfBinding(cache);\n    } else {\n        // render element\n        renderIfBinding({\n            bindingData: cache,\n            viewModel: viewModel,\n            bindingAttrs: bindingAttrs,\n        });\n\n        // if render once\n        // remove this cache from parent array if no child caches\n        if (cache.isOnce && !cache.hasIterationBindingCache) {\n            // delete cache.fragment;\n            removeBindingInQueue({\n                viewModel: viewModel,\n                cache: cache,\n            });\n        }\n    }\n};\n\nconst removeBindingInQueue = ({viewModel, cache}) => {\n    let ret = false;\n    if (viewModel.APP.postProcessQueue) {\n        viewModel.APP.postProcessQueue.push(\n            ((cache, index) => () => {\n                cache[constants.PARENT_REF].splice(index, 1);\n            })(cache, cache[constants.PARENT_REF].indexOf(cache)),\n        );\n        ret = true;\n    }\n    return ret;\n};\n\nexport default ifBinding;\n","import {getViewModelPropValue} from './util';\nimport {createClonedElementCache, wrapCommentAround} from './commentWrapper';\nimport {renderIfBinding, removeIfBinding} from './renderIfBinding';\n/**\n * switch-Binding\n * @description\n * DOM decleartive switch binding.\n * switch parent element wrap direct child with case bindings\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n */\nconst switchBinding = (cache, viewModel, bindingAttrs) => {\n    const dataKey = cache.dataKey;\n\n    if (!dataKey) {\n        return;\n    }\n\n    cache.elementData = cache.elementData || {};\n\n    const newExpression = getViewModelPropValue(viewModel, cache);\n\n    if (newExpression === cache.elementData.viewModelPropValue) {\n        return;\n    }\n\n    cache.elementData.viewModelPropValue = newExpression;\n\n    // build switch cases if not yet defined\n    if (!cache.cases) {\n        const childrenElements = cache.el.children;\n        if (!childrenElements.length) {\n            return;\n        }\n        cache.cases = [];\n        for (let i = 0, elementLength = childrenElements.length; i < elementLength; i += 1) {\n            let caseData = null;\n            if (childrenElements[i].hasAttribute(bindingAttrs.case)) {\n                caseData = createCaseData(childrenElements[i], bindingAttrs.case);\n            } else if (childrenElements[i].hasAttribute(bindingAttrs.default)) {\n                caseData = createCaseData(childrenElements[i], bindingAttrs.default);\n                caseData.isDefault = true;\n            }\n            // create fragment by clone node\n            // wrap with comment tag\n            if (caseData) {\n                wrapCommentAround(caseData, caseData.el);\n                // remove binding attribute for later dataBind parse\n                if (caseData.isDefault) {\n                    caseData.el.removeAttribute(bindingAttrs.default);\n                } else {\n                    caseData.el.removeAttribute(bindingAttrs.case);\n                }\n                createClonedElementCache(caseData);\n                cache.cases.push(caseData);\n            }\n        }\n    }\n\n    if (cache.cases.length) {\n        let hasMatch = false;\n        // do switch operation - reuse if binding logic\n        for (let j = 0, casesLength = cache.cases.length; j < casesLength; j += 1) {\n            let newCaseValue;\n            if (cache.cases[j].dataKey) {\n                // set back to dataKey if nothing found in viewModel\n                newCaseValue = getViewModelPropValue(viewModel, cache.cases[j]) || cache.cases[j].dataKey;\n            }\n\n            if (newCaseValue === cache.elementData.viewModelPropValue || cache.cases[j].isDefault) {\n                hasMatch = true;\n                // render element\n                renderIfBinding({\n                    bindingData: cache.cases[j],\n                    viewModel: viewModel,\n                    bindingAttrs: bindingAttrs,\n                });\n\n                // remove other elements\n                removeUnmatchCases(cache.cases, j);\n                break;\n            }\n        }\n        // no match remove all cases\n        if (!hasMatch) {\n            removeUnmatchCases(cache.cases);\n        }\n    }\n};\n\nfunction removeUnmatchCases(cases, matchedIndex) {\n    cases.forEach((caseData, index) => {\n        if (index !== matchedIndex || typeof matchedIndex === 'undefined') {\n            removeIfBinding(caseData);\n            // remove cache.IterationBindingCache to prevent memory leak\n            if (caseData.hasIterationBindingCache) {\n                caseData.iterationBindingCache = null;\n                caseData.hasIterationBindingCache = false;\n            }\n        }\n    });\n}\n\nfunction createCaseData(node, attrName) {\n    const caseData = {\n        el: node,\n        dataKey: node.getAttribute(attrName),\n        type: attrName,\n    };\n    return caseData;\n}\n\nexport default switchBinding;\n","import {\n    getFormData,\n    getViewModelValue,\n    resolveViewModelContext,\n    resolveParamList,\n} from './util';\n\nconst createEventBinding = ({\n    cache = {},\n    forceRender = false,\n    type = '',\n    viewModel = {},\n}) => {\n    const handlerName = cache.dataKey;\n    let paramList = cache.parameters;\n    let viewModelContext;\n    const APP = viewModel.APP || viewModel.$root.APP;\n\n    if (!type || !handlerName || (!forceRender && !APP.$rootElement.contains(cache.el))) {\n        return;\n    }\n\n    const handlerFn = getViewModelValue(viewModel, handlerName);\n\n    if (typeof handlerFn === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n\n        const handlerWrap = (e) => {\n            let formData;\n            let args = [];\n            if (type === 'submit') {\n                formData = getFormData(e.currentTarget);\n                args = [e, e.currentTarget, formData].concat(paramList);\n            } else {\n                args = [e, e.currentTarget].concat(paramList);\n            }\n            handlerFn.apply(viewModelContext, args);\n        };\n\n        cache.el.removeEventListener(type, handlerWrap, false);\n        cache.el.addEventListener(type, handlerWrap, false);\n    }\n};\n\nexport default createEventBinding;\n","import hoverBinding from './hoverBinding';\nimport changeBinding from './changeBinding';\nimport modelBinding from './modelBinding';\nimport textBinding from './textBinding';\nimport showBinding from './showBinding';\nimport cssBinding from './cssBinding';\nimport attrBinding from './attrBinding';\nimport forOfBinding from './forOfBinding'; // depends renderForOfBinding -> this , renderIteration\nimport ifBinding from './ifBinding';\nimport switchBinding from './switchBinding';\nimport createEventBinding from './createEventBinding';\n\nfunction applyBinding({ctx, elementCache, updateOption, bindingAttrs, viewModel}) {\n    if (!elementCache || !updateOption) {\n        return;\n    }\n\n    // the follow binding should be in order for better efficiency\n\n    // apply forOf Binding\n    if (updateOption.forOfBinding && elementCache[bindingAttrs.forOf] && elementCache[bindingAttrs.forOf].length) {\n        elementCache[bindingAttrs.forOf].forEach((cache) => {\n            forOfBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n    }\n\n    // apply attr Binding\n    if (updateOption.attrBinding && elementCache[bindingAttrs.attr] && elementCache[bindingAttrs.attr].length) {\n        elementCache[bindingAttrs.attr].forEach((cache) => {\n            attrBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n    }\n\n    // apply if Binding\n    if (updateOption.ifBinding && elementCache[bindingAttrs.if] && elementCache[bindingAttrs.if].length) {\n        elementCache[bindingAttrs.if].forEach((cache) => {\n            ifBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n    }\n\n    // apply show Binding\n    if (updateOption.showBinding && elementCache[bindingAttrs.show] && elementCache[bindingAttrs.show].length) {\n        elementCache[bindingAttrs.show].forEach((cache) => {\n            showBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n    }\n\n    // apply switch Binding\n    if (updateOption.switchBinding && elementCache[bindingAttrs.switch] && elementCache[bindingAttrs.switch].length) {\n        elementCache[bindingAttrs.switch].forEach((cache) => {\n            switchBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n    }\n\n    // apply text binding\n    if (updateOption.textBinding && elementCache[bindingAttrs.text] && elementCache[bindingAttrs.text].length) {\n        elementCache[bindingAttrs.text].forEach((cache) => {\n            textBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n    }\n\n    // apply cssBinding\n    if (updateOption.cssBinding && elementCache[bindingAttrs.css] && elementCache[bindingAttrs.css].length) {\n        elementCache[bindingAttrs.css].forEach((cache) => {\n            cssBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n    }\n\n    // apply model binding\n    if (updateOption.modelBinding && elementCache[bindingAttrs.model] && elementCache[bindingAttrs.model].length) {\n        elementCache[bindingAttrs.model].forEach((cache) => {\n            modelBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n    }\n\n    // apply change binding\n    if (updateOption.changeBinding && elementCache[bindingAttrs.change] && elementCache[bindingAttrs.change].length) {\n        elementCache[bindingAttrs.change].forEach((cache) => {\n            changeBinding({\n                bindingAttrs,\n                cache,\n                forceRender: updateOption.forceRender,\n                type: 'change',\n                viewModel,\n            });\n        });\n    }\n\n    // apply submit binding\n    if (updateOption.submitBinding && elementCache[bindingAttrs.submit] && elementCache[bindingAttrs.submit].length) {\n        elementCache[bindingAttrs.submit].forEach((cache) => {\n            createEventBinding({\n                cache,\n                forceRender: updateOption.forceRender,\n                type: 'submit',\n                viewModel,\n            });\n        });\n    }\n\n    // apply click binding\n    if (updateOption.clickBinding && elementCache[bindingAttrs.click] && elementCache[bindingAttrs.click].length) {\n        elementCache[bindingAttrs.click].forEach((cache) => {\n            createEventBinding({\n                cache,\n                forceRender: updateOption.forceRender,\n                type: 'click',\n                viewModel,\n            });\n        });\n    }\n\n    // apply double click binding\n    if (updateOption.dblclickBinding && elementCache[bindingAttrs.dblclick] && elementCache[bindingAttrs.dblclick].length) {\n        elementCache[bindingAttrs.dblclick].forEach((cache) => {\n            createEventBinding({\n                cache,\n                forceRender: updateOption.forceRender,\n                type: 'dblclick',\n                viewModel,\n            });\n        });\n    }\n\n    // apply blur binding\n    if (updateOption.blurBinding && elementCache[bindingAttrs.blur] && elementCache[bindingAttrs.blur].length) {\n        elementCache[bindingAttrs.blur].forEach((cache) => {\n            createEventBinding({\n                cache,\n                forceRender: updateOption.forceRender,\n                type: 'blur',\n                viewModel,\n            });\n        });\n    }\n\n    // apply focus binding\n    if (updateOption.focusBinding && elementCache[bindingAttrs.focus] && elementCache[bindingAttrs.focus].length) {\n        elementCache[bindingAttrs.focus].forEach((cache) => {\n            createEventBinding({\n                cache,\n                forceRender: updateOption.forceRender,\n                type: 'focus',\n                viewModel,\n            });\n        });\n    }\n\n    // apply hover binding\n    if (updateOption.hoverBinding && elementCache[bindingAttrs.hover] && elementCache[bindingAttrs.hover].length) {\n        elementCache[bindingAttrs.hover].forEach((cache) => {\n            hoverBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n    }\n\n    // apply input binding - eg html range input\n    if (updateOption.inputBinding && elementCache[bindingAttrs.input] && elementCache[bindingAttrs.input].length) {\n        elementCache[bindingAttrs.input].forEach((cache) => {\n            changeBinding({\n                bindingAttrs,\n                cache,\n                forceRender: updateOption.forceRender,\n                type: 'input',\n                viewModel,\n            });\n        });\n    }\n}\n\nexport default applyBinding;\n","import {getViewModelPropValue} from './util';\n\n/**\n * showBinding\n * @description\n * DOM decleartive show binding. Make binding show/hide according to viewModel data (boolean)\n * viewModel data can function but must return boolean\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n */\nconst showBinding = (cache, viewModel, bindingAttrs) => {\n    const dataKey = cache.dataKey;\n    let currentInlineSytle = {};\n    let currentInlineDisplaySytle = '';\n    let shouldShow = true;\n\n    if (!dataKey) {\n        return;\n    }\n\n    cache.elementData = cache.elementData || {};\n\n    const oldShowStatus = cache.elementData.viewModelPropValue;\n\n    // store current element display default style once only\n    if (\n        typeof cache.elementData.displayStyle === 'undefined' ||\n        typeof cache.elementData.computedStyle === 'undefined'\n    ) {\n        currentInlineSytle = cache.el.style;\n        currentInlineDisplaySytle = currentInlineSytle.display;\n        // use current inline style if defined\n        if (currentInlineDisplaySytle) {\n            // set to 'block' if is 'none'\n            cache.elementData.displayStyle = currentInlineDisplaySytle === 'none' ? 'block' : currentInlineDisplaySytle;\n            cache.elementData.computedStyle = null;\n        } else {\n            const computeStyle = window.getComputedStyle(cache.el, null).getPropertyValue('display');\n            cache.elementData.displayStyle = null;\n            cache.elementData.computedStyle = computeStyle;\n        }\n    }\n\n    shouldShow = getViewModelPropValue(viewModel, cache);\n\n    // treat undefined || null as false.\n    // eg if property doesn't exsits in viewModel, it will treat as false to hide element\n    shouldShow = Boolean(shouldShow);\n\n    // reject if nothing changed\n    if (oldShowStatus === shouldShow) {\n        return;\n    }\n\n    if (!shouldShow) {\n        if (cache.el.style.display !== 'none') {\n            cache.el.style.setProperty('display', 'none');\n        }\n    } else {\n        if (cache.elementData.computedStyle || cache.el.style.display === 'none') {\n            if (cache.elementData.computedStyle === 'none') {\n                // default display is none in css rule, so use display 'block'\n                cache.el.style.setProperty('display', 'block');\n            } else {\n                // has default displayable type so just remove inline display 'none'\n                if (currentInlineSytle.length > 1) {\n                    cache.el.style.removeProperty('display');\n                } else {\n                    cache.el.removeAttribute('style');\n                }\n            }\n        } else {\n            // element default display was inline style, so restore it\n            cache.el.style.setProperty('display', cache.elementData.displayStyle);\n        }\n    }\n\n    // store new show status\n    cache.elementData.viewModelPropValue = shouldShow;\n};\n\nexport default showBinding;\n","import {getViewModelPropValue} from './util';\n\n/**\n * textBinding\n * * @description\n * DOM decleartive text binding update dom textnode with viewModel data\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {boolean} forceRender\n */\nconst textBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n    const dataKey = cache.dataKey;\n    const APP = viewModel.APP || viewModel.$root.APP;\n\n    // NOTE: this doesn't work for for-of, if and switch bindings because element was not in DOM\n    if (!dataKey || (!forceRender && !APP.$rootElement.contains(cache.el))) {\n        return;\n    }\n\n    const newValue = getViewModelPropValue(viewModel, cache);\n    const oldValue = cache.el.textContent;\n\n    if (typeof newValue !== 'undefined' && typeof newValue !== 'object' && newValue !== null) {\n        if (newValue !== oldValue) {\n            cache.el.textContent = newValue;\n        }\n    }\n};\n\nexport default textBinding;\n","import {\n    getViewModelPropValue,\n    isPlainObject,\n    arrayRemoveMatch,\n    each,\n} from './util';\n\n/**\n * cssBinding\n * @description\n * DOM decleartive css binding. update classlist.\n * viewModel data can function but must return JSOL.\n * added css class if value is true\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {boolean} forceRender\n */\nconst cssBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n    const dataKey = cache.dataKey;\n    const APP = viewModel.APP || viewModel.$root.APP;\n\n    if (!dataKey || (!forceRender && !APP.$rootElement.contains(cache.el))) {\n        return;\n    }\n\n    cache.elementData = cache.elementData || {};\n    cache.elementData.viewModelPropValue = cache.elementData.viewModelPropValue || '';\n\n    const oldCssList = cache.elementData.viewModelPropValue;\n    let newCssList = '';\n    const vmCssListObj = getViewModelPropValue(viewModel, cache);\n    let vmCssListArray = [];\n    let isViewDataObject = false;\n    let isViewDataString = false;\n    let cssList = [];\n\n    if (typeof vmCssListObj === 'string') {\n        isViewDataString = true;\n    } else if (isPlainObject(vmCssListObj)) {\n        isViewDataObject = true;\n    } else {\n        // reject if vmCssListObj is not an object or string\n        return;\n    }\n\n    if (isViewDataObject) {\n        newCssList = JSON.stringify(vmCssListObj);\n    } else {\n        newCssList = vmCssListObj.replace(/\\s\\s+/g, ' ').trim();\n        vmCssListArray = newCssList.split(' ');\n    }\n    // reject if nothing changed\n    if (oldCssList === newCssList) {\n        return;\n    }\n\n    // get current css classes from element\n    const domCssList = cache.el.classList;\n    // clone domCssList as new array\n    const domCssListLength = domCssList.length;\n    for (let i = 0; i < domCssListLength; i += 1) {\n        cssList.push(domCssList[i]);\n    }\n\n    if (isViewDataObject) {\n        each(vmCssListObj, function(k, v) {\n            const i = cssList.indexOf(k);\n            if (v === true) {\n                cssList.push(k);\n            } else if (i !== -1) {\n                cssList.splice(i, 1);\n            }\n        });\n    } else if (isViewDataString) {\n        // remove oldCssList items from cssList\n        cssList = arrayRemoveMatch(cssList, oldCssList);\n        cssList = cssList.concat(vmCssListArray);\n    }\n\n    // unique cssList array\n    cssList = cssList.filter((v, i, a) => {\n        return a.indexOf(v) === i;\n    });\n\n    cssList = cssList.join(' ');\n    // update element data\n    cache.elementData.viewModelPropValue = newCssList;\n    // replace all css classes\n    cache.el.setAttribute('class', cssList);\n};\n\nexport default cssBinding;\n","import {getViewModelValue} from './util';\n\n/**\n * modelBinding\n * @description input element data binding. viewModel -> DOM update\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {boolean} forceRender\n */\nconst modelBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n    const dataKey = cache.dataKey;\n    let newValue = '';\n    const APP = viewModel.APP || viewModel.$root.APP;\n\n    if (!dataKey || (!forceRender && !APP.$rootElement.contains(cache.el))) {\n        return;\n    }\n\n    newValue = getViewModelValue(viewModel, dataKey);\n\n    if (typeof newValue !== 'undefined' && newValue !== null) {\n        const $element = cache.el;\n        const isCheckbox = $element.type === 'checkbox';\n        const isRadio = $element.type === 'radio';\n        const inputName = $element.name;\n        const $radioGroup = isRadio ? APP.$rootElement.querySelectorAll(`input[name=\"${inputName}\"]`) : [];\n        const oldValue = isCheckbox ? $element.checked : $element.value;\n\n        // update element value\n        if (newValue !== oldValue) {\n            if (isCheckbox) {\n                $element.checked = Boolean(newValue);\n            } else if (isRadio) {\n                let i = 0;\n                const radioGroupLength = $radioGroup.length;\n\n                for (i = 0; i < radioGroupLength; i += 1) {\n                    if ($radioGroup[i].value === newValue) {\n                        $radioGroup[i].checked = true;\n                        break;\n                    }\n                }\n            } else {\n                $element.value = newValue;\n            }\n        }\n    }\n};\n\nexport default modelBinding;\n"," \nimport {bindingDataReference} from './config';\nimport {\n    getViewModelValue,\n    resolveViewModelContext,\n    resolveParamList,\n} from './util';\n\n/**\n * blurBinding\n * DOM decleartive on blur event binding\n * event handler bind to viewModel method according to the DOM attribute\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {boolean} forceRender\n */\nconst hoverBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n    const handlerName = cache.dataKey;\n    let paramList = cache.parameters;\n    const inHandlerName = bindingDataReference.mouseEnterHandlerName;\n    const outHandlerName = bindingDataReference.mouseLeaveHandlerName;\n    let viewModelContext;\n    const APP = viewModel.APP || viewModel.$root.APP;\n\n    cache.elementData = cache.elementData || {};\n\n    // TODO: check what is APP.$rootElement.contains(cache.el)\n    if (!handlerName || (!forceRender && !APP.$rootElement.contains(cache.el))) {\n        return;\n    }\n\n    const handlers = getViewModelValue(viewModel, handlerName);\n\n    if (handlers && typeof handlers[inHandlerName] === 'function' && typeof handlers[outHandlerName] === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n\n        function onMouseEnterHandler(e) {\n            const args = [e, cache.el].concat(paramList);\n            handlers[inHandlerName].apply(viewModelContext, args);\n        }\n\n        function onMouseLeaveHandler(e) {\n            const args = [e, cache.el].concat(paramList);\n            handlers[outHandlerName].apply(viewModelContext, args);\n        }\n\n        cache.el.removeEventListener('mouseenter', onMouseEnterHandler, false);\n        cache.el.removeEventListener('mouseleave', onMouseLeaveHandler, false);\n\n        cache.el.addEventListener('mouseenter', onMouseEnterHandler, false);\n        cache.el.addEventListener('mouseleave', onMouseLeaveHandler, false);\n    }\n};\n\nexport default hoverBinding;\n","import * as util from './util';\n\n/**\n *  pubSub\n * @description use jQuery object as pubSub\n * @example EVENTS object strucure:\n *  EVENTS = {\n        'EVENT-NAME': [{ 'comp-id': fn }],\n        'EVENT-NAME2': [{ 'comp-id': fn }]\n    };\n */\n\nconst EVENTS = {};\n\nconst subscribeEvent = (instance = null, eventName = '', fn, isOnce = false) => {\n    if (!instance || !instance.compId || !eventName || typeof fn !== 'function') {\n        return;\n    }\n\n    let subscriber;\n    let isSubscribed = false;\n\n    eventName = eventName.replace(util.REGEX.WHITE_SPACES, '');\n    EVENTS[eventName] = EVENTS[eventName] || [];\n    // check if already subscribed and update callback fn\n    isSubscribed = EVENTS[eventName].some((subscriber) => {\n        if (subscriber[instance.compId]) {\n            subscriber[instance.compId] = fn.bind(instance.viewModel);\n            subscriber.isOnce = isOnce;\n            return true;\n        }\n    });\n    // push if not yet subscribe\n    if (!isSubscribed) {\n        subscriber = {};\n        subscriber[instance.compId] = fn.bind(instance.viewModel);\n        subscriber.isOnce = isOnce;\n        EVENTS[eventName].push(subscriber);\n    }\n};\n\nconst subscribeEventOnce = (instance = null, eventName = '', fn) => {\n    subscribeEvent(instance, eventName, fn, true);\n};\n\nconst unsubscribeEvent = (compId = '', eventName = '') => {\n    if (!compId || !eventName) {\n        return;\n    }\n\n    let i = 0;\n    let subscribersLength = 0;\n    let subscriber;\n\n    eventName = eventName.replace(util.REGEX.WHITE_SPACES, '');\n\n    if (EVENTS[eventName]) {\n        subscribersLength = EVENTS[eventName].length;\n        for (i = 0; i < subscribersLength; i += 1) {\n            subscriber = EVENTS[eventName][i];\n            if (subscriber[compId]) {\n                EVENTS[eventName].splice(i, 1);\n                break;\n            }\n        }\n    }\n    // delete the event if no more subscriber\n    if (!EVENTS[eventName].length) {\n        delete EVENTS[eventName];\n    }\n};\n\n/**\n * unsubscribeAllEvent\n * @description unsubscribe all event by compId. eg when a component removed\n * @param {string} compId\n */\nconst unsubscribeAllEvent = (compId = '') => {\n    if (!compId) {\n        return;\n    }\n    Object.keys(EVENTS).forEach((eventName) => {\n        unsubscribeEvent(compId, eventName);\n    });\n};\n\nconst publishEvent = (eventName = '', ...args) => {\n    if (!eventName || !EVENTS[eventName]) {\n        return;\n    }\n\n    eventName = eventName.replace(util.REGEX.WHITE_SPACES, '');\n\n    EVENTS[eventName].forEach((subscriber) => {\n        Object.keys(subscriber).forEach((compId) => {\n            if (typeof subscriber[compId] === 'function') {\n                const ret = subscriber[compId](...args);\n                if (subscriber.isOnce) {\n                    unsubscribeEvent(compId, eventName);\n                }\n                return ret;\n            }\n        });\n    });\n};\n\nexport {\n    subscribeEvent,\n    subscribeEventOnce,\n    unsubscribeEvent,\n    unsubscribeAllEvent,\n    publishEvent,\n};\n","import * as config from './config';\r\nimport {debounceRaf} from './util';\r\nimport createBindingCache from './domWalker';\r\nimport createBindingOption from './createBindingOption';\r\nimport applyBinding from './applyBinding';\r\nimport renderTemplatesBinding from './renderTemplatesBinding';\r\nimport postProcess from './postProcess';\r\nimport * as pubSub from './pubSub';\r\n\r\nlet compIdIndex = 0;\r\n\r\nclass Binder {\r\n    constructor($rootElement, viewModel, bindingAttrs) {\r\n        if (!$rootElement || $rootElement.nodeType !== 1 || viewModel === null || typeof viewModel !== 'object') {\r\n            throw new TypeError('$rootElement or viewModel is invalid');\r\n        }\r\n\r\n        this.initRendered = false;\r\n\r\n        this.compId = compIdIndex += 1;\r\n\r\n        this.$rootElement = $rootElement;\r\n\r\n        this.viewModel = viewModel;\r\n\r\n        this.bindingAttrs = bindingAttrs;\r\n\r\n        this.render = debounceRaf(this.render, this);\r\n\r\n        this.isServerRendered = this.$rootElement.getAttribute(config.serverRenderedAttr) !== null;\r\n\r\n        // inject instance into viewModel\r\n        this.viewModel.APP = this;\r\n\r\n        // add $root pointer to viewModel so binding can be refer as $root.something\r\n        this.viewModel.$root = this.viewModel;\r\n\r\n        // 1st step\r\n        // parsView walk the DOM and create binding cache that holds each element's binding details\r\n        // this binding cache is like AST for render and update\r\n        this.parseView();\r\n\r\n        // for jquery user set viewModel referece to $rootElement for easy debug\r\n        // otherwise use Expando to attach viewModel to $rootElement\r\n        this.$rootElement[config.bindingDataReference.rootDataKey] = this.viewModel;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * parseView\r\n     * @description\r\n     * @return {this}\r\n     * traver from $rootElement to find each data-bind-* element\r\n     * then apply data binding\r\n     */\r\n    parseView() {\r\n        this.elementCache = createBindingCache({\r\n            rootNode: this.$rootElement,\r\n            bindingAttrs: this.bindingAttrs,\r\n        });\r\n\r\n        // updateElementCache if server rendered on init\r\n        if (this.isServerRendered && !this.initRendered) {\r\n            this.updateElementCache({\r\n                templateCache: true,\r\n            });\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * updateElementCache\r\n     * @param {object} opt\r\n     * @description call createBindingCache to parse view and generate bindingCache\r\n     */\r\n    updateElementCache(opt = {}) {\r\n        const elementCache = opt.elementCache || this.elementCache;\r\n\r\n        if (opt.allCache) {\r\n            // walk dom from root element to regenerate elementCache\r\n            this.elementCache = createBindingCache({\r\n                rootNode: this.$rootElement,\r\n                bindingAttrs: this.bindingAttrs,\r\n            });\r\n        }\r\n        // walk from first rendered template node to create/update child bindingCache\r\n        if (opt.allCache || opt.templateCache) {\r\n            if (elementCache[this.bindingAttrs.tmp] && elementCache[this.bindingAttrs.tmp].length) {\r\n                // Use for loop to handle templates added during rendering\r\n                for (let i = 0; i < elementCache[this.bindingAttrs.tmp].length; i++) {\r\n                    const cache = elementCache[this.bindingAttrs.tmp][i];\r\n                    // set skipCheck as skipForOfParseFn whenever an node has\r\n                    // both template and forOf bindings\r\n                    // then the template bindingCache should be an empty object\r\n                    let skipForOfParseFn = null;\r\n                    if (cache.el.hasAttribute(this.bindingAttrs.forOf)) {\r\n                        skipForOfParseFn = () => {\r\n                            return true;\r\n                        };\r\n                    }\r\n                    cache.bindingCache = createBindingCache({\r\n                        rootNode: cache.el,\r\n                        bindingAttrs: this.bindingAttrs,\r\n                        skipCheck: skipForOfParseFn,\r\n                        isRenderedTemplate: opt.isRenderedTemplates,\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    render(opt = {}) {\r\n        let updateOption = {};\r\n\r\n        if (!this.initRendered) {\r\n            // only update eventsBinding if server rendered\r\n            if (this.isServerRendered) {\r\n                this.$rootElement.removeAttribute(config.serverRenderedAttr);\r\n                updateOption = createBindingOption(config.bindingUpdateConditions.serverRendered, opt);\r\n            } else {\r\n                updateOption = createBindingOption(config.bindingUpdateConditions.init, opt);\r\n            }\r\n        } else {\r\n            // when called again only update visualBinding options\r\n            updateOption = createBindingOption('', opt);\r\n        }\r\n\r\n        // create postProcessQueue before start rendering\r\n        this.postProcessQueue = [];\r\n\r\n        const renderBindingOption = {\r\n            ctx: this,\r\n            elementCache: this.elementCache,\r\n            updateOption: updateOption,\r\n            bindingAttrs: this.bindingAttrs,\r\n            viewModel: this.viewModel,\r\n        };\r\n\r\n        // always render template binding first\r\n        // render and apply binding to template(s)\r\n        // this is an share function therefore passing 'this' context\r\n        renderTemplatesBinding(renderBindingOption);\r\n\r\n        // apply bindings to rest of the DOM\r\n        applyBinding(renderBindingOption);\r\n\r\n        // trigger postProcess\r\n        postProcess(this.postProcessQueue);\r\n        // clear postProcessQueue\r\n        this.postProcessQueue.length = 0;\r\n        delete this.postProcessQueue;\r\n\r\n        this.initRendered = true;\r\n    }\r\n\r\n    subscribe(eventName = '', fn) {\r\n        pubSub.subscribeEvent(this, eventName, fn);\r\n        return this;\r\n    }\r\n\r\n    subscribeOnce(eventName = '', fn) {\r\n        pubSub.subscribeEventOnce(this, eventName, fn);\r\n        return this;\r\n    }\r\n\r\n    unsubscribe(eventName = '') {\r\n        pubSub.unsubscribeEvent(this.compId, eventName);\r\n        return this;\r\n    }\r\n\r\n    unsubscribeAll() {\r\n        pubSub.unsubscribeAllEvent(this.compId);\r\n        return this;\r\n    }\r\n\r\n    publish(eventName = '', ...args) {\r\n        pubSub.publishEvent(eventName, ...args);\r\n        return this;\r\n    }\r\n}\r\n\r\nexport default Binder;\r\n","import {\n    each,\n    throwErrorMessage,\n} from './util';\n\nexport default function postProcess(tasks) {\n    if (!tasks || !tasks.length) {\n        return;\n    }\n\n    each(tasks, (index, task) => {\n        if (typeof task === 'function') {\n            try {\n                task();\n            } catch (err) {\n                throwErrorMessage(err, 'Error postProcess: ' + String(task));\n            }\n        }\n    });\n}\n","import * as config from './config';\nimport {extend} from './util';\nimport Binder from './binder';\n\nconst isSupportPromise = typeof window['Promise'] === 'function';\n\nlet bindingAttrs = config.bindingAttrs;\n\nconst use = (settings = {}) => {\n    if (settings.bindingAttrs) {\n        bindingAttrs = extend({}, settings.bindingAttrs);\n    }\n};\n\nconst init = ($rootElement, viewModel = null) => {\n    if (!isSupportPromise) {\n        return console.warn('Browser not support Promise');\n    }\n    return new Binder($rootElement, viewModel, bindingAttrs);\n};\n\nexport default {\n    use: use,\n    init: init,\n    version: '@version@',\n};\n"],"names":["bindingAttrs","comp","tmp","text","click","dblclick","blur","focus","hover","input","change","submit","model","show","css","attr","forOf","if","switch","case","default","serverRenderedAttr","commentPrefix","commentSuffix","bindingDataReference","bindingUpdateConditions","maxDatakeyLength","constants","ONCE","hasIsArray","Array","isArray","REGEX","BAD_TAGS","FOR_OF","FUNCTION_PARAM","HTML_TAG","OBJECT_LITERAL","PIPE","WHITE_SPACES","LINE_BREAKS_TABS","IS_SUPPORT_TEMPLATE","document","createElement","WRAP_MAP","div","thead","col","tr","td","caption","colgroup","tbody","tfoot","th","obj","Object","prototype","toString","call","isJsObject","isPlainObject","ctor","constructor","prot","hasOwnProperty","isEmptyObject","getOwnPropertyNames","length","createHtmlFragment","htmlString","template","innerHTML","replace","removeBadTags","content","fragment","createDocumentFragment","queryContainer","firstTag","match","getFirstHtmlStringTag","wrap","createRange","createContextualFragment","insertAdjacentHTML","query","querySelector","firstChild","appendChild","getViewModelValue","viewModel","prop","split","filter","Boolean","every","step","undefined","def","setViewModelValue","value","_set","path","slice","reduce","a","c","i","Math","abs","getViewModelPropValue","bindingCache","dataKey","paramList","parameters","isInvertBoolean","charAt","substring","ret","viewModelContext","resolveViewModelContext","oldViewModelProValue","elementData","viewModelPropValue","resolveParamList","args","concat","el","apply","filtersViewModelPropValue","filters","each","index","filterFn","err","throwErrorMessage","createDeferredObj","dfObj","promise","Promise","resolve","reject","extend","isDeepMerge","target","sources","source","shift","isMergebleObject","keys","forEach","key","_extends","fn","keysLength","isArrayObj","TypeError","item","cloneDomNode","element","cloneNode","insertAfter","parentNode","newNode","referenceNode","refNextElement","nextSibling","insertBefore","datakey","bindingDataContext","config","map","param","trim","emptyElement","node","removeChild","errorMessage","message","console","error","log","bindingAttrsMap","walkDOM","func","parseChildNode","firstElementChild","nextElementSibling","rootSkipCheck","tagName","defaultSkipCheck","hasAttribute","populateBindingCache","attrObj","type","attrValue","cacheData","filterList","isOnceIndex","v","isOnce","splice","extractFilterList","str","paramlist","getFunctionParameterList","push","createBindingCache","rootNode","skipCheck","isRenderedTemplate","window","Node","sourceObj","parseNode","skipNodeCheckFn","isSkipForOfChild","nodeType","hasAttributes","attributes","name","getAttributesObject","hasSkipChildParseBindings","checkSkipChildParseBindings","iterateList","createBindingOption","condition","opt","visualBindingOptions","templateBinding","textBinding","cssBinding","ifBinding","showBinding","modelBinding","attrBinding","forOfBinding","switchBinding","eventsBindingOptions","changeBinding","clickBinding","dblclickBinding","blurBinding","focusBinding","hoverBinding","inputBinding","submitBinding","serverRenderedOptions","updateOption","forceRender","reUnescapedHtml","reHasUnescapedHtml","RegExp","htmlEscapes","escapeHtmlChar","chr","cache","handlerName","modelDataKey","getAttribute","newValue","oldValue","APP","$root","$rootElement","contains","handlerFn","changeHandler","e","$this","this","isCheckbox","string","checked","test","currentTarget","removeEventListener","addEventListener","isObjLiteralStr","isObjectLiteralString","vmAttrObj","parseBindingObjectString","objectLiteralString","keyVal","JSON","stringify","oldAttrObj","setAttribute","removeAttribute","$domFragment","$templateRoot","$templateRootPrepend","$templateRootAppend","nestTemplatesCount","renderTemplate","elementCache","settings","parse","parseStringToJson","viewData","data","isAppend","append","isPrepend","prepend","$currentElement","$element","$index","htmlFragment","id","templateElement","getElementById","getTemplateString","childNodes","$nestedTemplates","querySelectorAll","nestedTemplatesLength","thisTemplateCache","afterTemplateRender","renderTemplatesBinding","ctx","updateElementCache","templateCache","isRenderedTemplates","applyBindingModule","renderIteration","iterationVm","isRegenerate","bindingUpdateOption","createClonedElementCache","bindingData","clonedElement","setCommentPrefix","dataKeyMarker","util","setDocRangeEndAfter","endTextContent","textContent","docRange","setEndBefore","wrapCommentAround","prefix","commentBegin","createComment","commentEnd","previousNonTemplateElement","previousSibling","nextNonTemplateElement","parentElement","removeElemnetsByCommentWrap","setStartBefore","deleteContents","insertRenderedElements","createIterationViewModel","iterationData","iterator","alias","generateForOfElements","iterationDataLength","iterationSize","clonedItem","iterationBindingCache","forExpMatch","renderForOfBinding","configBindingAttrs","renderIfBinding","isDomRemoved","commentStartTextContent","endCommentTag","isTargetDomRemoved","rootElement","removeIfBinding","hasIterationBindingCache","shouldRender","removeBindingInQueue","postProcessQueue","indexOf","newExpression","cases","childrenElements","children","elementLength","caseData","createCaseData","isDefault","hasMatch","j","casesLength","newCaseValue","removeUnmatchCases","matchedIndex","attrName","createEventBinding","handlerWrap","formData","$form","HTMLFormElement","FormData","getFormData","applyBinding","currentInlineSytle","currentInlineDisplaySytle","shouldShow","oldShowStatus","displayStyle","computedStyle","style","display","computeStyle","getComputedStyle","getPropertyValue","setProperty","removeProperty","oldCssList","newCssList","vmCssListObj","vmCssListArray","isViewDataObject","isViewDataString","cssList","domCssList","classList","domCssListLength","arrayRemoveMatch","frommArray","k","join","isRadio","inputName","$radioGroup","radioGroupLength","inHandlerName","outHandlerName","handlers","onMouseEnterHandler","onMouseLeaveHandler","EVENTS","subscribeEvent","instance","eventName","compId","subscriber","isSubscribed","some","bind","unsubscribeEvent","subscribersLength","compIdIndex","Binder","initRendered","render","debounceRaf","rafId","from","arguments","cancelAnimationFrame","requestAnimationFrame","isServerRendered","parseView","allCache","skipForOfParseFn","renderBindingOption","tasks","task","String","subscribe","pubSub","subscribeOnce","subscribeEventOnce","unsubscribe","unsubscribeAll","unsubscribeAllEvent","publish","publishEvent","isSupportPromise","use","init","warn","version"],"mappings":"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"}