{"version":3,"sources":["dataBind.min.js"],"names":["bindingAttrs","comp","tmp","text","click","dblclick","blur","focus","hover","change","submit","model","show","css","attr","forOf","if","switch","case","default","commentPrefix","bindingDataReference","bindingUpdateConditions","constants","ONCE","_","window","hasIsArray","Array","isArray","supportPromise","REGEX","IS_SUPPORT_TEMPLATE","document","createElement","WRAP_MAP","div","thead","col","tr","td","createHtmlFragment","htmlString","template","innerHTML","replace","removeBadTags","content","fragment","createDocumentFragment","queryContainer","firstTag","match","getFirstHtmlStringTag","wrap","createRange","createContextualFragment","insertAdjacentHTML","query","querySelector","firstChild","appendChild","caption","colgroup","tbody","tfoot","th","obj","Object","prototype","toString","call","isJsObject","isPlainObject","ctor","constructor","prot","hasOwnProperty","isEmptyObject","getOwnPropertyNames","length","getViewModelValue","viewModel","prop","get","getViewModelPropValue","bindingCache","dataKey","paramList","parameters","isInvertBoolean","charAt","substring","ret","viewModelContext","resolveViewModelContext","oldViewModelProValue","elementData","viewModelProValue","resolveParamList","args","concat","el","apply","Boolean","filtersViewModelPropValue","value","filters","each","index","filter","filterFn","err","throwErrorMessage","getFormData","$form","data","HTMLFormElement","FormData","forEach","key","push","createDeferredObj","dfObj","promise","Promise","resolve","reject","$","Deferred","extend","isDeepMerge","target","sources","source","shift","undefined","isMergebleObject","keys","assign","fn","keysLength","isArrayObj","i","TypeError","item","insertAfter","parentNode","newNode","referenceNode","refNextElement","nextSibling","insertBefore","datakey","bindingDataContext","split","map","param","trim","emptyElement","node","removeChild","errorMessage","message","console","error","log","$domFragment","$templateRoot","nestTemplatesCount","templateCache","renderTemplate","cache","elementCache","settings","str","JSON","parse","parseStringToJson","viewData","isAppend","append","isPrepend","prepend","$currentElement","$element","$index","getAttribute","htmlFragment","id","templateData","templateString","templateElement","getElementById","variable","compileTemplate","childNodes","$nestedTemplates","querySelectorAll","nestedTemplatesLength","thisTemplateCache","afterTemplateRender","changeBinding","forceRender","handlerName","modelDataKey","newValue","oldValue","APP","$root","$rootElement","contains","handlerFn","changeHandler","e","isCheckbox","this","type","checked","escape","set","currentTarget","removeEventListener","addEventListener","bindingAttrsMap","walkDOM","func","parseChildNode","firstElementChild","nextElementSibling","rootSkipCheck","tagName","defaultSkipCheck","hasAttribute","populateBindingCache","attrObj","attrValue","cacheData","filterList","isOnceIndex","v","isOnce","splice","extractFilterList","paramlist","getFunctionParameterList","createBindingCache","rootNode","skipCheck","isRenderedTemplate","Node","sourceObj","reduce","parseNode","skipNodeCheckFn","isSkipForOfChild","nodeType","hasAttributes","slice","attributes","name","getAttributesObject","hasSkipChildParseBindings","checkSkipChildParseBindings","iterateList","createClonedElementCache","bindingData","clonedElement","cloneNode","setCommentPrefix","commentPrefix$1","dataKeyMarker","setDocRangeEndAfter","endTextContent","textContent","docRange","setEndBefore","wrapCommentAround","prefix","commentBegin","createComment","commentEnd","previousNonTemplateElement","previousSibling","nextNonTemplateElement","parentElement","removeElemnetsByCommentWrap","setStartBefore","deleteContents","insertRenderedElements","renderForOfBinding","bindingAttrs$1","iterationDataLength","iterationData","iterator","isRegenerate","iterationSize","removeAttribute","iterationBindingCache","iterationVm","createIterationViewModel","renderIteration","generateForOfElements","alias","clonedItem","renderIfBinding","isDomRemoved","commentStartTextContent","endCommentTag","isTargetDomRemoved","rootElement","removeIfBinding","hasIterationBindingCache","ifBinding","viewModelPropValue","shouldRender","removeBindingInQueue","postProcessQueue","indexOf","removeUnmatchCases","cases","matchedIndex","caseData","createCaseData","attrName","EVENTS","subscribeEvent","instance","eventName","compId","subscriber","isSubscribed","some","bind","unsubscribeEvent","subscribersLength","compIdIndex","Binder","[object Object]","initRendered","render","ctx","rafId","from","arguments","cancelAnimationFrame","requestAnimationFrame","debounceRaf","isServerRendered","parseView","updateElementCache","opt","allCache","skipForOfParseFn","isRenderedTemplates","updateOption","createBindingOption","renderTemplatesBinding","applyBinding","postProcess","forOfBinding","forExpMatch","attrBinding","oldAttrObj","vmAttrObj","stringify","setAttribute","showBinding","currentInlineSytle","currentInlineDisplaySytle","shouldShow","oldShowStatus","displayStyle","computedStyle","style","display","computeStyle","getComputedStyle","getPropertyValue","setProperty","removeProperty","switchBinding","newExpression","childrenElements","children","elementLength","isDefault","hasMatch","j","casesLength","newCaseValue","textBinding","cssBinding","oldCssList","newCssList","vmCssListObj","vmCssListArray","isViewDataObject","isViewDataString","cssList","domCssList","classList","domCssListLength","frommArray","k","a","join","modelBinding","isRadio","inputName","$radioGroup","radioGroupLength","submitBinding","submitHandler","clickBinding","clickHandler","dblclickBinding","dbclickHandler","blurBinding","blurHandler","focusBinding","focusHandler","hoverBinding","inHandlerName","outHandlerName","handlers","onMouseEnterHandler","onMouseLeaveHandler","tasks","task","String","subscribeEventOnce","unsubscribeAllEvent","publishEvent","templateBinding","condition","visualBindingOptions","eventsBindingOptions","serverRenderedOptions","bindingUpdateOption","templateSettings$1","evaluate","interpolate","dataBind","use","templateSettings","init","version"],"mappings":"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","file":"dataBind.min.js","sourcesContent":["/**\n * dataBind\n * version 1.9.0\n * By Adam Chow\n * link https://gogocat.github.io/dataBind/\n * license MIT\n * \n */\n\n(function () {\n    'use strict';\n\n    const bindingAttrs = {\n      comp: 'data-jq-comp',\n      tmp: 'data-jq-tmp',\n      text: 'data-jq-text',\n      click: 'data-jq-click',\n      dblclick: 'data-jq-dblclick',\n      blur: 'data-jq-blur',\n      focus: 'data-jq-focus',\n      hover: 'data-jq-hover',\n      change: 'data-jq-change',\n      submit: 'data-jq-submit',\n      model: 'data-jq-model',\n      show: 'data-jq-show',\n      css: 'data-jq-css',\n      attr: 'data-jq-attr',\n      forOf: 'data-jq-for',\n      if: 'data-jq-if',\n      switch: 'data-jq-switch',\n      case: 'data-jq-case',\n      default: 'data-jq-default'\n    };\n    const serverRenderedAttr = 'data-server-rendered';\n    const dataIndexAttr = 'data-index';\n    const commentPrefix = {\n      forOf: 'data-forOf_',\n      if: 'data-if_',\n      case: 'data-case_',\n      default: 'data-default_'\n    };\n    const commentSuffix = '_end'; // global setting of underscore template inteprolate default token\n\n    const templateSettings = {\n      evaluate: /<%([\\s\\S]+?)%>/g,\n      interpolate: /\\{\\{=(.+?)\\}\\}/g,\n      escape: /\\{\\{(.+?)\\}\\}/g\n    };\n    const bindingDataReference = {\n      rootDataKey: '$root',\n      currentData: '$data',\n      currentIndex: '$index',\n      mouseEnterHandlerName: 'in',\n      mouseLeaveHandlerName: 'out'\n    };\n    const bindingUpdateConditions = {\n      serverRendered: 'SERVER-RENDERED',\n      init: 'INIT'\n    }; // maximum string length before running regex\n\n    const maxDatakeyLength = 50;\n    const constants = {\n      filters: {\n        ONCE: 'once'\n      },\n      PARENT_REF: '_parent'\n    };\n\n    _ = window._ || {};\n    const hasIsArray = Array.isArray;\n    const supportPromise = typeof window['Promise'] === 'function';\n    const REGEX = {\n      FUNCTIONPARAM: /\\((.*?)\\)/,\n      WHITESPACES: /\\s+/g,\n      FOROF: /(.*?)\\s+(?:in|of)\\s+(.*)/,\n      PIPE: /\\|/,\n      HTML_TAG: /^[\\s]*<([a-z][^\\/\\s>]+)/i,\n      BAG_TAGS: /<(script|del)(?=[\\s>])[\\w\\W]*?<\\/\\1\\s*>/ig\n    };\n    const IS_SUPPORT_TEMPLATE = ('content' in document.createElement('template'));\n    const WRAP_MAP = {\n      div: ['div', '<div>', '</div>'],\n      thead: ['table', '<table>', '</table>'],\n      col: ['colgroup', '<table><colgroup>', '</colgroup></table>'],\n      tr: ['tbody', '<table><tbody>', '</tbody></table>'],\n      td: ['tr', '<table><tr>', '</tr></table>']\n    };\n    WRAP_MAP.caption = WRAP_MAP.colgroup = WRAP_MAP.tbody = WRAP_MAP.tfoot = WRAP_MAP.thead;\n    WRAP_MAP.th = WRAP_MAP.td;\n\n    function getFirstHtmlStringTag(htmlString) {\n      const match = htmlString.match(REGEX.HTML_TAG);\n\n      if (match) {\n        return match[1];\n      }\n\n      return null;\n    }\n\n    function removeBadTags(htmlString = '') {\n      return htmlString.replace(REGEX.BAG_TAGS, '');\n    }\n\n    function createHtmlFragment(htmlString) {\n      if (typeof htmlString !== 'string') {\n        return null;\n      } // use template element\n\n\n      if (IS_SUPPORT_TEMPLATE) {\n        const template = document.createElement('template');\n        template.innerHTML = removeBadTags(htmlString);\n        return template.content;\n      } // use document fragment with wrap html tag for tr, td etc.\n\n\n      const fragment = document.createDocumentFragment();\n      const queryContainer = document.createElement('div');\n      const firstTag = getFirstHtmlStringTag(htmlString);\n      const wrap = WRAP_MAP[firstTag || 'div'];\n\n      if (wrap[0] === 'div') {\n        return document.createRange().createContextualFragment(htmlString);\n      }\n\n      queryContainer.insertAdjacentHTML('beforeend', `${wrap[1]}${htmlString}${wrap[2]}`);\n      const query = queryContainer.querySelector(wrap[0]);\n\n      while (query.firstChild) {\n        fragment.appendChild(query.firstChild);\n      }\n\n      return fragment;\n    }\n\n    const isArray = obj => {\n      return hasIsArray ? Array.isArray(obj) : Object.prototype.toString.call(obj) === '[object Array]';\n    };\n\n    const isJsObject = obj => {\n      return obj !== null && typeof obj === 'object' && Object.prototype.toString.call(obj) === '[object Object]';\n    };\n\n    const isPlainObject = obj => {\n      if (!isJsObject(obj)) {\n        return false;\n      } // If has modified constructor\n\n\n      const ctor = obj.constructor;\n      if (typeof ctor !== 'function') return false; // If has modified prototype\n\n      const prot = ctor.prototype;\n      if (isJsObject(prot) === false) return false; // If constructor does not have an Object-specific method\n\n      if (prot.hasOwnProperty('isPrototypeOf') === false) {\n        return false;\n      } // Most likely a plain Object\n\n\n      return true;\n    };\n\n    const isEmptyObject = obj => {\n      if (isJsObject(obj)) {\n        return Object.getOwnPropertyNames(obj).length === 0;\n      }\n\n      return false;\n    };\n    /**\r\n     * getViewModelValue\r\n     * @description walk a object by provided string path. eg 'a.b.c'\r\n     * @param {object} viewModel\r\n     * @param {string} prop\r\n     * @return {object}\r\n     */\n\n\n    const getViewModelValue = (viewModel, prop) => {\n      return _.get(viewModel, prop);\n    };\n    /**\r\n     * setViewModelValue\r\n     * @description populate viewModel object by path string\r\n     * @param {object} obj\r\n     * @param {string} prop\r\n     * @param {string} value\r\n     * @return {call} underscore set\r\n     */\n\n\n    const setViewModelValue = (obj, prop, value) => {\n      return _.set(obj, prop, value);\n    };\n\n    const getViewModelPropValue = (viewModel, bindingCache) => {\n      let dataKey = bindingCache.dataKey;\n      let paramList = bindingCache.parameters;\n      const isInvertBoolean = dataKey.charAt(0) === '!';\n\n      if (isInvertBoolean) {\n        dataKey = isInvertBoolean ? dataKey.substring(1) : dataKey;\n      }\n\n      let ret = getViewModelValue(viewModel, dataKey);\n\n      if (typeof ret === 'function') {\n        const viewModelContext = resolveViewModelContext(viewModel, dataKey);\n        const oldViewModelProValue = bindingCache.elementData ? bindingCache.elementData.viewModelProValue : null;\n        paramList = paramList ? resolveParamList(viewModel, paramList) : []; // let args = [oldViewModelProValue, bindingCache.el].concat(paramList);\n\n        const args = paramList.concat([oldViewModelProValue, bindingCache.el]);\n        ret = ret.apply(viewModelContext, args);\n      }\n\n      ret = isInvertBoolean ? !Boolean(ret) : ret; // call through fitlers to get final value\n\n      ret = filtersViewModelPropValue({\n        value: ret,\n        viewModel: viewModel,\n        bindingCache: bindingCache\n      });\n      return ret;\n    };\n\n    const filtersViewModelPropValue = ({\n      value,\n      viewModel,\n      bindingCache\n    }) => {\n      let ret = value;\n\n      if (bindingCache.filters) {\n        each(bindingCache.filters, (index, filter) => {\n          const viewModelContext = resolveViewModelContext(viewModel, filter);\n          const filterFn = getViewModelValue.call(viewModelContext, viewModelContext, filter);\n\n          try {\n            ret = filterFn.call(viewModelContext, ret);\n          } catch (err) {\n            throwErrorMessage(err, `Invalid filter: ${filter}`);\n          }\n        });\n      }\n\n      return ret;\n    };\n\n    const parseStringToJson = str => {\n      // fix unquote or single quote keys and replace single quote to double quote\n      const ret = str.replace(/(\\s*?{\\s*?|\\s*?,\\s*?)(['\"])?([a-zA-Z0-9]+)(['\"])?:/g, '$1\"$3\":').replace(/'/g, '\"');\n      return JSON.parse(ret);\n    };\n    /**\r\n     * arrayRemoveMatch\r\n     * @description remove match items in fromArray out of toArray\r\n     * @param {array} toArray\r\n     * @param {array} frommArray\r\n     * @return {boolean}\r\n     */\n\n\n    const arrayRemoveMatch = (toArray, frommArray) => {\n      return toArray.filter((value, index) => {\n        return frommArray.indexOf(value) < 0;\n      });\n    };\n\n    const getFormData = $form => {\n      const data = {};\n\n      if (!$form instanceof HTMLFormElement) {\n        return data;\n      }\n\n      const formData = new FormData($form);\n      formData.forEach((value, key) => {\n        if (!Object.prototype.hasOwnProperty.call(Object, key)) {\n          data[key] = value;\n          return;\n        }\n\n        if (!Array.isArray(data[key])) {\n          data[key] = [data[key]];\n        }\n\n        data[key].push(value);\n      });\n      return data;\n    };\n    /**\r\n     * getFunctionParameterList\r\n     * @description convert parameter string to arrary\r\n     * eg. '(\"a\",\"b\",\"c\")' > [\"a\",\"b\",\"c\"]\r\n     * @param {string} str\r\n     * @return {array} paramlist\r\n     */\n\n\n    const getFunctionParameterList = str => {\n      if (!str || str.length > maxDatakeyLength) {\n        return;\n      }\n\n      let paramlist = str.match(REGEX.FUNCTIONPARAM);\n\n      if (paramlist && paramlist[1]) {\n        paramlist = paramlist[1].split(',');\n        paramlist.forEach(function (v, i) {\n          paramlist[i] = v.trim();\n        });\n      }\n\n      return paramlist;\n    };\n\n    const extractFilterList = cacheData => {\n      if (!cacheData || !cacheData.dataKey || cacheData.dataKey.length > maxDatakeyLength) {\n        return cacheData;\n      }\n\n      const filterList = cacheData.dataKey.split(REGEX.PIPE);\n      let isOnceIndex;\n      cacheData.dataKey = filterList[0].trim();\n\n      if (filterList.length > 1) {\n        filterList.shift(0);\n        filterList.forEach(function (v, i) {\n          filterList[i] = v.trim();\n\n          if (filterList[i] === constants.filters.ONCE) {\n            cacheData.isOnce = true;\n            isOnceIndex = i;\n          }\n        }); // don't store filter 'once' - because it is internal logic not a property from viewModel\n\n        if (isOnceIndex >= 0) {\n          filterList.splice(isOnceIndex, 1);\n        }\n\n        cacheData.filters = filterList;\n      }\n\n      return cacheData;\n    };\n\n    const invertObj = sourceObj => {\n      return Object.keys(sourceObj).reduce(function (obj, key) {\n        obj[sourceObj[key]] = key;\n        return obj;\n      }, {});\n    };\n\n    const createDeferredObj = () => {\n      let dfObj = {};\n\n      if (supportPromise) {\n        dfObj.promise = new Promise((resolve, reject) => {\n          dfObj.resolve = resolve;\n          dfObj.reject = reject;\n        });\n      } else {\n        dfObj = $.Deferred(); // eslint-disable-line new-cap\n      }\n\n      return dfObj;\n    };\n    /**\r\n     * debounce\r\n     * @description decorate a function to be debounce using requestAnimationFrame\r\n     * @param {function} fn\r\n     * @param {context} ctx\r\n     * @return {function}\r\n     */\n\n\n    const debounceRaf = (fn, ctx = null) => {\n      return function (fn, ctx) {\n        let dfObj = createDeferredObj();\n        let rafId = 0; // return decorated fn\n\n        return function () {\n          /* eslint-disable prefer-rest-params */\n          const args = Array.from ? Array.from(arguments) : Array.prototype.slice.call(arguments);\n          window.cancelAnimationFrame(rafId);\n          rafId = window.requestAnimationFrame(() => {\n            try {\n              // fn is Binder.render function\n              fn.apply(ctx, args); // dfObj.resolve is function provided in .then promise chain\n              // ctx is the current component\n\n              dfObj.resolve(ctx);\n            } catch (err) {\n              console.error('error in rendering: ', err);\n              dfObj.reject(err);\n            } // reset dfObj - otherwise then callbacks will not be in execution order\n            // example:\n            // myApp.render().then(function(){console.log('ok1')});\n            // myApp.render().then(function(){console.log('ok2')});\n            // myApp.render().then(function(){console.log('ok3')});\n            // >> ok1, ok2, ok3\n\n\n            dfObj = createDeferredObj();\n            window.cancelAnimationFrame(rafId);\n          });\n          /* eslint-enable prefer-rest-params */\n\n          return supportPromise ? dfObj.promise : dfObj.promise();\n        };\n      }(fn, ctx);\n    };\n    /**\r\n     * extend\r\n     * @param {boolean} isDeepMerge\r\n     * @param {object} target\r\n     * @param {object} sources\r\n     * @return {object} merged object\r\n     */\n\n\n    const extend = (isDeepMerge = false, target, ...sources) => {\n      if (!sources.length) {\n        return target;\n      }\n\n      const source = sources.shift();\n\n      if (source === undefined) {\n        return target;\n      }\n\n      if (!isDeepMerge) {\n        return Object.assign(target, ...sources);\n      }\n\n      if (isMergebleObject(target) && isMergebleObject(source)) {\n        Object.keys(source).forEach(key => {\n          if (isMergebleObject(source[key])) {\n            if (!target[key]) {\n              target[key] = {};\n            }\n\n            extend(target[key], source[key]);\n          } else {\n            target[key] = source[key];\n          }\n        });\n      }\n\n      return extend(true, target, ...sources);\n    };\n\n    const each = (obj, fn) => {\n      if (typeof obj !== 'object' || typeof fn !== 'function') {\n        return;\n      }\n\n      let keys = [];\n      let keysLength = 0;\n      const isArrayObj = isArray(obj);\n      let key;\n      let value;\n      let i = 0;\n\n      if (isArrayObj) {\n        keysLength = obj.length;\n      } else if (isJsObject(obj)) {\n        keys = Object.keys(obj);\n        keysLength = keys.length;\n      } else {\n        throw new TypeError('Object is not an array or object');\n      }\n\n      for (i = 0; i < keysLength; i += 1) {\n        if (isArrayObj) {\n          key = i;\n          value = obj[i];\n        } else {\n          key = keys[i];\n          value = obj[key];\n        }\n\n        fn(key, value);\n      }\n    };\n\n    const isMergebleObject = item => {\n      return isJsObject(item) && !isArray(item);\n    };\n    /**\r\n     * cloneDomNode\r\n     * @param {object} element\r\n     * @return {object} cloned element\r\n     * @description helper function to clone node\r\n     */\n\n\n    const cloneDomNode = element => {\n      return element.cloneNode(true);\n    };\n    /**\r\n     * insertAfter\r\n     * @param {object} parentNode\r\n     * @param {object} newNode\r\n     * @param {object} referenceNode\r\n     * @return {object} node\r\n     * @description helper function to insert new node before the reference node\r\n     */\n\n\n    const insertAfter = (parentNode, newNode, referenceNode) => {\n      const refNextElement = referenceNode && referenceNode.nextSibling ? referenceNode.nextSibling : null;\n      return parentNode.insertBefore(newNode, refNextElement);\n    };\n\n    const resolveViewModelContext = (viewModel, datakey) => {\n      let ret = viewModel;\n\n      if (typeof datakey !== 'string') {\n        return ret;\n      }\n\n      const bindingDataContext = datakey.split('.');\n\n      if (bindingDataContext.length > 1) {\n        if (bindingDataContext[0] === bindingDataReference.rootDataKey) {\n          ret = viewModel[bindingDataReference.rootDataKey] || viewModel;\n        } else if (bindingDataContext[0] === bindingDataReference.currentData) {\n          ret = viewModel[bindingDataReference.currentData] || viewModel;\n        }\n      }\n\n      return ret;\n    };\n\n    const resolveParamList = (viewModel, paramList) => {\n      if (!viewModel || !isArray(paramList)) {\n        return;\n      }\n\n      return paramList.map(param => {\n        param = param.trim();\n\n        if (param === bindingDataReference.currentIndex) {\n          // convert '$index' to value\n          param = viewModel[bindingDataReference.currentIndex];\n        } else if (param === bindingDataReference.currentData) {\n          // convert '$data' to value or current viewModel\n          param = viewModel[bindingDataReference.currentData] || viewModel;\n        } else if (param === bindingDataReference.rootDataKey) {\n          // convert '$root' to root viewModel\n          param = viewModel[bindingDataReference.rootDataKey] || viewModel;\n        }\n\n        return param;\n      });\n    };\n\n    const removeElement = el => {\n      if (el && el.parentNode) {\n        el.parentNode.removeChild(el);\n      }\n    };\n\n    const emptyElement = node => {\n      if (node && node.firstChild) {\n        while (node.firstChild) {\n          node.removeChild(node.firstChild);\n        }\n      }\n\n      return node;\n    };\n\n    const throwErrorMessage = (err = null, errorMessage = '') => {\n      const message = err && err.message ? err.message : errorMessage;\n\n      if (typeof console.error === 'function') {\n        return console.error(message);\n      }\n\n      return console.log(message);\n    };\n\n    let $domFragment = null;\n    let $templateRoot = null;\n    let nestTemplatesCount = 0;\n    const templateCache = {};\n    /**\r\n     * compileTemplate\r\n     * @description compile underscore template and store in templateCache\r\n     * @param {string} id\r\n     * @param {object} templateData\r\n     * @return {string} rendered html string\r\n     */\n\n    const compileTemplate = (id, templateData = null) => {\n      let templateString;\n      let templateElement;\n\n      if (!templateCache[id]) {\n        templateElement = document.getElementById(id);\n        templateString = templateElement ? templateElement.innerHTML : '';\n        templateCache[id] = _.template(templateString, {\n          variable: 'data'\n        });\n      }\n\n      return templateCache[id](templateData);\n    };\n    /**\r\n     * renderTemplate\r\n     * @description\r\n     * get template setting from DOM attribute then call compileTemplate\r\n     * to render and append to target DOM\r\n     * @param {object} cache\r\n     * @param {object} viewModel\r\n     * @param {object} bindingAttrs\r\n     * @param {object} elementCache\r\n     */\n\n\n    const renderTemplate = (cache, viewModel, bindingAttrs, elementCache) => {\n      const settings = typeof cache.dataKey === 'string' ? parseStringToJson(cache.dataKey) : cache.dataKey;\n      let viewData = settings.data;\n      const isAppend = settings.append;\n      const isPrepend = settings.prepend;\n      let $currentElement;\n      cache.dataKey = settings;\n      viewData = typeof viewData === 'undefined' || viewData === '$root' ? viewModel : getViewModelPropValue(viewModel, {\n        dataKey: settings.data,\n        parameters: cache.parameters\n      });\n\n      if (!viewData) {\n        return;\n      }\n\n      const $element = cache.el;\n      const $index = typeof viewModel.$index !== 'undefined' ? viewModel.$index : $element.getAttribute(dataIndexAttr);\n\n      if (typeof $index !== 'undefined') {\n        viewData.$index = $index;\n      }\n\n      $domFragment = $domFragment || document.createDocumentFragment();\n      $templateRoot = $templateRoot || $element;\n      const htmlString = compileTemplate(settings.id, viewData);\n      const htmlFragment = createHtmlFragment(htmlString); // append rendered html\n\n      if (!$domFragment.childNodes.length) {\n        // domFragment should be empty in first run\n        $currentElement = $domFragment; // copy of $domFragment for later find nested template check\n\n        $domFragment.appendChild(htmlFragment);\n      } else {\n        // during recursive run keep append to current fragment\n        $currentElement = $element; // reset to current nested template element\n\n        if (!isAppend && !isPrepend) {\n          $currentElement = emptyElement($currentElement);\n        }\n\n        if (isPrepend) {\n          $currentElement.insertBefore(htmlFragment, $currentElement.firstChild);\n        } else {\n          $currentElement.appendChild(htmlFragment);\n        }\n      } // check if there are nested template then recurisive render them\n\n\n      const $nestedTemplates = $currentElement.querySelectorAll('[' + bindingAttrs.tmp + ']');\n      const nestedTemplatesLength = $nestedTemplates.length;\n\n      if (nestedTemplatesLength) {\n        nestTemplatesCount += nestedTemplatesLength;\n\n        for (let i = 0; i < nestedTemplatesLength; i += 1) {\n          const thisTemplateCache = {\n            el: $nestedTemplates[i],\n            dataKey: $nestedTemplates[i].getAttribute(bindingAttrs.tmp)\n          };\n          elementCache[bindingAttrs.tmp].push(thisTemplateCache); // recursive template render\n\n          renderTemplate(thisTemplateCache, viewModel, bindingAttrs, elementCache);\n          nestTemplatesCount -= 1;\n        }\n      } // no more nested tempalted to render, start to append $domFragment into $templateRoot\n\n\n      if (nestTemplatesCount === 0) {\n        // append to DOM once\n        if (!isAppend && !isPrepend) {\n          $templateRoot = emptyElement($templateRoot);\n        }\n\n        if (isPrepend) {\n          $templateRoot.insertBefore($domFragment, $templateRoot.firstChild);\n        } else {\n          $templateRoot.appendChild($domFragment);\n        } // clear cached fragment\n\n\n        $domFragment = $templateRoot = null; // trigger callback if provided\n\n        if (typeof viewModel.afterTemplateRender === 'function') {\n          viewModel.afterTemplateRender(viewData);\n        }\n      }\n    };\n\n    /* eslint-disable no-invalid-this */\n    /**\r\n     * clickBinding\r\n     * @description\r\n     * DOM decleartive click event binding\r\n     * event handler bind to viewModel method according to the DOM attribute\r\n     * @param {object} cache\r\n     * @param {object} viewModel\r\n     * @param {object} bindingAttrs\r\n     * @param {boolean} forceRender\r\n     */\n\n    const clickBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n      const handlerName = cache.dataKey;\n      let paramList = cache.parameters;\n      let viewModelContext;\n      const APP = viewModel.APP || viewModel.$root.APP;\n\n      if (!handlerName || !forceRender && !APP.$rootElement.contains(cache.el)) {\n        return;\n      }\n\n      const handlerFn = getViewModelValue(viewModel, handlerName);\n\n      if (typeof handlerFn === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n\n        function clickHandler(e) {\n          const args = [e, e.currentTarget].concat(paramList);\n          handlerFn.apply(viewModelContext, args);\n        }\n\n        cache.el.removeEventListener('click', clickHandler, false);\n        cache.el.addEventListener('click', clickHandler, false);\n      }\n    };\n\n    /* eslint-disable no-invalid-this */\n    /**\r\n     * dblclickBinding\r\n     * DOM decleartive double click event binding\r\n     * event handler bind to viewModel method according to the DOM attribute\r\n     * @param {object} cache\r\n     * @param {object} viewModel\r\n     * @param {object} bindingAttrs\r\n     * @param {boolean} forceRender\r\n     */\n\n    const dblclickBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n      const handlerName = cache.dataKey;\n      let paramList = cache.parameters;\n      let viewModelContext;\n      const APP = viewModel.APP || viewModel.$root.APP;\n\n      if (!handlerName || !forceRender && !APP.$rootElement.contains(cache.el)) {\n        return;\n      }\n\n      const handlerFn = getViewModelValue(viewModel, handlerName);\n\n      if (typeof handlerFn === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n\n        function dbclickHandler(e) {\n          const args = [e, e.currentTarget].concat(paramList);\n          handlerFn.apply(viewModelContext, args);\n        }\n\n        cache.el.removeEventListener('dblclick', dbclickHandler, false);\n        cache.el.addEventListener('dblclick', dbclickHandler, false);\n      }\n    };\n\n    /* eslint-disable no-invalid-this */\n    /**\r\n     * blurBinding\r\n     * DOM decleartive on blur event binding\r\n     * event handler bind to viewModel method according to the DOM attribute\r\n     * @param {object} cache\r\n     * @param {object} viewModel\r\n     * @param {object} bindingAttrs\r\n     * @param {boolean} forceRender\r\n     */\n\n    const blurBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n      const handlerName = cache.dataKey;\n      let paramList = cache.parameters;\n      let viewModelContext;\n      const APP = viewModel.APP || viewModel.$root.APP;\n\n      if (!handlerName || !forceRender && !APP.$rootElement.contains(cache.el)) {\n        return;\n      }\n\n      const handlerFn = getViewModelValue(viewModel, handlerName);\n\n      if (typeof handlerFn === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n\n        function blurHandler(e) {\n          const args = [e, e.currentTarget].concat(paramList);\n          handlerFn.apply(viewModelContext, args);\n        }\n\n        cache.el.removeEventListener('blur', blurHandler, false);\n        cache.el.addEventListener('blur', blurHandler, false);\n      }\n    };\n\n    /* eslint-disable no-invalid-this */\n    /**\r\n     * focusBinding\r\n     * DOM decleartive on focus event binding\r\n     * event handler bind to viewModel method according to the DOM attribute\r\n     * @param {object} cache\r\n     * @param {object} viewModel\r\n     * @param {object} bindingAttrs\r\n     * @param {boolean} forceRender\r\n     */\n\n    const focusBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n      const handlerName = cache.dataKey;\n      let paramList = cache.parameters;\n      let viewModelContext;\n      const APP = viewModel.APP || viewModel.$root.APP;\n\n      if (!handlerName || !forceRender && !APP.$rootElement.contains(cache.el)) {\n        return;\n      }\n\n      const handlerFn = getViewModelValue(viewModel, handlerName);\n\n      if (typeof handlerFn === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n\n        function focusHandler(e) {\n          const args = [e, e.currentTarget].concat(paramList);\n          handlerFn.apply(viewModelContext, args);\n        }\n\n        cache.el.removeEventListener('focus', focusHandler, false);\n        cache.el.addEventListener('focus', focusHandler, false);\n      }\n    };\n\n    /* eslint-disable no-invalid-this */\n    /**\r\n     * blurBinding\r\n     * DOM decleartive on blur event binding\r\n     * event handler bind to viewModel method according to the DOM attribute\r\n     * @param {object} cache\r\n     * @param {object} viewModel\r\n     * @param {object} bindingAttrs\r\n     * @param {boolean} forceRender\r\n     */\n\n    const hoverBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n      const handlerName = cache.dataKey;\n      let paramList = cache.parameters;\n      const inHandlerName = bindingDataReference.mouseEnterHandlerName;\n      const outHandlerName = bindingDataReference.mouseLeaveHandlerName;\n      let viewModelContext;\n      const APP = viewModel.APP || viewModel.$root.APP;\n      cache.elementData = cache.elementData || {}; // TODO: check what is APP.$rootElement.contains(cache.el)\n\n      if (!handlerName || !forceRender && !APP.$rootElement.contains(cache.el)) {\n        return;\n      }\n\n      const handlers = getViewModelValue(viewModel, handlerName);\n\n      if (handlers && typeof handlers[inHandlerName] === 'function' && typeof handlers[outHandlerName] === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n\n        function onMouseEnterHandler(e) {\n          const args = [e, cache.el].concat(paramList);\n          handlers[inHandlerName].apply(viewModelContext, args);\n        }\n\n        function onMouseLeaveHandler(e) {\n          const args = [e, cache.el].concat(paramList);\n          handlers[outHandlerName].apply(viewModelContext, args);\n        }\n\n        cache.el.removeEventListener('mouseenter', onMouseEnterHandler, false);\n        cache.el.removeEventListener('mouseleave', onMouseLeaveHandler, false);\n        cache.el.addEventListener('mouseenter', onMouseEnterHandler, false);\n        cache.el.addEventListener('mouseleave', onMouseLeaveHandler, false);\n      }\n    };\n\n    /* eslint-disable no-invalid-this */\n    /**\r\n     * changeBinding\r\n     * @description input element on change event binding. DOM -> viewModel update\r\n     * @param {object} cache\r\n     * @param {object} viewModel\r\n     * @param {object} bindingAttrs\r\n     * @param {boolean} forceRender\r\n     */\n\n    const changeBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n      const handlerName = cache.dataKey;\n      let paramList = cache.parameters;\n      const modelDataKey = cache.el.getAttribute(bindingAttrs.model);\n      let newValue = '';\n      let oldValue = '';\n      let viewModelContext;\n      const APP = viewModel.APP || viewModel.$root.APP;\n\n      if (!handlerName || !forceRender && !APP.$rootElement.contains(cache.el)) {\n        return;\n      }\n\n      const handlerFn = getViewModelValue(viewModel, handlerName);\n\n      if (typeof handlerFn === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n\n        function changeHandler(e) {\n          const $this = this;\n          const isCheckbox = $this.type === 'checkbox';\n          newValue = isCheckbox ? $this.checked : _.escape($this.value); // set data to viewModel\n\n          if (modelDataKey) {\n            oldValue = getViewModelValue(viewModel, modelDataKey);\n            setViewModelValue(viewModel, modelDataKey, newValue);\n          }\n\n          const args = [e, e.currentTarget, newValue, oldValue].concat(paramList);\n          handlerFn.apply(viewModelContext, args);\n          oldValue = newValue;\n        } // assing on change event\n\n\n        cache.el.removeEventListener('change', changeHandler, false);\n        cache.el.addEventListener('change', changeHandler, false);\n      }\n    };\n\n    /**\r\n     * modelBinding\r\n     * @description input element data binding. viewModel -> DOM update\r\n     * @param {object} cache\r\n     * @param {object} viewModel\r\n     * @param {object} bindingAttrs\r\n     * @param {boolean} forceRender\r\n     */\n\n    const modelBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n      const dataKey = cache.dataKey;\n      let newValue = '';\n      const APP = viewModel.APP || viewModel.$root.APP;\n\n      if (!dataKey || !forceRender && !APP.$rootElement.contains(cache.el)) {\n        return;\n      }\n\n      newValue = getViewModelValue(viewModel, dataKey);\n\n      if (typeof newValue !== 'undefined' && newValue !== null) {\n        const $element = cache.el;\n        const isCheckbox = $element.type === 'checkbox';\n        const isRadio = $element.type === 'radio';\n        const inputName = $element.name;\n        const $radioGroup = isRadio ? APP.$rootElement.querySelectorAll(`input[name=\"${inputName}\"]`) : [];\n        const oldValue = isCheckbox ? $element.checked : $element.value; // update element value\n\n        if (newValue !== oldValue) {\n          if (isCheckbox) {\n            $element.checked = Boolean(newValue);\n          } else if (isRadio) {\n            let i = 0;\n            const radioGroupLength = $radioGroup.length;\n\n            for (i = 0; i < radioGroupLength; i += 1) {\n              if ($radioGroup[i].value === newValue) {\n                $radioGroup[i].checked = true;\n                break;\n              }\n            }\n          } else {\n            $element.value = newValue;\n          }\n        }\n      }\n    };\n\n    /**\r\n     * submitBinding\r\n     * @description on form submit binding. pass current form data as json object to handler\r\n     * @param {object} cache\r\n     * @param {object} viewModel\r\n     * @param {object} bindingAttrs\r\n     * @param {boolean} forceRender\r\n     */\n\n    const submitBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n      const handlerName = cache.dataKey;\n      let paramList = cache.parameters;\n      let viewModelContext;\n      const APP = viewModel.APP || viewModel.$root.APP;\n\n      if (!handlerName || !forceRender && !APP.$rootElement.contains(cache.el)) {\n        return;\n      }\n\n      const handlerFn = getViewModelValue(viewModel, handlerName);\n      const $element = cache.el;\n\n      if (typeof handlerFn === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n\n        function submitHandler(e) {\n          const args = [e, $element, getFormData($element)].concat(paramList);\n          handlerFn.apply(viewModelContext, args);\n        } // assing on change event\n\n\n        cache.el.removeEventListener('submit', submitHandler, false);\n        cache.el.addEventListener('submit', submitHandler, false);\n      }\n    };\n\n    /**\r\n     * textBinding\r\n     * * @description\r\n     * DOM decleartive text binding update dom textnode with viewModel data\r\n     * @param {object} cache\r\n     * @param {object} viewModel\r\n     * @param {object} bindingAttrs\r\n     * @param {boolean} forceRender\r\n     */\n\n    const textBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n      const dataKey = cache.dataKey;\n      const APP = viewModel.APP || viewModel.$root.APP; // NOTE: this doesn't work for for-of, if and switch bindings because element was not in DOM\n\n      if (!dataKey || !forceRender && !APP.$rootElement.contains(cache.el)) {\n        return;\n      }\n\n      const newValue = getViewModelPropValue(viewModel, cache);\n      const oldValue = cache.el.textContent;\n\n      if (typeof newValue !== 'undefined' && typeof newValue !== 'object' && newValue !== null) {\n        if (newValue !== oldValue) {\n          cache.el.textContent = newValue;\n        }\n      }\n    };\n\n    /**\r\n     * showBinding\r\n     * @description\r\n     * DOM decleartive show binding. Make binding show/hide according to viewModel data (boolean)\r\n     * viewModel data can function but must return boolean\r\n     * @param {object} cache\r\n     * @param {object} viewModel\r\n     * @param {object} bindingAttrs\r\n     */\n\n    const showBinding = (cache, viewModel, bindingAttrs) => {\n      const dataKey = cache.dataKey;\n      let currentInlineSytle = {};\n      let currentInlineDisplaySytle = '';\n      let shouldShow = true;\n\n      if (!dataKey) {\n        return;\n      }\n\n      cache.elementData = cache.elementData || {};\n      const oldShowStatus = cache.elementData.viewModelPropValue; // store current element display default style once only\n\n      if (typeof cache.elementData.displayStyle === 'undefined' || typeof cache.elementData.computedStyle === 'undefined') {\n        currentInlineSytle = cache.el.style;\n        currentInlineDisplaySytle = currentInlineSytle.display; // use current inline style if defined\n\n        if (currentInlineDisplaySytle) {\n          // set to 'block' if is 'none'\n          cache.elementData.displayStyle = currentInlineDisplaySytle === 'none' ? 'block' : currentInlineDisplaySytle;\n          cache.elementData.computedStyle = null;\n        } else {\n          const computeStyle = window.getComputedStyle(cache.el, null).getPropertyValue('display');\n          cache.elementData.displayStyle = null;\n          cache.elementData.computedStyle = computeStyle;\n        }\n      }\n\n      shouldShow = getViewModelPropValue(viewModel, cache); // treat undefined || null as false.\n      // eg if property doesn't exsits in viewModel, it will treat as false to hide element\n\n      shouldShow = Boolean(shouldShow); // reject if nothing changed\n\n      if (oldShowStatus === shouldShow) {\n        return;\n      }\n\n      if (!shouldShow) {\n        if (cache.el.style.display !== 'none') {\n          cache.el.style.setProperty('display', 'none');\n        }\n      } else {\n        if (cache.elementData.computedStyle || cache.el.style.display === 'none') {\n          if (cache.elementData.computedStyle === 'none') {\n            // default display is none in css rule, so use display 'block'\n            cache.el.style.setProperty('display', 'block');\n          } else {\n            // has default displayable type so just remove inline display 'none'\n            if (currentInlineSytle.length > 1) {\n              cache.el.style.removeProperty('display');\n            } else {\n              cache.el.removeAttribute('style');\n            }\n          }\n        } else {\n          // element default display was inline style, so restore it\n          cache.el.style.setProperty('display', cache.elementData.displayStyle);\n        }\n      } // store new show status\n\n\n      cache.elementData.viewModelPropValue = shouldShow;\n    };\n\n    /**\r\n     * cssBinding\r\n     * @description\r\n     * DOM decleartive css binding. update classlist.\r\n     * viewModel data can function but must return JSOL.\r\n     * added css class if value is true\r\n     * @param {object} cache\r\n     * @param {object} viewModel\r\n     * @param {object} bindingAttrs\r\n     * @param {boolean} forceRender\r\n     */\n\n    const cssBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n      const dataKey = cache.dataKey;\n      const APP = viewModel.APP || viewModel.$root.APP;\n\n      if (!dataKey || !forceRender && !APP.$rootElement.contains(cache.el)) {\n        return;\n      }\n\n      cache.elementData = cache.elementData || {};\n      cache.elementData.viewModelPropValue = cache.elementData.viewModelPropValue || '';\n      const oldCssList = cache.elementData.viewModelPropValue;\n      let newCssList = '';\n      const vmCssListObj = getViewModelPropValue(viewModel, cache);\n      let vmCssListArray = [];\n      let isViewDataObject = false;\n      let isViewDataString = false;\n      let cssList = [];\n\n      if (typeof vmCssListObj === 'string') {\n        isViewDataString = true;\n      } else if (isPlainObject(vmCssListObj)) {\n        isViewDataObject = true;\n      } else {\n        // reject if vmCssListObj is not an object or string\n        return;\n      }\n\n      if (isViewDataObject) {\n        newCssList = JSON.stringify(vmCssListObj);\n      } else {\n        newCssList = vmCssListObj.replace(/\\s\\s+/g, ' ').trim();\n        vmCssListArray = newCssList.split(' ');\n      } // reject if nothing changed\n\n\n      if (oldCssList === newCssList) {\n        return;\n      } // get current css classes from element\n\n\n      const domCssList = cache.el.classList; // clone domCssList as new array\n\n      const domCssListLength = domCssList.length;\n\n      for (let i = 0; i < domCssListLength; i += 1) {\n        cssList.push(domCssList[i]);\n      }\n\n      if (isViewDataObject) {\n        each(vmCssListObj, function (k, v) {\n          const i = cssList.indexOf(k);\n\n          if (v === true) {\n            cssList.push(k);\n          } else if (i !== -1) {\n            cssList.splice(i, 1);\n          }\n        });\n      } else if (isViewDataString) {\n        // remove oldCssList items from cssList\n        cssList = arrayRemoveMatch(cssList, oldCssList);\n        cssList = cssList.concat(vmCssListArray);\n      } // unique cssList array\n\n\n      cssList = cssList.filter((v, i, a) => {\n        return a.indexOf(v) === i;\n      });\n      cssList = cssList.join(' '); // update element data\n\n      cache.elementData.viewModelPropValue = newCssList; // replace all css classes\n\n      cache.el.setAttribute('class', cssList);\n    };\n\n    /**\r\n     * attrBinding\r\n     * @description\r\n     * DOM decleartive attr binding. update elenment attributes\r\n     * @param {object} cache\r\n     * @param {object} viewModel\r\n     * @param {object} bindingAttrs\r\n     */\n\n    const attrBinding = (cache, viewModel, bindingAttrs) => {\n      const dataKey = cache.dataKey;\n\n      if (!dataKey) {\n        return;\n      }\n\n      cache.elementData = cache.elementData || {};\n      cache.elementData.viewModelProValue = cache.elementData.viewModelProValue || {};\n      const oldAttrObj = cache.elementData.viewModelProValue;\n      const vmAttrObj = getViewModelPropValue(viewModel, cache);\n\n      if (!isPlainObject(vmAttrObj)) {\n        return;\n      } // reject if nothing changed\n\n\n      if (JSON.stringify(oldAttrObj) === JSON.stringify(vmAttrObj)) {\n        return;\n      } // reset old data and update it\n\n\n      cache.elementData.viewModelProValue = {};\n\n      if (isEmptyObject(oldAttrObj)) {\n        each(vmAttrObj, (key, value) => {\n          cache.el.setAttribute(key, value); // populate with vmAttrObj data\n\n          cache.elementData.viewModelProValue[key] = value;\n        });\n      } else {\n        each(oldAttrObj, (key, value) => {\n          if (typeof vmAttrObj[key] === 'undefined') {\n            // remove attribute if not present in current vm\n            cache.el.removeAttribute(key);\n          }\n        });\n        each(vmAttrObj, (key, value) => {\n          if (oldAttrObj[key] !== vmAttrObj[key]) {\n            // update attribute if value changed\n            cache.el.setAttribute(key, vmAttrObj[key]);\n          } // populate with vmAttrObj data\n\n\n          cache.elementData.viewModelProValue[key] = value;\n        });\n      }\n    };\n\n    let bindingAttrsMap;\n    /**\r\n     * walkDOM\r\n     * @description by Douglas Crockford - walk each DOM node and calls provided callback function\r\n     * start walk from firstChild\r\n     * @param {object} node\r\n     * @param {function} func\r\n     */\n\n    const walkDOM = (node, func) => {\n      let parseChildNode = true;\n      node = node.firstElementChild;\n\n      while (node) {\n        parseChildNode = func(node);\n\n        if (parseChildNode) {\n          walkDOM(node, func);\n        }\n\n        node = node.nextElementSibling;\n      }\n    };\n\n    const getAttributesObject = node => {\n      const ret = {};\n      Array.prototype.slice.call(node.attributes).forEach(item => {\n        ret[item.name] = item.value;\n      });\n      return ret;\n    };\n\n    const checkSkipChildParseBindings = (attrObj = {}, bindingAttrs) => {\n      return [bindingAttrs.forOf, bindingAttrs.if, bindingAttrs.case, bindingAttrs.default].filter(type => {\n        return typeof attrObj[type] !== 'undefined';\n      });\n    };\n\n    const rootSkipCheck = node => {\n      return node.tagName === 'SVG';\n    };\n\n    const defaultSkipCheck = (node, bindingAttrs) => {\n      return node.tagName === 'SVG' || node.hasAttribute(bindingAttrs.comp);\n    };\n\n    const populateBindingCache = ({\n      node,\n      attrObj,\n      bindingCache,\n      type\n    }) => {\n      let attrValue;\n      let cacheData;\n\n      if (bindingAttrsMap && bindingAttrsMap[type] && typeof attrObj[type] !== 'undefined') {\n        bindingCache[type] = bindingCache[type] || [];\n        attrValue = attrObj[type].trim();\n        cacheData = {\n          el: node,\n          dataKey: attrValue\n        }; // populate cacheData.filters. update filterList first item as dataKey\n\n        cacheData = extractFilterList(cacheData); // populate cacheData.parameters\n        // for store function call parameters eg. '$index', '$root'\n        // useful with DOM for-loop template as reference to binding data\n\n        const paramList = getFunctionParameterList(cacheData.dataKey);\n\n        if (paramList) {\n          cacheData.parameters = paramList;\n          cacheData.dataKey = cacheData.dataKey.replace(REGEX.FUNCTIONPARAM, '').trim();\n        } // store parent array reference to cacheData\n\n\n        cacheData[constants.PARENT_REF] = bindingCache[type];\n        bindingCache[type].push(cacheData);\n      }\n\n      return bindingCache;\n    };\n\n    const createBindingCache = ({\n      rootNode = null,\n      bindingAttrs = {},\n      skipCheck,\n      isRenderedTemplate = false\n    }) => {\n      let bindingCache = {};\n\n      if (!rootNode instanceof window.Node) {\n        throw new TypeError('walkDOM: Expected a DOM node');\n      }\n\n      bindingAttrsMap = bindingAttrsMap || invertObj(bindingAttrs);\n\n      const parseNode = (node, skipNodeCheckFn = defaultSkipCheck) => {\n        let isSkipForOfChild = false;\n\n        if (node.nodeType !== 1 || !node.hasAttributes()) {\n          return true;\n        }\n\n        if (skipNodeCheckFn(node, bindingAttrs) || typeof skipCheck === 'function' && skipCheck(node)) {\n          return false;\n        } // when creating sub bindingCache if is for tmp binding\n        // skip same element that has forOf binding the  forOf is alredy parsed\n\n\n        const attrObj = getAttributesObject(node);\n        const hasSkipChildParseBindings = checkSkipChildParseBindings(attrObj, bindingAttrs);\n        let iterateList = [];\n\n        if (hasSkipChildParseBindings.length) {\n          isSkipForOfChild = true;\n          iterateList = hasSkipChildParseBindings;\n        } else if (isRenderedTemplate && attrObj[bindingAttrs.tmp]) {\n          // skip current node parse if was called by node has template binding and already rendered\n          return true;\n        } else {\n          iterateList = Object.keys(attrObj);\n        }\n\n        iterateList.forEach(key => {\n          // skip for switch case and default bining\n          if (key !== bindingAttrs.case && key !== bindingAttrs.default) {\n            bindingCache = populateBindingCache({\n              node: node,\n              attrObj: attrObj,\n              bindingCache: bindingCache,\n              type: key\n            });\n          }\n        }); // after cache forOf skip parse child nodes\n\n        if (isSkipForOfChild) {\n          return false;\n        }\n\n        return true;\n      };\n\n      if (parseNode(rootNode, rootSkipCheck)) {\n        walkDOM(rootNode, parseNode);\n      }\n\n      return bindingCache;\n    };\n\n    /* eslint-disable no-invalid-this */\n\n    const createClonedElementCache = bindingData => {\n      const clonedElement = bindingData.el.cloneNode(true);\n      bindingData.fragment = document.createDocumentFragment();\n      bindingData.fragment.appendChild(clonedElement);\n      return bindingData;\n    };\n\n    const setCommentPrefix = bindingData => {\n      if (!bindingData || !bindingData.type) {\n        return;\n      }\n\n      let commentPrefix$1 = '';\n      const dataKeyMarker = bindingData.dataKey ? bindingData.dataKey.replace(REGEX.WHITESPACES, '_') : '';\n\n      switch (bindingData.type) {\n        case bindingAttrs.forOf:\n          commentPrefix$1 = commentPrefix.forOf;\n          break;\n\n        case bindingAttrs.if:\n          commentPrefix$1 = commentPrefix.if;\n          break;\n\n        case bindingAttrs.case:\n          commentPrefix$1 = commentPrefix.case;\n          break;\n\n        case bindingAttrs.default:\n          commentPrefix$1 = commentPrefix.default;\n          break;\n      }\n\n      bindingData.commentPrefix = commentPrefix$1 + dataKeyMarker;\n      return bindingData;\n    };\n    /**\r\n     * setDocRangeEndAfter\r\n     * @param {object} node\r\n     * @param {object} bindingData\r\n     * @description\r\n     * recursive execution to find last wrapping comment node\r\n     * and set as bindingData.docRange.setEndAfter\r\n     * if not found deleteContents will has no operation\r\n     * @return {undefined}\r\n     */\n\n\n    const setDocRangeEndAfter = (node, bindingData) => {\n      if (!bindingData.commentPrefix) {\n        setCommentPrefix(bindingData);\n      }\n\n      const startTextContent = bindingData.commentPrefix;\n      const endTextContent = startTextContent + commentSuffix;\n      node = node.nextSibling; // check last wrap comment node\n\n      if (node) {\n        if (node.nodeType === 8 && node.textContent === endTextContent) {\n          return bindingData.docRange.setEndBefore(node);\n        }\n\n        setDocRangeEndAfter(node, bindingData);\n      }\n    };\n    /**\r\n     * wrapCommentAround\r\n     * @param {object} bindingData\r\n     * @param {Node} node\r\n     * @return {object} DOM fragment\r\n     * @description\r\n     * wrap frament with comment node\r\n     */\n\n\n    const wrapCommentAround = (bindingData, node) => {\n      let prefix = '';\n\n      if (!bindingData.commentPrefix) {\n        setCommentPrefix(bindingData);\n      }\n\n      prefix = bindingData.commentPrefix;\n      const commentBegin = document.createComment(prefix);\n      const commentEnd = document.createComment(prefix + commentSuffix); // document fragment - logic for ForOf binding\n      // check node.parentNode because node could be from cache and no longer in DOM\n\n      if (node.nodeType === 11) {\n        node.insertBefore(commentBegin, node.firstChild);\n        node.appendChild(commentEnd);\n      } else if (node.parentNode) {\n        node.parentNode.insertBefore(commentBegin, node);\n        insertAfter(node.parentNode, commentEnd, node); // update bindingData details\n\n        bindingData.previousNonTemplateElement = node.previousSibling;\n        bindingData.nextNonTemplateElement = node.nextSibling;\n        bindingData.parentElement = node.previousSibling.parentElement;\n      }\n\n      return node;\n    };\n    /**\r\n     * removeElemnetsByCommentWrap\r\n     * @param {object} bindingData\r\n     * @return {undefined}\r\n     * @description remove elments by range\r\n     */\n\n\n    const removeElemnetsByCommentWrap = bindingData => {\n      if (!bindingData.docRange) {\n        bindingData.docRange = document.createRange();\n      }\n\n      try {\n        if (bindingData.previousNonTemplateElement) {\n          // update docRange start and end match the wrapped comment node\n          bindingData.docRange.setStartBefore(bindingData.previousNonTemplateElement.nextSibling);\n          setDocRangeEndAfter(bindingData.previousNonTemplateElement.nextSibling, bindingData);\n        } else {\n          // insert before next non template element\n          bindingData.docRange.setStartBefore(bindingData.parentElement.firstChild);\n          setDocRangeEndAfter(bindingData.parentElement.firstChild, bindingData);\n        }\n      } catch (err) {\n        console.log('error removeElemnetsByCommentWrap: ', err.message);\n      }\n\n      return bindingData.docRange.deleteContents();\n    };\n\n    const insertRenderedElements = (bindingData, fragment) => {\n      // insert rendered fragment after the previousNonTemplateElement\n      if (bindingData.previousNonTemplateElement) {\n        insertAfter(bindingData.parentElement, fragment, bindingData.previousNonTemplateElement);\n      } else {\n        // insert before next non template element\n        if (bindingData.nextNonTemplateElement) {\n          bindingData.parentElement.insertBefore(fragment, bindingData.nextNonTemplateElement);\n        } else if (bindingData.parentElement) {\n          // insert from parent\n          bindingData.parentElement.appendChild(fragment);\n        }\n      }\n    };\n\n    /* eslint-disable no-invalid-this */\n\n    const renderForOfBinding = ({\n      bindingData,\n      viewModel,\n      bindingAttrs: bindingAttrs$1\n    }) => {\n      if (!bindingData || !viewModel || !bindingAttrs$1) {\n        return;\n      }\n\n      let keys;\n      let iterationDataLength;\n      const iterationData = getViewModelPropValue(viewModel, bindingData.iterator);\n      let isRegenerate = false; // check iterationData and set iterationDataLength\n\n      if (isArray(iterationData)) {\n        iterationDataLength = iterationData.length;\n      } else if (isPlainObject(iterationData)) {\n        keys = Object.keys(iterationData);\n        iterationDataLength = keys.length;\n      } else {\n        // throw error but let script contince to run\n        return throwErrorMessage(null, 'iterationData is not an plain object or array');\n      } // flag as pared for-of logic with bindingData.type\n\n\n      if (!bindingData.type) {\n        bindingData.type = bindingAttrs.forOf;\n        wrapCommentAround(bindingData, bindingData.el);\n      } // assign forOf internal id to bindingData once\n\n\n      if (typeof bindingData.iterationSize === 'undefined') {\n        // store iterationDataLength\n        bindingData.iterationSize = iterationDataLength; // remove orignal node for-of attributes\n\n        bindingData.el.removeAttribute(bindingAttrs$1.forOf);\n        isRegenerate = true;\n      } else {\n        // only regenerate cache if iterationDataLength changed\n        isRegenerate = bindingData.iterationSize !== iterationDataLength; // update iterationSize\n\n        bindingData.iterationSize = iterationDataLength;\n      }\n\n      if (!isRegenerate) {\n        bindingData.iterationBindingCache.forEach(function (elementCache, i) {\n          if (!isEmptyObject(elementCache)) {\n            const iterationVm = createIterationViewModel({\n              bindingData: bindingData,\n              viewModel: viewModel,\n              iterationData: iterationData,\n              keys: keys,\n              index: i\n            });\n            renderIteration({\n              elementCache: elementCache,\n              iterationVm: iterationVm,\n              bindingAttrs: bindingAttrs$1,\n              isRegenerate: false\n            });\n          }\n        });\n        return;\n      } // generate forOfBinding elements into fragment\n\n\n      const fragment = generateForOfElements(bindingData, viewModel, bindingAttrs$1, iterationData, keys);\n      removeElemnetsByCommentWrap(bindingData); // insert fragment content into DOM\n\n      return insertRenderedElements(bindingData, fragment);\n    };\n\n    const createIterationViewModel = ({\n      bindingData,\n      viewModel,\n      iterationData,\n      keys,\n      index\n    }) => {\n      const iterationVm = {};\n      iterationVm[bindingData.iterator.alias] = keys ? iterationData[keys[index]] : iterationData[index]; // populate common binding data reference\n\n      iterationVm[bindingDataReference.rootDataKey] = viewModel.$root || viewModel;\n      iterationVm[bindingDataReference.currentData] = iterationVm[bindingData.iterator.alias];\n      iterationVm[bindingDataReference.currentIndex] = index;\n      return iterationVm;\n    };\n\n    const generateForOfElements = (bindingData, viewModel, bindingAttrs, iterationData, keys) => {\n      const fragment = document.createDocumentFragment();\n      const iterationDataLength = bindingData.iterationSize;\n      let clonedItem;\n      let iterationVm;\n      let iterationBindingCache;\n      let i = 0; // create or clear exisitng iterationBindingCache\n\n      if (isArray(bindingData.iterationBindingCache)) {\n        bindingData.iterationBindingCache.length = 0;\n      } else {\n        bindingData.iterationBindingCache = [];\n      } // generate forOf and append to DOM\n\n\n      for (i = 0; i < iterationDataLength; i += 1) {\n        clonedItem = cloneDomNode(bindingData.el); // create bindingCache per iteration\n\n        iterationBindingCache = createBindingCache({\n          rootNode: clonedItem,\n          bindingAttrs: bindingAttrs\n        });\n        bindingData.iterationBindingCache.push(iterationBindingCache);\n\n        if (!isEmptyObject(iterationBindingCache)) {\n          // create an iterationVm match iterator alias\n          iterationVm = createIterationViewModel({\n            bindingData: bindingData,\n            viewModel: viewModel,\n            iterationData: iterationData,\n            keys: keys,\n            index: i\n          });\n          renderIteration({\n            elementCache: bindingData.iterationBindingCache[i],\n            iterationVm: iterationVm,\n            bindingAttrs: bindingAttrs,\n            isRegenerate: true\n          });\n        }\n\n        fragment.appendChild(clonedItem);\n      }\n\n      return fragment;\n    };\n\n    /**\r\n     * forOfBinding\r\n     * @description\r\n     * DOM decleartive for binding.\r\n     * @param {object} cache\r\n     * @param {object} viewModel\r\n     * @param {object} bindingAttrs\r\n     */\n\n    const forOfBinding = (cache, viewModel, bindingAttrs) => {\n      const dataKey = cache.dataKey;\n\n      if (!dataKey || dataKey.length > maxDatakeyLength) {\n        return;\n      }\n\n      if (!cache.iterator) {\n        if (dataKey.length > maxDatakeyLength) {\n          return;\n        } // replace mess spaces with single space\n\n\n        cache.dataKey = cache.dataKey.replace(REGEX.WHITESPACES, ' ');\n        const forExpMatch = dataKey.match(REGEX.FOROF);\n\n        if (!forExpMatch) {\n          return;\n        }\n\n        cache.iterator = {};\n        cache.iterator.alias = forExpMatch[1].trim();\n\n        if (forExpMatch[2]) {\n          cache.iterator.dataKey = forExpMatch[2].trim();\n          cache.parentElement = cache.el.parentElement;\n          cache.previousNonTemplateElement = cache.el.previousSibling;\n          cache.nextNonTemplateElement = cache.el.nextSibling;\n        }\n      }\n\n      renderForOfBinding({\n        bindingData: cache,\n        viewModel: viewModel,\n        bindingAttrs: bindingAttrs\n      });\n    };\n\n    /**\r\n     * isTargetDomRemoved\r\n     * @description check if DOM between 'start' and 'end' comment tag has been removed\r\n     * @param {object} bindingData\r\n     * @return {boolean}\r\n     */\n\n    const isTargetDomRemoved = bindingData => {\n      let ret = false;\n\n      if (bindingData && bindingData.previousNonTemplateElement) {\n        const commentStartTextContent = bindingData.previousNonTemplateElement.textContent;\n        const endCommentTag = bindingData.previousNonTemplateElement.nextSibling;\n\n        if (endCommentTag.nodeType === 8) {\n          if (endCommentTag.textContent === commentStartTextContent + commentSuffix) {\n            ret = true;\n          }\n        }\n      }\n\n      return ret;\n    };\n\n    const renderIfBinding = ({\n      bindingData,\n      viewModel,\n      bindingAttrs\n    }) => {\n      if (!bindingData.fragment) {\n        return;\n      }\n\n      const isDomRemoved = isTargetDomRemoved(bindingData);\n      let rootElement = bindingData.el; // remove current old DOM.\n      // TODO: try preserve DOM\n\n      if (!isDomRemoved && !bindingData.isOnce) {\n        removeIfBinding(bindingData); // use fragment for create iterationBindingCache\n\n        rootElement = bindingData.fragment.firstChild.cloneNode(true);\n      } // walk clonedElement to create iterationBindingCache once\n\n\n      if (!bindingData.iterationBindingCache || !bindingData.hasIterationBindingCache) {\n        bindingData.iterationBindingCache = createBindingCache({\n          rootNode: rootElement,\n          bindingAttrs: bindingAttrs\n        });\n      } // only render if has iterationBindingCache\n      // means has other dataBindings to be render\n\n\n      if (!isEmptyObject(bindingData.iterationBindingCache)) {\n        bindingData.hasIterationBindingCache = true;\n        renderIteration({\n          elementCache: bindingData.iterationBindingCache,\n          iterationVm: viewModel,\n          bindingAttrs: bindingAttrs,\n          isRegenerate: true\n        });\n      } // insert to new rendered DOM\n      // TODO: check unnecessary insertion when DOM is preserved\n\n\n      insertRenderedElements(bindingData, rootElement);\n    };\n\n    const removeIfBinding = bindingData => {\n      removeElemnetsByCommentWrap(bindingData); // remove cache.IterationBindingCache to prevent memory leak\n\n      if (bindingData.hasIterationBindingCache) {\n        delete bindingData.iterationBindingCache;\n        delete bindingData.hasIterationBindingCache;\n      }\n    };\n\n    /**\r\n     * if-Binding\r\n     * @description\r\n     * DOM decleartive for binding.\r\n     * @param {object} cache\r\n     * @param {object} viewModel\r\n     * @param {object} bindingAttrs\r\n     */\n\n    const ifBinding = (cache, viewModel, bindingAttrs$1) => {\n      const dataKey = cache.dataKey; // isOnce only return if there is no child bindings\n\n      if (!dataKey || cache.isOnce && cache.hasIterationBindingCache === false) {\n        return;\n      }\n\n      cache.elementData = cache.elementData || {};\n      cache.type = cache.type || bindingAttrs.if;\n      const oldViewModelProValue = cache.elementData.viewModelPropValue; // getViewModelPropValue could be return undefined or null\n\n      const viewModelPropValue = getViewModelPropValue(viewModel, cache) || false; // do nothing if viewModel value not changed and no child bindings\n\n      if (oldViewModelProValue === viewModelPropValue && !cache.hasIterationBindingCache) {\n        return;\n      }\n\n      const shouldRender = Boolean(viewModelPropValue); // remove this cache from parent array\n\n      if (!shouldRender && cache.isOnce && cache.el.parentNode) {\n        removeElement(cache.el); // delete cache.fragment;\n\n        removeBindingInQueue({\n          viewModel: viewModel,\n          cache: cache\n        });\n        return;\n      } // store new show status\n\n\n      cache.elementData.viewModelPropValue = viewModelPropValue; // only create fragment once\n      // wrap comment tag around\n      // remove if attribute from original element to allow later dataBind parsing\n\n      if (!cache.fragment) {\n        wrapCommentAround(cache, cache.el);\n        cache.el.removeAttribute(bindingAttrs$1.if);\n        createClonedElementCache(cache);\n      }\n\n      if (!shouldRender) {\n        // remove element\n        removeIfBinding(cache);\n      } else {\n        // render element\n        renderIfBinding({\n          bindingData: cache,\n          viewModel: viewModel,\n          bindingAttrs: bindingAttrs$1\n        }); // if render once\n        // remove this cache from parent array if no child caches\n\n        if (cache.isOnce && !cache.hasIterationBindingCache) {\n          // delete cache.fragment;\n          removeBindingInQueue({\n            viewModel: viewModel,\n            cache: cache\n          });\n        }\n      }\n    };\n\n    const removeBindingInQueue = ({\n      viewModel,\n      cache\n    }) => {\n      let ret = false;\n\n      if (viewModel.APP.postProcessQueue) {\n        viewModel.APP.postProcessQueue.push(((cache, index) => () => {\n          cache[constants.PARENT_REF].splice(index, 1);\n        })(cache, cache[constants.PARENT_REF].indexOf(cache)));\n        ret = true;\n      }\n\n      return ret;\n    };\n\n    /**\r\n     * switch-Binding\r\n     * @description\r\n     * DOM decleartive switch binding.\r\n     * switch parent element wrap direct child with case bindings\r\n     * @param {object} cache\r\n     * @param {object} viewModel\r\n     * @param {object} bindingAttrs\r\n     */\n\n    const switchBinding = (cache, viewModel, bindingAttrs) => {\n      const dataKey = cache.dataKey;\n\n      if (!dataKey) {\n        return;\n      }\n\n      cache.elementData = cache.elementData || {};\n      const newExpression = getViewModelPropValue(viewModel, cache);\n\n      if (newExpression === cache.elementData.viewModelPropValue) {\n        return;\n      }\n\n      cache.elementData.viewModelPropValue = newExpression; // build switch cases if not yet defined\n\n      if (!cache.cases) {\n        const childrenElements = cache.el.children;\n\n        if (!childrenElements.length) {\n          return;\n        }\n\n        cache.cases = [];\n\n        for (let i = 0, elementLength = childrenElements.length; i < elementLength; i += 1) {\n          let caseData = null;\n\n          if (childrenElements[i].hasAttribute(bindingAttrs.case)) {\n            caseData = createCaseData(childrenElements[i], bindingAttrs.case);\n          } else if (childrenElements[i].hasAttribute(bindingAttrs.default)) {\n            caseData = createCaseData(childrenElements[i], bindingAttrs.default);\n            caseData.isDefault = true;\n          } // create fragment by clone node\n          // wrap with comment tag\n\n\n          if (caseData) {\n            wrapCommentAround(caseData, caseData.el); // remove binding attribute for later dataBind parse\n\n            if (caseData.isDefault) {\n              caseData.el.removeAttribute(bindingAttrs.default);\n            } else {\n              caseData.el.removeAttribute(bindingAttrs.case);\n            }\n\n            createClonedElementCache(caseData);\n            cache.cases.push(caseData);\n          }\n        }\n      }\n\n      if (cache.cases.length) {\n        let hasMatch = false; // do switch operation - reuse if binding logic\n\n        for (let j = 0, casesLength = cache.cases.length; j < casesLength; j += 1) {\n          let newCaseValue;\n\n          if (cache.cases[j].dataKey) {\n            // set back to dataKey if nothing found in viewModel\n            newCaseValue = getViewModelPropValue(viewModel, cache.cases[j]) || cache.cases[j].dataKey;\n          }\n\n          if (newCaseValue === cache.elementData.viewModelPropValue || cache.cases[j].isDefault) {\n            hasMatch = true; // render element\n\n            renderIfBinding({\n              bindingData: cache.cases[j],\n              viewModel: viewModel,\n              bindingAttrs: bindingAttrs\n            }); // remove other elements\n\n            removeUnmatchCases(cache.cases, j);\n            break;\n          }\n        } // no match remove all cases\n\n\n        if (!hasMatch) {\n          removeUnmatchCases(cache.cases);\n        }\n      }\n    };\n\n    function removeUnmatchCases(cases, matchedIndex) {\n      cases.forEach((caseData, index) => {\n        if (index !== matchedIndex || typeof matchedIndex === 'undefined') {\n          removeIfBinding(caseData); // remove cache.IterationBindingCache to prevent memory leak\n\n          if (caseData.hasIterationBindingCache) {\n            caseData.iterationBindingCache = null;\n            caseData.hasIterationBindingCache = false;\n          }\n        }\n      });\n    }\n\n    function createCaseData(node, attrName) {\n      const caseData = {\n        el: node,\n        dataKey: node.getAttribute(attrName),\n        type: attrName\n      };\n      return caseData;\n    }\n\n    /**\r\n     *  pubSub\r\n     * @description use jQuery object as pubSub\r\n     * @example EVENTS object strucure:\r\n     *  EVENTS = {\r\n            'EVENT-NAME': [{ 'comp-id': fn }],\r\n            'EVENT-NAME2': [{ 'comp-id': fn }]\r\n        };\r\n     */\n\n    const EVENTS = {};\n\n    const subscribeEvent = (instance = null, eventName = '', fn, isOnce = false) => {\n      if (!instance || !instance.compId || !eventName || typeof fn !== 'function') {\n        return;\n      }\n\n      let subscriber;\n      let isSubscribed = false;\n      eventName = eventName.replace(REGEX.WHITESPACES, '');\n      EVENTS[eventName] = EVENTS[eventName] || []; // check if already subscribed and update callback fn\n\n      isSubscribed = EVENTS[eventName].some(subscriber => {\n        if (subscriber[instance.compId]) {\n          subscriber[instance.compId] = fn.bind(instance.viewModel);\n          subscriber.isOnce = isOnce;\n          return true;\n        }\n      }); // push if not yet subscribe\n\n      if (!isSubscribed) {\n        subscriber = {};\n        subscriber[instance.compId] = fn.bind(instance.viewModel);\n        subscriber.isOnce = isOnce;\n        EVENTS[eventName].push(subscriber);\n      }\n    };\n\n    const subscribeEventOnce = (instance = null, eventName = '', fn) => {\n      subscribeEvent(instance, eventName, fn, true);\n    };\n\n    const unsubscribeEvent = (compId = '', eventName = '') => {\n      if (!compId || !eventName) {\n        return;\n      }\n\n      let i = 0;\n      let subscribersLength = 0;\n      let subscriber;\n      eventName = eventName.replace(REGEX.WHITESPACES, '');\n\n      if (EVENTS[eventName]) {\n        subscribersLength = EVENTS[eventName].length;\n\n        for (i = 0; i < subscribersLength; i += 1) {\n          subscriber = EVENTS[eventName][i];\n\n          if (subscriber[compId]) {\n            EVENTS[eventName].splice(i, 1);\n            break;\n          }\n        }\n      } // delete the event if no more subscriber\n\n\n      if (!EVENTS[eventName].length) {\n        delete EVENTS[eventName];\n      }\n    };\n    /**\r\n     * unsubscribeAllEvent\r\n     * @description unsubscribe all event by compId. eg when a component removed\r\n     * @param {string} compId\r\n     */\n\n\n    const unsubscribeAllEvent = (compId = '') => {\n      if (!compId) {\n        return;\n      }\n\n      Object.keys(EVENTS).forEach(eventName => {\n        unsubscribeEvent(compId, eventName);\n      });\n    };\n\n    const publishEvent = (eventName = '', ...args) => {\n      if (!eventName || !EVENTS[eventName]) {\n        return;\n      }\n\n      eventName = eventName.replace(REGEX.WHITESPACES, '');\n      EVENTS[eventName].forEach(subscriber => {\n        Object.keys(subscriber).forEach(compId => {\n          if (typeof subscriber[compId] === 'function') {\n            const ret = subscriber[compId](...args);\n\n            if (subscriber.isOnce) {\n              unsubscribeEvent(compId, eventName);\n            }\n\n            return ret;\n          }\n        });\n      });\n    };\n\n    let compIdIndex = 0;\n\n    class Binder {\n      constructor($rootElement, viewModel, bindingAttrs) {\n        if (!$rootElement || $rootElement.nodeType !== 1 || viewModel === null || typeof viewModel !== 'object') {\n          throw new TypeError('$rootElement or viewModel is invalid');\n        }\n\n        this.initRendered = false;\n        this.compId = compIdIndex += 1;\n        this.$rootElement = $rootElement;\n        this.viewModel = viewModel;\n        this.bindingAttrs = bindingAttrs;\n        this.render = debounceRaf(this.render, this);\n        this.isServerRendered = this.$rootElement.getAttribute(serverRenderedAttr) !== null; // inject instance into viewModel\n\n        this.viewModel.APP = this;\n        this.viewModel.$root = this.viewModel;\n        this.parseView(); // for jquery user set viewModel referece to $rootElement for easy debug\n        // otherwise use Expando to attach viewModel to $rootElement\n\n        this.$rootElement[bindingDataReference.rootDataKey] = this.viewModel;\n        return this;\n      }\n      /**\r\n       * parseView\r\n       * @description\r\n       * @return {this}\r\n       * traver from $rootElement to find each data-bind-* element\r\n       * then apply data binding\r\n       */\n\n\n      parseView() {\n        this.elementCache = createBindingCache({\n          rootNode: this.$rootElement,\n          bindingAttrs: this.bindingAttrs\n        }); // updateElementCache if server rendered on init\n\n        if (this.isServerRendered && !this.initRendered) {\n          this.updateElementCache({\n            templateCache: true\n          });\n        }\n\n        return this;\n      }\n      /**\r\n       * updateElementCache\r\n       * @param {object} opt\r\n       * @description call createBindingCache to parse view and generate bindingCache\r\n       */\n\n\n      updateElementCache(opt = {}) {\n        const elementCache = opt.elementCache || this.elementCache;\n\n        if (opt.allCache) {\n          // walk dom from root element to regenerate elementCache\n          this.elementCache = createBindingCache({\n            rootNode: this.$rootElement,\n            bindingAttrs: this.bindingAttrs\n          });\n        } // walk from first rendered template node to create/update child bindingCache\n\n\n        if (opt.allCache || opt.templateCache) {\n          if (elementCache[this.bindingAttrs.tmp] && elementCache[this.bindingAttrs.tmp].length) {\n            elementCache[this.bindingAttrs.tmp].forEach(cache => {\n              // set skipCheck as skipForOfParseFn whenever an node has\n              // both template and forOf bindings\n              // then the template bindingCache should be an empty object\n              let skipForOfParseFn = null;\n\n              if (cache.el.hasAttribute(this.bindingAttrs.forOf)) {\n                skipForOfParseFn = () => {\n                  return true;\n                };\n              }\n\n              cache.bindingCache = createBindingCache({\n                rootNode: cache.el,\n                bindingAttrs: this.bindingAttrs,\n                skipCheck: skipForOfParseFn,\n                isRenderedTemplate: opt.isRenderedTemplates\n              });\n            });\n          }\n        }\n      }\n\n      render(opt = {}) {\n        let updateOption = {};\n\n        if (!this.initRendered) {\n          // only update eventsBinding if server rendered\n          if (this.isServerRendered) {\n            this.$rootElement.removeAttribute(serverRenderedAttr);\n            updateOption = createBindingOption(bindingUpdateConditions.serverRendered, opt);\n          } else {\n            updateOption = createBindingOption(bindingUpdateConditions.init, opt);\n          }\n        } else {\n          // when called again only update visualBinding options\n          updateOption = createBindingOption('', opt);\n        } // create postProcessQueue before start rendering\n\n\n        this.postProcessQueue = []; // render and apply binding to template(s)\n        // this is an share function therefore passing 'this' context\n\n        renderTemplatesBinding({\n          ctx: this,\n          elementCache: this.elementCache,\n          updateOption: updateOption,\n          bindingAttrs: this.bindingAttrs,\n          viewModel: this.viewModel\n        }); // apply bindings to rest of the DOM\n\n        Binder.applyBinding({\n          ctx: this,\n          elementCache: this.elementCache,\n          updateOption: updateOption,\n          bindingAttrs: this.bindingAttrs,\n          viewModel: this.viewModel\n        }); // trigger postProcess\n\n        Binder.postProcess(this.postProcessQueue); // clear postProcessQueue\n\n        this.postProcessQueue.length = 0;\n        delete this.postProcessQueue;\n        this.initRendered = true;\n      }\n\n      static applyBinding({\n        ctx,\n        elementCache,\n        updateOption,\n        bindingAttrs,\n        viewModel\n      }) {\n        if (!elementCache || !updateOption) {\n          return;\n        } // the follow binding should be in order for better efficiency\n        // apply forOf Binding\n\n\n        if (updateOption.forOfBinding && elementCache[bindingAttrs.forOf] && elementCache[bindingAttrs.forOf].length) {\n          elementCache[bindingAttrs.forOf].forEach(cache => {\n            forOfBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n          });\n        } // apply attr Binding\n\n\n        if (updateOption.attrBinding && elementCache[bindingAttrs.attr] && elementCache[bindingAttrs.attr].length) {\n          elementCache[bindingAttrs.attr].forEach(cache => {\n            attrBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n          });\n        } // apply if Binding\n\n\n        if (updateOption.ifBinding && elementCache[bindingAttrs.if] && elementCache[bindingAttrs.if].length) {\n          elementCache[bindingAttrs.if].forEach(cache => {\n            ifBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n          });\n        } // apply show Binding\n\n\n        if (updateOption.showBinding && elementCache[bindingAttrs.show] && elementCache[bindingAttrs.show].length) {\n          elementCache[bindingAttrs.show].forEach(cache => {\n            showBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n          });\n        } // apply switch Binding\n\n\n        if (updateOption.switchBinding && elementCache[bindingAttrs.switch] && elementCache[bindingAttrs.switch].length) {\n          elementCache[bindingAttrs.switch].forEach(cache => {\n            switchBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n          });\n        } // apply text binding\n\n\n        if (updateOption.textBinding && elementCache[bindingAttrs.text] && elementCache[bindingAttrs.text].length) {\n          elementCache[bindingAttrs.text].forEach(cache => {\n            textBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n          });\n        } // apply cssBinding\n\n\n        if (updateOption.cssBinding && elementCache[bindingAttrs.css] && elementCache[bindingAttrs.css].length) {\n          elementCache[bindingAttrs.css].forEach(cache => {\n            cssBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n          });\n        } // apply model binding\n\n\n        if (updateOption.modelBinding && elementCache[bindingAttrs.model] && elementCache[bindingAttrs.model].length) {\n          elementCache[bindingAttrs.model].forEach(cache => {\n            modelBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n          });\n        } // apply change binding\n\n\n        if (updateOption.changeBinding && elementCache[bindingAttrs.change] && elementCache[bindingAttrs.change].length) {\n          elementCache[bindingAttrs.change].forEach(cache => {\n            changeBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n          });\n        } // apply submit binding\n\n\n        if (updateOption.submitBinding && elementCache[bindingAttrs.submit] && elementCache[bindingAttrs.submit].length) {\n          elementCache[bindingAttrs.submit].forEach(cache => {\n            submitBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n          });\n        } // apply click binding\n\n\n        if (updateOption.clickBinding && elementCache[bindingAttrs.click] && elementCache[bindingAttrs.click].length) {\n          elementCache[bindingAttrs.click].forEach(cache => {\n            clickBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n          });\n        } // apply double click binding\n\n\n        if (updateOption.dblclickBinding && elementCache[bindingAttrs.dblclick] && elementCache[bindingAttrs.dblclick].length) {\n          elementCache[bindingAttrs.dblclick].forEach(cache => {\n            dblclickBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n          });\n        } // apply blur binding\n\n\n        if (updateOption.blurBinding && elementCache[bindingAttrs.blur] && elementCache[bindingAttrs.blur].length) {\n          elementCache[bindingAttrs.blur].forEach(cache => {\n            blurBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n          });\n        } // apply focus binding\n\n\n        if (updateOption.focusBinding && elementCache[bindingAttrs.focus] && elementCache[bindingAttrs.focus].length) {\n          elementCache[bindingAttrs.focus].forEach(cache => {\n            focusBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n          });\n        } // apply hover binding\n\n\n        if (updateOption.hoverBinding && elementCache[bindingAttrs.hover] && elementCache[bindingAttrs.hover].length) {\n          elementCache[bindingAttrs.hover].forEach(cache => {\n            hoverBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n          });\n        }\n      }\n\n      static postProcess(tasks) {\n        if (!tasks || !tasks.length) {\n          return;\n        }\n\n        each(tasks, (index, task) => {\n          if (typeof task === 'function') {\n            try {\n              task();\n            } catch (err) {\n              throwErrorMessage(err, 'Error postProcess: ' + String(task));\n            }\n          }\n        });\n      }\n\n      subscribe(eventName = '', fn) {\n        subscribeEvent(this, eventName, fn);\n        return this;\n      }\n\n      subscribeOnce(eventName = '', fn) {\n        subscribeEventOnce(this, eventName, fn);\n        return this;\n      }\n\n      unsubscribe(eventName = '') {\n        unsubscribeEvent(this.compId, eventName);\n        return this;\n      }\n\n      unsubscribeAll() {\n        unsubscribeAllEvent(this.compId);\n        return this;\n      }\n\n      publish(eventName = '', ...args) {\n        publishEvent(eventName, ...args);\n        return this;\n      }\n\n    }\n\n    const renderTemplatesBinding = ({\n      ctx,\n      elementCache,\n      updateOption,\n      bindingAttrs,\n      viewModel\n    }) => {\n      if (!elementCache || !bindingAttrs) {\n        return false;\n      } // render and apply binding to template(s) and forOf DOM\n\n\n      if (elementCache[bindingAttrs.tmp] && elementCache[bindingAttrs.tmp].length) {\n        // when re-render call with {templateBinding: true}\n        // template and nested templates\n        if (updateOption.templateBinding) {\n          // overwrite updateOption with 'init' bindingUpdateConditions\n          updateOption = createBindingOption(bindingUpdateConditions.init);\n          elementCache[bindingAttrs.tmp].forEach($element => {\n            renderTemplate($element, viewModel, bindingAttrs, elementCache);\n          }); // update cache after all template(s) rendered\n\n          ctx.updateElementCache({\n            templateCache: true,\n            elementCache: elementCache,\n            isRenderedTemplates: true\n          });\n        } // enforce render even element is not in DOM tree\n\n\n        updateOption.forceRender = true; // apply bindings to rendered templates element\n\n        elementCache[bindingAttrs.tmp].forEach(cache => {\n          Binder.applyBinding({\n            elementCache: cache.bindingCache,\n            updateOption: updateOption,\n            bindingAttrs: bindingAttrs,\n            viewModel: viewModel\n          });\n        });\n      }\n\n      return true;\n    };\n    /**\r\n     * createBindingOption\r\n     * @param {string} condition\r\n     * @param {object} opt\r\n     * @description\r\n     * generate binding update option object by condition\r\n     * @return {object} updateOption\r\n     */\n\n\n    const createBindingOption = (condition = '', opt = {}) => {\n      const visualBindingOptions = {\n        templateBinding: false,\n        textBinding: true,\n        cssBinding: true,\n        ifBinding: true,\n        showBinding: true,\n        modelBinding: true,\n        attrBinding: true,\n        forOfBinding: true,\n        switchBinding: true\n      };\n      const eventsBindingOptions = {\n        changeBinding: true,\n        clickBinding: true,\n        dblclickBinding: true,\n        blurBinding: true,\n        focusBinding: true,\n        hoverBinding: true,\n        submitBinding: true\n      }; // this is visualBindingOptions but everything false\n      // concrete declear for performance purpose\n\n      const serverRenderedOptions = {\n        templateBinding: false,\n        textBinding: false,\n        cssBinding: false,\n        ifBinding: false,\n        showBinding: false,\n        modelBinding: false,\n        attrBinding: false,\n        forOfBinding: false,\n        switchBinding: false\n      };\n      let updateOption = {};\n\n      switch (condition) {\n        case bindingUpdateConditions.serverRendered:\n          updateOption = extend({}, eventsBindingOptions, serverRenderedOptions, opt);\n          break;\n\n        case bindingUpdateConditions.init:\n          // flag templateBinding to true to render tempalte(s)\n          opt.templateBinding = true;\n          updateOption = extend({}, visualBindingOptions, eventsBindingOptions, opt);\n          break;\n\n        default:\n          // when called again only update visualBinding options\n          updateOption = extend({}, visualBindingOptions, opt);\n      }\n\n      return updateOption;\n    };\n    /**\r\n     * renderIteration\r\n     * @param {object} opt\r\n     * @description\r\n     * render element's binding by supplied elementCache\r\n     * This function is desidned for FoOf, If, switch bindings\r\n     */\n\n\n    const renderIteration = ({\n      elementCache,\n      iterationVm,\n      bindingAttrs,\n      isRegenerate\n    }) => {\n      const bindingUpdateOption = isRegenerate ? createBindingOption(bindingUpdateConditions.init) : createBindingOption(); // enforce render even element is not in DOM tree\n\n      bindingUpdateOption.forceRender = true; // render and apply binding to template(s)\n      // this is an share function therefore passing current APP 'this' context\n      // viewModel is a dynamic generated iterationVm\n\n      renderTemplatesBinding({\n        ctx: iterationVm.$root ? iterationVm.$root.APP : iterationVm.APP,\n        elementCache: elementCache,\n        updateOption: bindingUpdateOption,\n        bindingAttrs: bindingAttrs,\n        viewModel: iterationVm\n      });\n      Binder.applyBinding({\n        elementCache: elementCache,\n        updateOption: bindingUpdateOption,\n        bindingAttrs: bindingAttrs,\n        viewModel: iterationVm\n      });\n    };\n\n    let bindingAttrs$1 = bindingAttrs;\n    let templateSettings$1 = templateSettings;\n\n    const use = (settings = {}) => {\n      if (settings.bindingAttrs) {\n        bindingAttrs$1 = $.extend({}, settings.bindingAttrs);\n      }\n\n      if (settings.templateSettings) {\n        templateSettings$1 = $.extend({}, settings.templateSettings);\n      }\n    };\n\n    const init = ($rootElement, viewModel = null) => {\n      _.templateSettings = templateSettings$1;\n      return new Binder($rootElement, viewModel, bindingAttrs$1);\n    }; // expose to global\n\n\n    window.dataBind = {\n      use: use,\n      init: init,\n      version: '@version@'\n    };\n\n}());\n"]}