{"version":3,"sources":["dataBind.min.js"],"names":["finallyConstructor","callback","constructor","this","then","value","resolve","reason","reject","allSettled","arr","length","TypeError","args","Array","prototype","slice","call","remaining","res","i","val","e","status","setTimeoutFunc","setTimeout","isArray$1","x","Boolean","noop","Promise$1","fn","_state","_handled","_value","undefined","_deferreds","doResolve","handle","self","deferred","_immediateFn","cb","onFulfilled","onRejected","ret","promise","push","newValue","finale","thisArg","apply","arguments","_unhandledRejectionFn","len","Handler","done","ex","prom","all","race","setImmediate","err","console","warn","globalNS","window","global","Error","Promise","bindingAttrs$1","comp","tmp","text","click","dblclick","blur","focus","hover","change","submit","model","show","css","attr","forOf","if","switch","case","default","serverRenderedAttr","commentPrefix","commentSuffix","bindingDataReference","bindingUpdateConditions","constants","ONCE","_","hasIsArray","isArray","REGEX","IS_SUPPORT_TEMPLATE","document","createElement","WRAP_MAP","div","thead","col","tr","td","caption","colgroup","tbody","tfoot","th","obj","Object","toString","isJsObject","isPlainObject","ctor","prot","hasOwnProperty","isEmptyObject","getOwnPropertyNames","createHtmlFragment","htmlString","template","innerHTML","replace","removeBadTags","content","fragment","createDocumentFragment","queryContainer","firstTag","match","getFirstHtmlStringTag","wrap","createRange","createContextualFragment","insertAdjacentHTML","query","querySelector","firstChild","appendChild","getViewModelValue","viewModel","prop","get","getViewModelPropValue","bindingCache","dataKey","paramList","parameters","isInvertBoolean","charAt","substring","viewModelContext","resolveViewModelContext","oldViewModelProValue","elementData","viewModelProValue","resolveParamList","concat","el","filtersViewModelPropValue","filters","each","index","filter","filterFn","throwErrorMessage","createDeferredObj","dfObj","extend","isDeepMerge","target","sources","source","shift","isMergebleObject","keys","forEach","key","assign","keysLength","isArrayObj","item","insertAfter","parentNode","newNode","referenceNode","refNextElement","nextSibling","insertBefore","datakey","bindingDataContext","split","map","param","trim","emptyElement","node","removeChild","errorMessage","message","error","log","$domFragment","$templateRoot","nestTemplatesCount","templateCache","renderTemplate","cache","bindingAttrs","elementCache","settings","str","JSON","parse","parseStringToJson","viewData","data","isAppend","append","isPrepend","prepend","$currentElement","$element","$index","getAttribute","htmlFragment","id","templateData","templateString","templateElement","getElementById","variable","compileTemplate","childNodes","$nestedTemplates","querySelectorAll","nestedTemplatesLength","thisTemplateCache","afterTemplateRender","changeBinding","forceRender","handlerName","modelDataKey","oldValue","APP","$root","$rootElement","contains","handlerFn","changeHandler","$this","isCheckbox","type","checked","escape","set","currentTarget","removeEventListener","addEventListener","bindingAttrsMap","walkDOM","func","parseChildNode","firstElementChild","nextElementSibling","rootSkipCheck","tagName","defaultSkipCheck","hasAttribute","populateBindingCache","attrObj","attrValue","cacheData","filterList","isOnceIndex","v","isOnce","splice","extractFilterList","paramlist","getFunctionParameterList","createBindingCache","rootNode","skipCheck","isRenderedTemplate","Node","sourceObj","reduce","parseNode","skipNodeCheckFn","isSkipForOfChild","nodeType","hasAttributes","attributes","name","getAttributesObject","hasSkipChildParseBindings","checkSkipChildParseBindings","iterateList","createClonedElementCache","bindingData","clonedElement","cloneNode","setCommentPrefix","commentPrefix$1","dataKeyMarker","setDocRangeEndAfter","endTextContent","textContent","docRange","setEndBefore","wrapCommentAround","prefix","commentBegin","createComment","commentEnd","previousNonTemplateElement","previousSibling","nextNonTemplateElement","parentElement","removeElemnetsByCommentWrap","setStartBefore","deleteContents","insertRenderedElements","createIterationViewModel","iterationData","iterationVm","iterator","alias","generateForOfElements","iterationDataLength","iterationSize","clonedItem","iterationBindingCache","renderIteration","isRegenerate","forOfBinding","forExpMatch","removeAttribute","renderForOfBinding","renderIfBinding","isDomRemoved","commentStartTextContent","endCommentTag","isTargetDomRemoved","rootElement","removeIfBinding","hasIterationBindingCache","removeBindingInQueue","postProcessQueue","indexOf","removeUnmatchCases","cases","matchedIndex","caseData","createCaseData","attrName","EVENTS","subscribeEvent","instance","eventName","compId","subscriber","isSubscribed","some","bind","unsubscribeEvent","subscribersLength","compIdIndex","Binder","initRendered","render","ctx","rafId","from","cancelAnimationFrame","requestAnimationFrame","debounceRaf","isServerRendered","parseView","updateElementCache","opt","allCache","skipForOfParseFn","isRenderedTemplates","updateOption","createBindingOption","renderTemplatesBinding","applyBinding","postProcess","attrBinding","oldAttrObj","vmAttrObj","stringify","setAttribute","ifBinding","viewModelPropValue","shouldRender","showBinding","currentInlineSytle","currentInlineDisplaySytle","shouldShow","oldShowStatus","displayStyle","computedStyle","style","display","computeStyle","getComputedStyle","getPropertyValue","setProperty","removeProperty","switchBinding","newExpression","childrenElements","children","elementLength","isDefault","hasMatch","j","casesLength","newCaseValue","textBinding","cssBinding","oldCssList","newCssList","vmCssListObj","vmCssListArray","isViewDataObject","isViewDataString","cssList","domCssList","classList","domCssListLength","frommArray","k","a","join","modelBinding","isRadio","inputName","$radioGroup","radioGroupLength","submitBinding","createEventBinding","clickBinding","dblclickBinding","blurBinding","focusBinding","hoverBinding","inHandlerName","outHandlerName","handlers","onMouseEnterHandler","onMouseLeaveHandler","tasks","task","String","subscribe","subscribeOnce","subscribeEventOnce","unsubscribe","unsubscribeAll","unsubscribeAllEvent","publish","publishEvent","templateBinding","condition","visualBindingOptions","eventsBindingOptions","serverRenderedOptions","bindingUpdateOption","handlerWrap","formData","$form","HTMLFormElement","FormData","getFormData","templateSettings","evaluate","interpolate","dataBind","use","init","version"],"mappings":"CASC,WACC,aAKA,SAASA,EAAmBC,GAC1B,IAAIC,EAAcC,KAAKD,YACvB,OAAOC,KAAKC,MAAK,SAAUC,GAEzB,OAAOH,EAAYI,QAAQL,KAAYG,MAAK,WAC1C,OAAOC,QAER,SAAUE,GAEX,OAAOL,EAAYI,QAAQL,KAAYG,MAAK,WAE1C,OAAOF,EAAYM,OAAOD,SAKhC,SAASE,EAAWC,GAElB,OAAO,IADCP,MACK,SAAUG,EAASE,GAC9B,IAAME,QAA6B,IAAfA,EAAIC,OACtB,OAAOH,EAAO,IAAII,iBAAiBF,EAAM,IAAMA,EAAM,mEAGvD,IAAIG,EAAOC,MAAMC,UAAUC,MAAMC,KAAKP,GACtC,GAAoB,IAAhBG,EAAKF,OAAc,OAAOL,EAAQ,IACtC,IAAIY,EAAYL,EAAKF,OAErB,SAASQ,EAAIC,EAAGC,GACd,GAAIA,IAAuB,iBAARA,GAAmC,mBAARA,GAAqB,CACjE,IAAIjB,EAAOiB,EAAIjB,KAEf,GAAoB,mBAATA,EAaT,YAZAA,EAAKa,KAAKI,GAAK,SAAUA,GACvBF,EAAIC,EAAGC,MACN,SAAUC,GACXT,EAAKO,GAAK,CACRG,OAAQ,WACRhB,OAAQe,GAGU,KAAdJ,GACJZ,EAAQO,MAOhBA,EAAKO,GAAK,CACRG,OAAQ,YACRlB,MAAOgB,GAGW,KAAdH,GACJZ,EAAQO,GAIZ,IAAK,IAAIO,EAAI,EAAGA,EAAIP,EAAKF,OAAQS,IAC/BD,EAAIC,EAAGP,EAAKO,OAOlB,IAAII,EAAiBC,WAErB,SAASC,EAAUC,GACjB,OAAOC,QAAQD,QAAyB,IAAbA,EAAEhB,QAG/B,SAASkB,KAcT,SAASC,EAAUC,GACjB,KAAM5B,gBAAgB2B,GAAY,MAAM,IAAIlB,UAAU,wCACtD,GAAkB,mBAAPmB,EAAmB,MAAM,IAAInB,UAAU,kBAGlDT,KAAK6B,OAAS,EAGd7B,KAAK8B,UAAW,EAGhB9B,KAAK+B,YAASC,EAGdhC,KAAKiC,WAAa,GAClBC,EAAUN,EAAI5B,MAGhB,SAASmC,EAAOC,EAAMC,GACpB,KAAuB,IAAhBD,EAAKP,QACVO,EAAOA,EAAKL,OAGM,IAAhBK,EAAKP,QAMTO,EAAKN,UAAW,EAEhBH,EAAUW,cAAa,WACrB,IAAIC,EAAqB,IAAhBH,EAAKP,OAAeQ,EAASG,YAAcH,EAASI,WAE7D,GAAW,OAAPF,EAAJ,CAKA,IAAIG,EAEJ,IACEA,EAAMH,EAAGH,EAAKL,QACd,MAAOZ,GAEP,YADAd,EAAOgC,EAASM,QAASxB,GAI3BhB,EAAQkC,EAASM,QAASD,QAbP,IAAhBN,EAAKP,OAAe1B,EAAUE,GAAQgC,EAASM,QAASP,EAAKL,YAXhEK,EAAKH,WAAWW,KAAKP,GA4BzB,SAASlC,EAAQiC,EAAMS,GACrB,IAEE,GAAIA,IAAaT,EAAM,MAAM,IAAI3B,UAAU,6CAE3C,GAAIoC,IAAiC,iBAAbA,GAA6C,mBAAbA,GAA0B,CAChF,IAAI5C,EAAO4C,EAAS5C,KAEpB,GAAI4C,aAAoBlB,EAItB,OAHAS,EAAKP,OAAS,EACdO,EAAKL,OAASc,OACdC,EAAOV,GAEF,GAAoB,mBAATnC,EAEhB,YADAiC,GA7EMN,EA6ES3B,EA7EL8C,EA6EWF,EA5EpB,WACLjB,EAAGoB,MAAMD,EAASE,aA2EkBb,GAKpCA,EAAKP,OAAS,EACdO,EAAKL,OAASc,EACdC,EAAOV,GACP,MAAOjB,GACPd,EAAO+B,EAAMjB,GAtFjB,IAAcS,EAAImB,EA0FlB,SAAS1C,EAAO+B,EAAMS,GACpBT,EAAKP,OAAS,EACdO,EAAKL,OAASc,EACdC,EAAOV,GAGT,SAASU,EAAOV,GACM,IAAhBA,EAAKP,QAA2C,IAA3BO,EAAKH,WAAWzB,QACvCmB,EAAUW,cAAa,WAChBF,EAAKN,UACRH,EAAUuB,sBAAsBd,EAAKL,WAK3C,IAAK,IAAId,EAAI,EAAGkC,EAAMf,EAAKH,WAAWzB,OAAQS,EAAIkC,EAAKlC,IACrDkB,EAAOC,EAAMA,EAAKH,WAAWhB,IAG/BmB,EAAKH,WAAa,KAOpB,SAASmB,EAAQZ,EAAaC,EAAYE,GACxC3C,KAAKwC,YAAqC,mBAAhBA,EAA6BA,EAAc,KACrExC,KAAKyC,WAAmC,mBAAfA,EAA4BA,EAAa,KAClEzC,KAAK2C,QAAUA,EAUjB,SAAST,EAAUN,EAAIQ,GACrB,IAAIiB,GAAO,EAEX,IACEzB,GAAG,SAAU1B,GACPmD,IACJA,GAAO,EACPlD,EAAQiC,EAAMlC,OACb,SAAUE,GACPiD,IACJA,GAAO,EACPhD,EAAO+B,EAAMhC,OAEf,MAAOkD,GACP,GAAID,EAAM,OACVA,GAAO,EACPhD,EAAO+B,EAAMkB,IAIjB3B,EAAUf,UAAiB,MAAI,SAAU6B,GACvC,OAAOzC,KAAKC,KAAK,KAAMwC,IAGzBd,EAAUf,UAAUX,KAAO,SAAUuC,EAAaC,GAEhD,IAAIc,EAAO,IAAIvD,KAAKD,YAAY2B,GAEhC,OADAS,EAAOnC,KAAM,IAAIoD,EAAQZ,EAAaC,EAAYc,IAC3CA,GAGT5B,EAAUf,UAAmB,QAAIf,EAEjC8B,EAAU6B,IAAM,SAAUjD,GACxB,OAAO,IAAIoB,GAAU,SAAUxB,EAASE,GACtC,IAAKkB,EAAUhB,GACb,OAAOF,EAAO,IAAII,UAAU,iCAG9B,IAAIC,EAAOC,MAAMC,UAAUC,MAAMC,KAAKP,GACtC,GAAoB,IAAhBG,EAAKF,OAAc,OAAOL,EAAQ,IACtC,IAAIY,EAAYL,EAAKF,OAErB,SAASQ,EAAIC,EAAGC,GACd,IACE,GAAIA,IAAuB,iBAARA,GAAmC,mBAARA,GAAqB,CACjE,IAAIjB,EAAOiB,EAAIjB,KAEf,GAAoB,mBAATA,EAIT,YAHAA,EAAKa,KAAKI,GAAK,SAAUA,GACvBF,EAAIC,EAAGC,KACNb,GAKPK,EAAKO,GAAKC,EAEU,KAAdH,GACJZ,EAAQO,GAEV,MAAO4C,GACPjD,EAAOiD,IAIX,IAAK,IAAIrC,EAAI,EAAGA,EAAIP,EAAKF,OAAQS,IAC/BD,EAAIC,EAAGP,EAAKO,QAKlBU,EAAUrB,WAAaA,EAEvBqB,EAAUxB,QAAU,SAAUD,GAC5B,OAAIA,GAA0B,iBAAVA,GAAsBA,EAAMH,cAAgB4B,EACvDzB,EAGF,IAAIyB,GAAU,SAAUxB,GAC7BA,EAAQD,OAIZyB,EAAUtB,OAAS,SAAUH,GAC3B,OAAO,IAAIyB,GAAU,SAAUxB,EAASE,GACtCA,EAAOH,OAIXyB,EAAU8B,KAAO,SAAUlD,GACzB,OAAO,IAAIoB,GAAU,SAAUxB,EAASE,GACtC,IAAKkB,EAAUhB,GACb,OAAOF,EAAO,IAAII,UAAU,kCAG9B,IAAK,IAAIQ,EAAI,EAAGkC,EAAM5C,EAAIC,OAAQS,EAAIkC,EAAKlC,IACzCU,EAAUxB,QAAQI,EAAIU,IAAIhB,KAAKE,EAASE,OAM9CsB,EAAUW,aACc,mBAAjBoB,cAA+B,SAAU9B,GAE9C8B,aAAa9B,KACV,SAAUA,GACbP,EAAeO,EAAI,IAGrBD,EAAUuB,sBAAwB,SAA+BS,GACxC,oBAAZC,SAA2BA,SACpCA,QAAQC,KAAK,wCAAyCF,IAM1D,IAAIG,EAAW,WAIb,GAAoB,oBAAT1B,KACT,OAAOA,KAGT,GAAsB,oBAAX2B,OACT,OAAOA,OAGT,GAAsB,oBAAXC,OACT,OAAOA,OAGT,MAAM,IAAIC,MAAM,kCAhBH,GAuBoB,mBAAxBH,EAAkB,QAC3BA,EAAkB,QAAInC,EACZmC,EAASI,QAAQtD,UAAmB,QAEpCkD,EAASI,QAAQ5D,aAC3BwD,EAASI,QAAQ5D,WAAaA,GAF9BwD,EAASI,QAAQtD,UAAmB,QAAIf,EAK1C,MAAMsE,EAAiB,CACrBC,KAAM,eACNC,IAAK,cACLC,KAAM,eACNC,MAAO,gBACPC,SAAU,mBACVC,KAAM,eACNC,MAAO,gBACPC,MAAO,gBACPC,OAAQ,iBACRC,OAAQ,iBACRC,MAAO,gBACPC,KAAM,eACNC,IAAK,cACLC,KAAM,eACNC,MAAO,cACPC,GAAI,aACJC,OAAQ,iBACRC,KAAM,eACNC,QAAS,mBAELC,EAAqB,uBAErBC,EACG,cADHA,EAEA,WAFAA,EAGE,aAHFA,EAIK,gBAELC,EAAgB,OAOhBC,EACS,QADTA,EAES,QAFTA,EAGU,SAHVA,EAImB,KAJnBA,EAKmB,MAEnBC,EACY,kBADZA,EAEE,OAIFC,EACK,CACPC,KAAM,QAFJD,EAIQ,UAGdE,EAAI/B,OAAO+B,GAAK,GAChB,MAAMC,EAAapF,MAAMqF,QACnBC,EACW,YADXA,EAES,OAFTA,EAGG,2BAHHA,EAIE,KAJFA,EAKM,2BALNA,EAMM,4CAENC,EAAuB,YAAaC,SAASC,cAAc,YAC3DC,EAAW,CACfC,IAAK,CAAC,MAAO,QAAS,UACtBC,MAAO,CAAC,QAAS,UAAW,YAC5BC,IAAK,CAAC,WAAY,oBAAqB,uBACvCC,GAAI,CAAC,QAAS,iBAAkB,oBAChCC,GAAI,CAAC,KAAM,cAAe,kBAE5BL,EAASM,QAAUN,EAASO,SAAWP,EAASQ,MAAQR,EAASS,MAAQT,EAASE,MAClFF,EAASU,GAAKV,EAASK,GAEvB,MAAMV,EAAUgB,GACPjB,EAAapF,MAAMqF,QAAQgB,GAA+C,mBAAxCC,OAAOrG,UAAUsG,SAASpG,KAAKkG,GAGpEG,EAAaH,GACF,OAARA,GAA+B,iBAARA,GAA4D,oBAAxCC,OAAOrG,UAAUsG,SAASpG,KAAKkG,GAG7EI,EAAgBJ,IACpB,IAAKG,EAAWH,GACd,OAAO,EAIT,MAAMK,EAAOL,EAAIjH,YACjB,GAAoB,mBAATsH,EAAqB,OAAO,EAEvC,MAAMC,EAAOD,EAAKzG,UAClB,OAAyB,IAArBuG,EAAWG,KAE8B,IAAzCA,EAAKC,eAAe,kBAQpBC,EAAgBR,KAChBG,EAAWH,IACqC,IAA3CC,OAAOQ,oBAAoBT,GAAKxG,OAoB3C,SAASkH,EAAmBC,GAC1B,GAA0B,iBAAfA,EACT,OAAO,KAIT,GAAIzB,EAAqB,CACvB,MAAM0B,EAAWzB,SAASC,cAAc,YAExC,OADAwB,EAASC,UAZb,SAAuBF,EAAa,IAClC,OAAOA,EAAWG,QAAQ7B,EAAgB,IAWnB8B,CAAcJ,GAC5BC,EAASI,QAIlB,MAAMC,EAAW9B,SAAS+B,yBACpBC,EAAiBhC,SAASC,cAAc,OACxCgC,EA7BR,SAA+BT,GAC7B,MAAMU,EAAQV,EAAWU,MAAMpC,GAE/B,OAAIoC,EACKA,EAAM,GAGR,KAsBUC,CAAsBX,GACjCY,EAAOlC,EAAS+B,GAAY,OAElC,GAAgB,QAAZG,EAAK,GACP,OAAOpC,SAASqC,cAAcC,yBAAyBd,GAGzDQ,EAAeO,mBAAmB,YAAa,GAAGH,EAAK,KAAKZ,IAAaY,EAAK,MAC9E,MAAMI,EAAQR,EAAeS,cAAcL,EAAK,IAEhD,KAAOI,EAAME,YACXZ,EAASa,YAAYH,EAAME,YAG7B,OAAOZ,EAWT,MAAMc,EAAoB,CAACC,EAAWC,IAC7BnD,EAAEoD,IAAIF,EAAWC,GAgBpBE,EAAwB,CAACH,EAAWI,KACxC,IAAIC,EAAUD,EAAaC,QACvBC,EAAYF,EAAaG,WAC7B,MAAMC,EAAwC,MAAtBH,EAAQI,OAAO,GAEnCD,IACFH,EAAUG,EAAkBH,EAAQK,UAAU,GAAKL,GAGrD,IAAI3G,EAAMqG,EAAkBC,EAAWK,GAEvC,GAAmB,mBAAR3G,EAAoB,CAC7B,MAAMiH,EAAmBC,EAAwBZ,EAAWK,GACtDQ,EAAuBT,EAAaU,YAAcV,EAAaU,YAAYC,kBAAoB,KACrGT,EAAYA,EAAYU,EAAiBhB,EAAWM,GAAa,GAEjE,MAAM5I,EAAO4I,EAAUW,OAAO,CAACJ,EAAsBT,EAAac,KAClExH,EAAMA,EAAIM,MAAM2G,EAAkBjJ,GAUpC,OAPAgC,EAAM8G,GAAmB/H,QAAQiB,GAAOA,EAExCA,EAAMyH,EAA0B,CAC9BjK,MAAOwC,EACPsG,UAAWA,EACXI,aAAcA,IAET1G,GAGHyH,EAA4B,EAChCjK,MAAAA,EACA8I,UAAAA,EACAI,aAAAA,MAEA,IAAI1G,EAAMxC,EAeV,OAbIkJ,EAAagB,SACfC,EAAKjB,EAAagB,SAAS,CAACE,EAAOC,KACjC,MAAMZ,EAAmBC,EAAwBZ,EAAWuB,GACtDC,EAAWzB,EAAkBjI,KAAK6I,EAAkBA,EAAkBY,GAE5E,IACE7H,EAAM8H,EAAS1J,KAAK6I,EAAkBjH,GACtC,MAAOiB,GACP8G,GAAkB9G,EAAK,mBAAmB4G,SAKzC7H,GA4GHgI,EAAoB,KACxB,MAAMC,EAAQ,GAKd,OAJAA,EAAMhI,QAAU,IAAIuB,SAAQ,CAAC/D,EAASE,KACpCsK,EAAMxK,QAAUA,EAChBwK,EAAMtK,OAASA,KAEVsK,GAsDHC,EAAS,CAACC,GAAc,EAAOC,KAAWC,KAC9C,IAAKA,EAAQvK,OACX,OAAOsK,EAGT,MAAME,EAASD,EAAQE,QAEvB,YAAejJ,IAAXgJ,EACKF,EAGJD,GAIDK,EAAiBJ,IAAWI,EAAiBF,IAC/C/D,OAAOkE,KAAKH,GAAQI,SAAQC,IACtBH,EAAiBF,EAAOK,KACrBP,EAAOO,KACVP,EAAOO,GAAO,IAGhBT,EAAOE,EAAOO,GAAML,EAAOK,KAE3BP,EAAOO,GAAOL,EAAOK,MAKpBT,GAAO,EAAME,KAAWC,IAjBtB9D,OAAOqE,OAAOR,KAAWC,IAoB9BV,EAAO,CAACrD,EAAKpF,KACjB,GAAmB,iBAARoF,GAAkC,mBAAPpF,EACpC,OAGF,IAAIuJ,EAAO,GACPI,EAAa,EACjB,MAAMC,EAAaxF,EAAQgB,GAC3B,IAAIqE,EACAnL,EACAe,EAAI,EAER,GAAIuK,EACFD,EAAavE,EAAIxG,WACZ,CAAA,IAAI2G,EAAWH,GAIpB,MAAM,IAAIvG,UAAU,oCAHpB0K,EAAOlE,OAAOkE,KAAKnE,GACnBuE,EAAaJ,EAAK3K,OAKpB,IAAKS,EAAI,EAAGA,EAAIsK,EAAYtK,GAAK,EAC3BuK,GACFH,EAAMpK,EACNf,EAAQ8G,EAAI/F,KAEZoK,EAAMF,EAAKlK,GACXf,EAAQ8G,EAAIqE,IAGdzJ,EAAGyJ,EAAKnL,IAINgL,EAAmBO,GAChBtE,EAAWsE,KAAUzF,EAAQyF,GAuBhCC,EAAc,CAACC,EAAYC,EAASC,KACxC,MAAMC,EAAiBD,GAAiBA,EAAcE,YAAcF,EAAcE,YAAc,KAChG,OAAOJ,EAAWK,aAAaJ,EAASE,IAGpClC,EAA0B,CAACZ,EAAWiD,KAC1C,IAAIvJ,EAAMsG,EAEV,GAAuB,iBAAZiD,EACT,OAAOvJ,EAGT,MAAMwJ,EAAqBD,EAAQE,MAAM,KAUzC,OARID,EAAmB1L,OAAS,IAC1B0L,EAAmB,KAAOxG,EAC5BhD,EAAMsG,EAAUtD,IAAqCsD,EAC5CkD,EAAmB,KAAOxG,IACnChD,EAAMsG,EAAUtD,IAAqCsD,IAIlDtG,GAGHsH,EAAmB,CAAChB,EAAWM,KACnC,GAAKN,GAAchD,EAAQsD,GAI3B,OAAOA,EAAU8C,KAAIC,KACnBA,EAAQA,EAAMC,UAEA5G,EAEZ2G,EAAQrD,EAAUtD,GACT2G,IAAU3G,EAEnB2G,EAAQrD,EAAUtD,IAAqCsD,EAC9CqD,IAAU3G,IAEnB2G,EAAQrD,EAAUtD,IAAqCsD,GAGlDqD,MAULE,GAAeC,IACnB,GAAIA,GAAQA,EAAK3D,WACf,KAAO2D,EAAK3D,YACV2D,EAAKC,YAAYD,EAAK3D,YAI1B,OAAO2D,GAGH/B,GAAoB,CAAC9G,EAAM,KAAM+I,EAAe,MACpD,MAAMC,EAAUhJ,GAAOA,EAAIgJ,QAAUhJ,EAAIgJ,QAAUD,EAEnD,MAA6B,mBAAlB9I,QAAQgJ,MACVhJ,QAAQgJ,MAAMD,GAGhB/I,QAAQiJ,IAAIF,IAGrB,IAAIG,GAAe,KACfC,GAAgB,KAChBC,GAAqB,EACzB,MAAMC,GAAgB,GAmChBC,GAAiB,CAACC,EAAOnE,EAAWoE,EAAcC,KACtD,MAAMC,EAAoC,iBAAlBH,EAAM9D,QAhXNkE,CAAAA,IAExB,MAAM7K,EAAM6K,EAAIzF,QAAQ,sDAAuD,WAAWA,QAAQ,KAAM,KACxG,OAAO0F,KAAKC,MAAM/K,IA6WmCgL,CAAkBP,EAAM9D,SAAW8D,EAAM9D,QAC9F,IAAIsE,EAAWL,EAASM,KACxB,MAAMC,EAAWP,EAASQ,OACpBC,EAAYT,EAASU,QAC3B,IAAIC,EAOJ,GANAd,EAAM9D,QAAUiE,EAChBK,OAA+B,IAAbA,GAAyC,UAAbA,EAAuB3E,EAAYG,EAAsBH,EAAW,CAChHK,QAASiE,EAASM,KAClBrE,WAAY4D,EAAM5D,cAGfoE,EACH,OAGF,MAAMO,EAAWf,EAAMjD,GACjBiE,OAAqC,IAArBnF,EAAUmF,OAAyBnF,EAAUmF,OAASD,EAASE,aAvlBjE,mBAylBE,IAAXD,IACTR,EAASQ,OAASA,GAGpBrB,GAAeA,IAAgB3G,SAAS+B,yBACxC6E,GAAgBA,IAAiBmB,EACjC,MACMG,EAAe3G,EApDC,EAAC4G,EAAIC,EAAe,QAC1C,IAAIC,EACAC,EAUJ,OARKxB,GAAcqB,KACjBG,EAAkBtI,SAASuI,eAAeJ,GAC1CE,EAAiBC,EAAkBA,EAAgB5G,UAAY,GAC/DoF,GAAcqB,GAAMxI,EAAE8B,SAAS4G,EAAgB,CAC7CG,SAAU,UAIP1B,GAAcqB,GAAIC,IAuCNK,CAAgBtB,EAASgB,GAAIX,IAG3Cb,GAAa+B,WAAWrO,QAO3ByN,EAAkBC,EAEbL,GAAaE,IAChBE,EAAkB1B,GAAa0B,IAG7BF,EACFE,EAAgBjC,aAAaqC,EAAcJ,EAAgBpF,YAE3DoF,EAAgBnF,YAAYuF,KAd9BJ,EAAkBnB,GAElBA,GAAahE,YAAYuF,IAiB3B,MAAMS,EAAmBb,EAAgBc,iBAAiB,IAAM3B,EAAa/I,IAAM,KAC7E2K,EAAwBF,EAAiBtO,OAE/C,GAAIwO,EAAuB,CACzBhC,IAAsBgC,EAEtB,IAAK,IAAI/N,EAAI,EAAGA,EAAI+N,EAAuB/N,GAAK,EAAG,CACjD,MAAMgO,EAAoB,CACxB/E,GAAI4E,EAAiB7N,GACrBoI,QAASyF,EAAiB7N,GAAGmN,aAAahB,EAAa/I,MAEzDgJ,EAAaD,EAAa/I,KAAKzB,KAAKqM,GAEpC/B,GAAe+B,EAAmBjG,EAAWoE,EAAcC,GAC3DL,IAAsB,GAKC,IAAvBA,KAEGa,GAAaE,IAChBhB,GAAgBR,GAAaQ,KAG3BgB,EACFhB,GAAcf,aAAac,GAAcC,GAAclE,YAEvDkE,GAAcjE,YAAYgE,IAI5BA,GAAeC,GAAgB,KAEc,mBAAlC/D,EAAUkG,qBACnBlG,EAAUkG,oBAAoBvB,KA8D9BwB,GAAgB,CAAChC,EAAOnE,EAAWoE,EAAcgC,KACrD,MAAMC,EAAclC,EAAM9D,QAC1B,IAAIC,EAAY6D,EAAM5D,WACtB,MAAM+F,EAAenC,EAAMjD,GAAGkE,aAAahB,EAAatI,OACxD,IAEI6E,EAFA9G,EAAW,GACX0M,EAAW,GAEf,MAAMC,EAAMxG,EAAUwG,KAAOxG,EAAUyG,MAAMD,IAE7C,IAAKH,IAAgBD,IAAgBI,EAAIE,aAAaC,SAASxC,EAAMjD,IACnE,OAGF,MAAM0F,EAAY7G,EAAkBC,EAAWqG,GAE/C,GAAyB,mBAAdO,EAA0B,CAInC,SAASC,EAAc1O,GACrB,MAAM2O,EAAQ9P,KACR+P,EAA4B,aAAfD,EAAME,KA/kBL,IAAChJ,EAAKiC,EAAM/I,EAglBhC2C,EAAWkN,EAAaD,EAAMG,QAAUnK,EAAEoK,OAAOJ,EAAM5P,OAEnDoP,IACFC,EAAWxG,EAAkBC,EAAWsG,GAnlBrBtI,EAolBDgC,EAplBMC,EAolBKqG,EAplBCpP,EAolBa2C,EAnlB1CiD,EAAEqK,IAAInJ,EAAKiC,EAAM/I,IAslBpB,MAAMQ,EAAO,CAACS,EAAGA,EAAEiP,cAAevN,EAAU0M,GAAUtF,OAAOX,GAC7DsG,EAAU5M,MAAM2G,EAAkBjJ,GAClC6O,EAAW1M,EAfb8G,EAAmBC,EAAwBZ,EAAWqG,GACtD/F,EAAYA,EAAYU,EAAiBhB,EAAWM,GAAa,GAkBjE6D,EAAMjD,GAAGmG,oBAAoB,SAAUR,GAAe,GACtD1C,EAAMjD,GAAGoG,iBAAiB,SAAUT,GAAe,KA2SvD,IAAIU,GASJ,MAAMC,GAAU,CAAChE,EAAMiE,KACrB,IAAIC,GAAiB,EAGrB,IAFAlE,EAAOA,EAAKmE,kBAELnE,GACLkE,EAAiBD,EAAKjE,GAElBkE,GACFF,GAAQhE,EAAMiE,GAGhBjE,EAAOA,EAAKoE,oBAkBVC,GAAgBrE,GACI,QAAjBA,EAAKsE,QAGRC,GAAmB,CAACvE,EAAMY,IACN,QAAjBZ,EAAKsE,SAAqBtE,EAAKwE,aAAa5D,EAAahJ,MAG5D6M,GAAuB,EAC3BzE,KAAAA,EACA0E,QAAAA,EACA9H,aAAAA,EACA4G,KAAAA,MAEA,IAAImB,EACAC,EAEJ,GAAIb,IAAmBA,GAAgBP,SAAkC,IAAlBkB,EAAQlB,GAAuB,CACpF5G,EAAa4G,GAAQ5G,EAAa4G,IAAS,GAC3CmB,EAAYD,EAAQlB,GAAM1D,OAC1B8E,EAAY,CACVlH,GAAIsC,EACJnD,QAAS8H,GAGXC,EA30BsBA,CAAAA,IACxB,IAAKA,IAAcA,EAAU/H,SAAW+H,EAAU/H,QAAQ7I,OAlQnC,GAmQrB,OAAO4Q,EAGT,MAAMC,EAAaD,EAAU/H,QAAQ8C,MAAMlG,GAC3C,IAAIqL,EAqBJ,OApBAF,EAAU/H,QAAUgI,EAAW,GAAG/E,OAE9B+E,EAAW7Q,OAAS,IACtB6Q,EAAWpG,MAAM,GACjBoG,EAAWjG,SAAQ,SAAUmG,EAAGtQ,GAC9BoQ,EAAWpQ,GAAKsQ,EAAEjF,OAEd+E,EAAWpQ,KAAO2E,EAAkBC,OACtCuL,EAAUI,QAAS,EACnBF,EAAcrQ,MAIdqQ,GAAe,GACjBD,EAAWI,OAAOH,EAAa,GAGjCF,EAAUhH,QAAUiH,GAGfD,GAgzBOM,CAAkBN,GAI9B,MAAM9H,EAh2BuBiE,CAAAA,IAC/B,IAAKA,GAAOA,EAAI/M,OAjPO,GAkPrB,OAGF,IAAImR,EAAYpE,EAAIlF,MAAMpC,GAS1B,OAPI0L,GAAaA,EAAU,KACzBA,EAAYA,EAAU,GAAGxF,MAAM,KAC/BwF,EAAUvG,SAAQ,SAAUmG,EAAGtQ,GAC7B0Q,EAAU1Q,GAAKsQ,EAAEjF,WAIdqF,GAk1BaC,CAAyBR,EAAU/H,SAEjDC,IACF8H,EAAU7H,WAAaD,EACvB8H,EAAU/H,QAAU+H,EAAU/H,QAAQvB,QAAQ7B,EAAqB,IAAIqG,QAIzE8E,EAAUxL,GAAwBwD,EAAa4G,GAC/C5G,EAAa4G,GAAMpN,KAAKwO,GAG1B,OAAOhI,GAGHyI,GAAqB,EACzBC,SAAAA,EAAW,KACX1E,aAAAA,EAAe,GACf2E,UAAAA,EACAC,mBAAAA,GAAqB,MAErB,IAAI5I,EAAe,GAEnB,IAAK0I,aAAoB/N,OAAOkO,KAC9B,MAAM,IAAIxR,UAAU,gCAz0BNyR,IAAAA,EA40BhB3B,GAAkBA,KA50BF2B,EA40B+B9E,EA30BxCnG,OAAOkE,KAAK+G,GAAWC,QAAO,SAAUnL,EAAKqE,GAElD,OADArE,EAAIkL,EAAU7G,IAAQA,EACfrE,IACN,KA00BH,MAAMoL,EAAY,CAAC5F,EAAM6F,EAAkBtB,MACzC,IAAIuB,GAAmB,EAEvB,GAAsB,IAAlB9F,EAAK+F,WAAmB/F,EAAKgG,gBAC/B,OAAO,EAGT,GAAIH,EAAgB7F,EAAMY,IAAsC,mBAAd2E,GAA4BA,EAAUvF,GACtF,OAAO,EAKT,MAAM0E,EArFkB1E,CAAAA,IAC1B,MAAM9J,EAAM,GAIZ,OAHA/B,MAAMC,UAAUC,MAAMC,KAAK0L,EAAKiG,YAAYrH,SAAQK,IAClD/I,EAAI+I,EAAKiH,MAAQjH,EAAKvL,SAEjBwC,GAgFWiQ,CAAoBnG,GAC9BoG,EA9E0B,EAAC1B,EAAU,GAAI9D,IAC1C,CAACA,EAAalI,MAAOkI,EAAajI,GAAIiI,EAAa/H,KAAM+H,EAAa9H,SAASiF,QAAOyF,QAC3D,IAAlBkB,EAAQlB,KA4EY6C,CAA4B3B,EAAS9D,GACvE,IAAI0F,EAAc,GAElB,GAAIF,EAA0BpS,OAC5B8R,GAAmB,EACnBQ,EAAcF,MACT,CAAA,GAAIZ,GAAsBd,EAAQ9D,EAAa/I,KAEpD,OAAO,EAEPyO,EAAc7L,OAAOkE,KAAK+F,GAe5B,OAZA4B,EAAY1H,SAAQC,IAEdA,IAAQ+B,EAAa/H,MAAQgG,IAAQ+B,EAAa9H,UACpD8D,EAAe6H,GAAqB,CAClCzE,KAAMA,EACN0E,QAASA,EACT9H,aAAcA,EACd4G,KAAM3E,SAKRiH,GAWN,OAJIF,EAAUN,EAAUjB,KACtBL,GAAQsB,EAAUM,GAGbhJ,GAKH2J,GAA2BC,IAC/B,MAAMC,EAAgBD,EAAY9I,GAAGgJ,WAAU,GAG/C,OAFAF,EAAY/K,SAAW9B,SAAS+B,yBAChC8K,EAAY/K,SAASa,YAAYmK,GAC1BD,GAGHG,GAAmBH,IACvB,IAAKA,IAAgBA,EAAYhD,KAC/B,OAAOgD,EAGT,IAAII,EAAkB,GACtB,MAAMC,EAAgBL,EAAY3J,QAAU2J,EAAY3J,QAAQvB,QAAQ7B,EAAmB,KAAO,GAElG,OAAQ+M,EAAYhD,MAClB,KAAK7L,EAAee,MAClBkO,EAAkB5N,EAClB,MAEF,KAAKrB,EAAegB,GAClBiO,EAAkB5N,EAClB,MAEF,KAAKrB,EAAekB,KAClB+N,EAAkB5N,EAClB,MAEF,KAAKrB,EAAemB,QAClB8N,EAAkB5N,EAKtB,OADAwN,EAAYxN,cAAgB4N,EAAkBC,EACvCL,GAcHM,GAAsB,CAAC9G,EAAMwG,KAC5BA,EAAYxN,eACf2N,GAAiBH,GAGnB,MACMO,EADmBP,EAAYxN,cACKC,EAG1C,GAFA+G,EAAOA,EAAKT,YAEF,CACR,GAAsB,IAAlBS,EAAK+F,UAAkB/F,EAAKgH,cAAgBD,EAC9C,OAAOP,EAAYS,SAASC,aAAalH,GAG3C8G,GAAoB9G,EAAMwG,KAaxBW,GAAoB,CAACX,EAAaxG,KACtC,IAAIoH,EAAS,GAERZ,EAAYxN,eACf2N,GAAiBH,GAGnBY,EAASZ,EAAYxN,cACrB,MAAMqO,EAAe1N,SAAS2N,cAAcF,GACtCG,EAAa5N,SAAS2N,cAAcF,EAASnO,GAenD,OAZsB,KAAlB+G,EAAK+F,UACP/F,EAAKR,aAAa6H,EAAcrH,EAAK3D,YACrC2D,EAAK1D,YAAYiL,IACRvH,EAAKb,aACda,EAAKb,WAAWK,aAAa6H,EAAcrH,GAC3Cd,EAAYc,EAAKb,WAAYoI,EAAYvH,GAEzCwG,EAAYgB,2BAA6BxH,EAAKyH,gBAC9CjB,EAAYkB,uBAAyB1H,EAAKT,YAC1CiH,EAAYmB,cAAgB3H,EAAKyH,gBAAgBE,eAG5C3H,GAUH4H,GAA8BpB,IAC7BA,EAAYS,WACfT,EAAYS,SAAWtN,SAASqC,eAGlC,IACMwK,EAAYgB,4BAEdhB,EAAYS,SAASY,eAAerB,EAAYgB,2BAA2BjI,aAC3EuH,GAAoBN,EAAYgB,2BAA2BjI,YAAaiH,KAGxEA,EAAYS,SAASY,eAAerB,EAAYmB,cAActL,YAC9DyK,GAAoBN,EAAYmB,cAActL,WAAYmK,IAE5D,MAAOrP,GACPC,QAAQiJ,IAAI,sCAAuClJ,EAAIgJ,SAGzD,OAAOqG,EAAYS,SAASa,kBAGxBC,GAAyB,CAACvB,EAAa/K,KAEvC+K,EAAYgB,2BACdtI,EAAYsH,EAAYmB,cAAelM,EAAU+K,EAAYgB,4BAGzDhB,EAAYkB,uBACdlB,EAAYmB,cAAcnI,aAAa/D,EAAU+K,EAAYkB,wBACpDlB,EAAYmB,eAErBnB,EAAYmB,cAAcrL,YAAYb,IA+EtCuM,GAA2B,EAC/BxB,YAAAA,EACAhK,UAAAA,EACAyL,cAAAA,EACAtJ,KAAAA,EACAb,MAAAA,MAEA,MAAMoK,EAAc,GAMpB,OALAA,EAAY1B,EAAY2B,SAASC,OAASzJ,EAAOsJ,EAActJ,EAAKb,IAAUmK,EAAcnK,GAE5FoK,EAAYhP,GAAoCsD,EAAUyG,OAASzG,EACnE0L,EAAYhP,GAAoCgP,EAAY1B,EAAY2B,SAASC,OACjFF,EAAYhP,GAAqC4E,EAC1CoK,GAGHG,GAAwB,CAAC7B,EAAahK,EAAWoE,EAAcqH,EAAetJ,KAClF,MAAMlD,EAAW9B,SAAS+B,yBACpB4M,EAAsB9B,EAAY+B,cACxC,IAAIC,EACAN,EACAO,EACAhU,EAAI,EASR,IAPI+E,EAAQgN,EAAYiC,uBACtBjC,EAAYiC,sBAAsBzU,OAAS,EAE3CwS,EAAYiC,sBAAwB,GAIjChU,EAAI,EAAGA,EAAI6T,EAAqB7T,GAAK,EACxC+T,EAA0BhC,EAAY9I,GAh/BzBgJ,WAAU,GAk/BvB+B,EAAwBpD,GAAmB,CACzCC,SAAUkD,EACV5H,aAAcA,IAEhB4F,EAAYiC,sBAAsBrS,KAAKqS,GAElCzN,EAAcyN,KAEjBP,EAAcF,GAAyB,CACrCxB,YAAaA,EACbhK,UAAWA,EACXyL,cAAeA,EACftJ,KAAMA,EACNb,MAAOrJ,IAETiU,GAAgB,CACd7H,aAAc2F,EAAYiC,sBAAsBhU,GAChDyT,YAAaA,EACbtH,aAAcA,EACd+H,cAAc,KAIlBlN,EAASa,YAAYkM,GAGvB,OAAO/M,GAYHmN,GAAe,CAACjI,EAAOnE,EAAWoE,KACtC,MAAM/D,EAAU8D,EAAM9D,QAEtB,GAAKA,KAAWA,EAAQ7I,OA38CD,IA28CvB,CAIA,IAAK2M,EAAMwH,SAAU,CACnB,GAAItL,EAAQ7I,OAh9CS,GAi9CnB,OAIF2M,EAAM9D,QAAU8D,EAAM9D,QAAQvB,QAAQ7B,EAAmB,KACzD,MAAMoP,EAAchM,EAAQhB,MAAMpC,GAElC,IAAKoP,EACH,OAGFlI,EAAMwH,SAAW,GACjBxH,EAAMwH,SAASC,MAAQS,EAAY,GAAG/I,OAElC+I,EAAY,KACdlI,EAAMwH,SAAStL,QAAUgM,EAAY,GAAG/I,OACxCa,EAAMgH,cAAgBhH,EAAMjD,GAAGiK,cAC/BhH,EAAM6G,2BAA6B7G,EAAMjD,GAAG+J,gBAC5C9G,EAAM+G,uBAAyB/G,EAAMjD,GAAG6B,aA3KnB,GACzBiH,YAAAA,EACAhK,UAAAA,EACAoE,aAAAA,MAEA,IAAK4F,IAAgBhK,IAAcoE,EACjC,OAGF,IAAIjC,EACA2J,EACJ,MAAML,EAAgBtL,EAAsBH,EAAWgK,EAAY2B,UACnE,IAAIQ,GAAe,EAEnB,GAAInP,EAAQyO,GACVK,EAAsBL,EAAcjU,WAC/B,CAAA,IAAI4G,EAAcqN,GAKvB,OAAOhK,GAAkB,KAAM,iDAJ/BU,EAAOlE,OAAOkE,KAAKsJ,GACnBK,EAAsB3J,EAAK3K,OA0B7B,GAnBKwS,EAAYhD,OACfgD,EAAYhD,KAAO7L,EAAee,MAClCyO,GAAkBX,EAAaA,EAAY9I,UAIJ,IAA9B8I,EAAY+B,eAErB/B,EAAY+B,cAAgBD,EAE5B9B,EAAY9I,GAAGoL,gBAAgBlI,EAAalI,OAC5CiQ,GAAe,IAGfA,EAAenC,EAAY+B,gBAAkBD,EAE7C9B,EAAY+B,cAAgBD,IAGzBK,EAkBH,YAjBAnC,EAAYiC,sBAAsB7J,SAAQ,SAAUiC,EAAcpM,GAChE,IAAKuG,EAAc6F,GAAe,CAChC,MAAMqH,EAAcF,GAAyB,CAC3CxB,YAAaA,EACbhK,UAAWA,EACXyL,cAAeA,EACftJ,KAAMA,EACNb,MAAOrJ,IAETiU,GAAgB,CACd7H,aAAcA,EACdqH,YAAaA,EACbtH,aAAcA,EACd+H,cAAc,QAQtB,MAAMlN,EAAW4M,GAAsB7B,EAAahK,EAAWoE,EAAcqH,EAAetJ,GAC5FiJ,GAA4BpB,GAErBuB,GAAuBvB,EAAa/K,IA0G3CsN,CAAmB,CACjBvC,YAAa7F,EACbnE,UAAWA,EACXoE,aAAcA,MA4BZoI,GAAkB,EACtBxC,YAAAA,EACAhK,UAAAA,EACAoE,aAAAA,MAEA,IAAK4F,EAAY/K,SACf,OAGF,MAAMwN,EA1BmBzC,CAAAA,IACzB,IAAItQ,GAAM,EAEV,GAAIsQ,GAAeA,EAAYgB,2BAA4B,CACzD,MAAM0B,EAA0B1C,EAAYgB,2BAA2BR,YACjEmC,EAAgB3C,EAAYgB,2BAA2BjI,YAE9B,IAA3B4J,EAAcpD,UACZoD,EAAcnC,cAAgBkC,EAA0BjQ,IAC1D/C,GAAM,GAKZ,OAAOA,GAYckT,CAAmB5C,GACxC,IAAI6C,EAAc7C,EAAY9I,GAGzBuL,GAAiBzC,EAAYxB,SAChCsE,GAAgB9C,GAEhB6C,EAAc7C,EAAY/K,SAASY,WAAWqK,WAAU,IAIrDF,EAAYiC,uBAA0BjC,EAAY+C,2BACrD/C,EAAYiC,sBAAwBpD,GAAmB,CACrDC,SAAU+D,EACVzI,aAAcA,KAMb5F,EAAcwL,EAAYiC,yBAC7BjC,EAAY+C,0BAA2B,EACvCb,GAAgB,CACd7H,aAAc2F,EAAYiC,sBAC1BP,YAAa1L,EACboE,aAAcA,EACd+H,cAAc,KAMlBZ,GAAuBvB,EAAa6C,IAGhCC,GAAkB9C,IACtBoB,GAA4BpB,GAExBA,EAAY+C,kCACP/C,EAAYiC,6BACZjC,EAAY+C,2BA2EjBC,GAAuB,EAC3BhN,UAAAA,EACAmE,MAAAA,MAEA,IAAIzK,GAAM,EASV,OAPIsG,EAAUwG,IAAIyG,mBAChBjN,EAAUwG,IAAIyG,iBAAiBrT,KAAK,EAAEuK,EAAO7C,IAAU,KACrD6C,EAAMvH,GAAsB6L,OAAOnH,EAAO,IADR,CAEjC6C,EAAOA,EAAMvH,GAAsBsQ,QAAQ/I,KAC9CzK,GAAM,GAGDA,GAiGT,SAASyT,GAAmBC,EAAOC,GACjCD,EAAMhL,SAAQ,CAACkL,EAAUhM,KACnBA,IAAU+L,QAAwC,IAAjBA,IACnCP,GAAgBQ,GAEZA,EAASP,2BACXO,EAASrB,sBAAwB,KACjCqB,EAASP,0BAA2B,OAM5C,SAASQ,GAAe/J,EAAMgK,GAM5B,MALiB,CACftM,GAAIsC,EACJnD,QAASmD,EAAK4B,aAAaoI,GAC3BxG,KAAMwG,GAeV,MAAMC,GAAS,GAETC,GAAiB,CAACC,EAAW,KAAMC,EAAY,GAAIhV,EAAI4P,GAAS,KACpE,IAAKmF,IAAaA,EAASE,SAAWD,GAA2B,mBAAPhV,EACxD,OAGF,IAAIkV,EACAC,GAAe,EACnBH,EAAYA,EAAU9O,QAAQ7B,EAAmB,IACjDwQ,GAAOG,GAAaH,GAAOG,IAAc,GAEzCG,EAAeN,GAAOG,GAAWI,MAAKF,IACpC,GAAIA,EAAWH,EAASE,QAGtB,OAFAC,EAAWH,EAASE,QAAUjV,EAAGqV,KAAKN,EAAS3N,WAC/C8N,EAAWtF,OAASA,GACb,KAINuF,IACHD,EAAa,GACbA,EAAWH,EAASE,QAAUjV,EAAGqV,KAAKN,EAAS3N,WAC/C8N,EAAWtF,OAASA,EACpBiF,GAAOG,GAAWhU,KAAKkU,KAQrBI,GAAmB,CAACL,EAAS,GAAID,EAAY,MACjD,IAAKC,IAAWD,EACd,OAGF,IAEIE,EAFA7V,EAAI,EACJkW,EAAoB,EAIxB,GAFAP,EAAYA,EAAU9O,QAAQ7B,EAAmB,IAE7CwQ,GAAOG,GAGT,IAFAO,EAAoBV,GAAOG,GAAWpW,OAEjCS,EAAI,EAAGA,EAAIkW,EAAmBlW,GAAK,EAGtC,GAFA6V,EAAaL,GAAOG,GAAW3V,GAE3B6V,EAAWD,GAAS,CACtBJ,GAAOG,GAAWnF,OAAOxQ,EAAG,GAC5B,MAMDwV,GAAOG,GAAWpW,eACdiW,GAAOG,IAyClB,IAAIQ,GAAc,EAElB,MAAMC,GACJtX,YAAY2P,EAAc1G,EAAWoE,GACnC,IAAKsC,GAA0C,IAA1BA,EAAa6C,UAAgC,OAAdvJ,GAA2C,iBAAdA,EAC/E,MAAM,IAAIvI,UAAU,wCAiBtB,OAdAT,KAAKsX,cAAe,EACpBtX,KAAK6W,OAASO,IAAe,EAC7BpX,KAAK0P,aAAeA,EACpB1P,KAAKgJ,UAAYA,EACjBhJ,KAAKoN,aAAeA,EACpBpN,KAAKuX,OAxkDW,EAAC3V,EAAI4V,EAAM,OACtB,SAAU5V,EAAI4V,GACnB,IAAI7M,EAAQD,IACR+M,EAAQ,EAEZ,OAAO,WAEL,MAAM/W,EAAOC,MAAM+W,KAAO/W,MAAM+W,KAAKzU,WAAatC,MAAMC,UAAUC,MAAMC,KAAKmC,WAuB7E,OAtBAc,OAAO4T,qBAAqBF,GAC5BA,EAAQ1T,OAAO6T,uBAAsB,KACnC,IAEEhW,EAAGoB,MAAMwU,EAAK9W,GAGdiK,EAAMxK,QAAQqX,GACd,MAAO7T,GACPC,QAAQgJ,MAAM,uBAAwBjJ,GACtCgH,EAAMtK,OAAOsD,GASfgH,EAAQD,IACR3G,OAAO4T,qBAAqBF,MAEvB9M,EAAMhI,SA7BV,CA+BLf,EAAI4V,GAwiDUK,CAAY7X,KAAKuX,OAAQvX,MACvCA,KAAK8X,iBAA0E,OAAvD9X,KAAK0P,aAAatB,aAAa7I,GAEvDvF,KAAKgJ,UAAUwG,IAAMxP,KACrBA,KAAKgJ,UAAUyG,MAAQzP,KAAKgJ,UAC5BhJ,KAAK+X,YAGL/X,KAAK0P,aAAahK,GAAoC1F,KAAKgJ,UACpDhJ,KAWT+X,YAYE,OAXA/X,KAAKqN,aAAewE,GAAmB,CACrCC,SAAU9R,KAAK0P,aACftC,aAAcpN,KAAKoN,eAGjBpN,KAAK8X,mBAAqB9X,KAAKsX,cACjCtX,KAAKgY,mBAAmB,CACtB/K,eAAe,IAIZjN,KASTgY,mBAAmBC,EAAM,IACvB,MAAM5K,EAAe4K,EAAI5K,cAAgBrN,KAAKqN,aAE1C4K,EAAIC,WAENlY,KAAKqN,aAAewE,GAAmB,CACrCC,SAAU9R,KAAK0P,aACftC,aAAcpN,KAAKoN,iBAKnB6K,EAAIC,UAAYD,EAAIhL,gBAClBI,EAAarN,KAAKoN,aAAa/I,MAAQgJ,EAAarN,KAAKoN,aAAa/I,KAAK7D,QAC7E6M,EAAarN,KAAKoN,aAAa/I,KAAK+G,SAAQ+B,IAI1C,IAAIgL,EAAmB,KAEnBhL,EAAMjD,GAAG8G,aAAahR,KAAKoN,aAAalI,SAC1CiT,EAAmB,KACV,GAIXhL,EAAM/D,aAAeyI,GAAmB,CACtCC,SAAU3E,EAAMjD,GAChBkD,aAAcpN,KAAKoN,aACnB2E,UAAWoG,EACXnG,mBAAoBiG,EAAIG,yBAOlCb,OAAOU,EAAM,IACX,IAAII,EAAe,GAEdrY,KAAKsX,aAURe,EAAeC,GAAoB,GAAIL,GARnCjY,KAAK8X,kBACP9X,KAAK0P,aAAa4F,gBAAgB/P,GAClC8S,EAAeC,GAAoB3S,EAAwCsS,IAE3EI,EAAeC,GAAoB3S,EAA8BsS,GAQrEjY,KAAKiW,iBAAmB,GAGxBsC,GAAuB,CACrBf,IAAKxX,KACLqN,aAAcrN,KAAKqN,aACnBgL,aAAcA,EACdjL,aAAcpN,KAAKoN,aACnBpE,UAAWhJ,KAAKgJ,YAGlBqO,GAAOmB,aAAa,CAClBhB,IAAKxX,KACLqN,aAAcrN,KAAKqN,aACnBgL,aAAcA,EACdjL,aAAcpN,KAAKoN,aACnBpE,UAAWhJ,KAAKgJ,YAGlBqO,GAAOoB,YAAYzY,KAAKiW,kBAExBjW,KAAKiW,iBAAiBzV,OAAS,SACxBR,KAAKiW,iBACZjW,KAAKsX,cAAe,EAGtBkB,qBAAoBhB,IAClBA,EAAGnK,aACHA,EAAYgL,aACZA,EAAYjL,aACZA,EAAYpE,UACZA,IAEKqE,GAAiBgL,IAMlBA,EAAajD,cAAgB/H,EAAaD,EAAalI,QAAUmI,EAAaD,EAAalI,OAAO1E,QACpG6M,EAAaD,EAAalI,OAAOkG,SAAQ+B,IACvCiI,GAAajI,EAAOnE,EAAWoE,EAAciL,EAAajJ,gBAK1DiJ,EAAaK,aAAerL,EAAaD,EAAanI,OAASoI,EAAaD,EAAanI,MAAMzE,QACjG6M,EAAaD,EAAanI,MAAMmG,SAAQ+B,IAjjC1B,EAACA,EAAOnE,EAAWoE,KAGrC,IAFgBD,EAAM9D,QAGpB,OAGF8D,EAAMrD,YAAcqD,EAAMrD,aAAe,GACzCqD,EAAMrD,YAAYC,kBAAoBoD,EAAMrD,YAAYC,mBAAqB,GAC7E,MAAM4O,EAAaxL,EAAMrD,YAAYC,kBAC/B6O,EAAYzP,EAAsBH,EAAWmE,GAE9C/F,EAAcwR,IAKfpL,KAAKqL,UAAUF,KAAgBnL,KAAKqL,UAAUD,KAKlDzL,EAAMrD,YAAYC,kBAAoB,GAElCvC,EAAcmR,GAChBtO,EAAKuO,GAAW,CAACvN,EAAKnL,KACpBiN,EAAMjD,GAAG4O,aAAazN,EAAKnL,GAE3BiN,EAAMrD,YAAYC,kBAAkBsB,GAAOnL,MAG7CmK,EAAKsO,GAAY,CAACtN,EAAKnL,UACS,IAAnB0Y,EAAUvN,IAEnB8B,EAAMjD,GAAGoL,gBAAgBjK,MAG7BhB,EAAKuO,GAAW,CAACvN,EAAKnL,KAChByY,EAAWtN,KAASuN,EAAUvN,IAEhC8B,EAAMjD,GAAG4O,aAAazN,EAAKuN,EAAUvN,IAIvC8B,EAAMrD,YAAYC,kBAAkBsB,GAAOnL,QAsgCzCwY,CAAYvL,EAAOnE,EAAWoE,EAAciL,EAAajJ,gBAKzDiJ,EAAaU,WAAa1L,EAAaD,EAAajI,KAAOkI,EAAaD,EAAajI,IAAI3E,QAC3F6M,EAAaD,EAAajI,IAAIiG,SAAQ+B,IAhd1B,EAACA,EAAOnE,EAAWoE,KAGnC,IAFgBD,EAAM9D,SAEN8D,EAAMqE,SAA6C,IAAnCrE,EAAM4I,yBACpC,OAGF5I,EAAMrD,YAAcqD,EAAMrD,aAAe,GACzCqD,EAAM6C,KAAO7C,EAAM6C,MAAQ7L,EAAegB,GAC1C,MAAM0E,EAAuBsD,EAAMrD,YAAYkP,mBAEzCA,EAAqB7P,EAAsBH,EAAWmE,KAAU,EAEtE,GAAItD,IAAyBmP,IAAuB7L,EAAM4I,yBACxD,OAGF,MAAMkD,EAAexX,QAAQuX,GAE7B,IAAKC,GAAgB9L,EAAMqE,QAAUrE,EAAMjD,GAAGyB,WAO5C,OAlnCkBzB,EA4mCJiD,EAAMjD,KA3mCZA,EAAGyB,YACXzB,EAAGyB,WAAWc,YAAYvC,QA4mC1B8L,GAAqB,CACnBhN,UAAWA,EACXmE,MAAOA,IAhnCSjD,IAAAA,EAsnCpBiD,EAAMrD,YAAYkP,mBAAqBA,EAIlC7L,EAAMlF,WACT0L,GAAkBxG,EAAOA,EAAMjD,IAC/BiD,EAAMjD,GAAGoL,gBAAgBlI,EAAajI,IACtC4N,GAAyB5F,IAGtB8L,GAKHzD,GAAgB,CACdxC,YAAa7F,EACbnE,UAAWA,EACXoE,aAAcA,IAIZD,EAAMqE,SAAWrE,EAAM4I,0BAEzBC,GAAqB,CACnBhN,UAAWA,EACXmE,MAAOA,KAdX2I,GAAgB3I,IAuaZ4L,CAAU5L,EAAOnE,EAAWoE,EAAciL,EAAajJ,gBAKvDiJ,EAAaa,aAAe7L,EAAaD,EAAarI,OAASsI,EAAaD,EAAarI,MAAMvE,QACjG6M,EAAaD,EAAarI,MAAMqG,SAAQ+B,IA/tC1B,EAACA,EAAOnE,EAAWoE,KAErC,IAAI+L,EAAqB,GACrBC,EAA4B,GAC5BC,GAAa,EAEjB,IALgBlM,EAAM9D,QAMpB,OAGF8D,EAAMrD,YAAcqD,EAAMrD,aAAe,GACzC,MAAMwP,EAAgBnM,EAAMrD,YAAYkP,mBAExC,QAA8C,IAAnC7L,EAAMrD,YAAYyP,mBAA2E,IAApCpM,EAAMrD,YAAY0P,cAIpF,GAHAL,EAAqBhM,EAAMjD,GAAGuP,MAC9BL,EAA4BD,EAAmBO,QAE3CN,EAEFjM,EAAMrD,YAAYyP,aAA6C,SAA9BH,EAAuC,QAAUA,EAClFjM,EAAMrD,YAAY0P,cAAgB,SAC7B,CACL,MAAMG,EAAe5V,OAAO6V,iBAAiBzM,EAAMjD,GAAI,MAAM2P,iBAAiB,WAC9E1M,EAAMrD,YAAYyP,aAAe,KACjCpM,EAAMrD,YAAY0P,cAAgBG,EAItCN,EAAalQ,EAAsBH,EAAWmE,GAG9CkM,EAAa5X,QAAQ4X,GAEjBC,IAAkBD,IAIjBA,EAKClM,EAAMrD,YAAY0P,eAA4C,SAA3BrM,EAAMjD,GAAGuP,MAAMC,QACZ,SAApCvM,EAAMrD,YAAY0P,cAEpBrM,EAAMjD,GAAGuP,MAAMK,YAAY,UAAW,SAGlCX,EAAmB3Y,OAAS,EAC9B2M,EAAMjD,GAAGuP,MAAMM,eAAe,WAE9B5M,EAAMjD,GAAGoL,gBAAgB,SAK7BnI,EAAMjD,GAAGuP,MAAMK,YAAY,UAAW3M,EAAMrD,YAAYyP,cAlB3B,SAA3BpM,EAAMjD,GAAGuP,MAAMC,SACjBvM,EAAMjD,GAAGuP,MAAMK,YAAY,UAAW,QAsB1C3M,EAAMrD,YAAYkP,mBAAqBK,IAmqCjCH,CAAY/L,EAAOnE,EAAWoE,EAAciL,EAAajJ,gBAKzDiJ,EAAa2B,eAAiB3M,EAAaD,EAAahI,SAAWiI,EAAaD,EAAahI,QAAQ5E,QACvG6M,EAAaD,EAAahI,QAAQgG,SAAQ+B,IAtY1B,EAACA,EAAOnE,EAAWoE,KAGvC,IAFgBD,EAAM9D,QAGpB,OAGF8D,EAAMrD,YAAcqD,EAAMrD,aAAe,GACzC,MAAMmQ,EAAgB9Q,EAAsBH,EAAWmE,GAEvD,GAAI8M,IAAkB9M,EAAMrD,YAAYkP,mBAAxC,CAMA,GAFA7L,EAAMrD,YAAYkP,mBAAqBiB,GAElC9M,EAAMiJ,MAAO,CAChB,MAAM8D,EAAmB/M,EAAMjD,GAAGiQ,SAElC,IAAKD,EAAiB1Z,OACpB,OAGF2M,EAAMiJ,MAAQ,GAEd,IAAK,IAAInV,EAAI,EAAGmZ,EAAgBF,EAAiB1Z,OAAQS,EAAImZ,EAAenZ,GAAK,EAAG,CAClF,IAAIqV,EAAW,KAEX4D,EAAiBjZ,GAAG+P,aAAa5D,EAAa/H,MAChDiR,EAAWC,GAAe2D,EAAiBjZ,GAAImM,EAAa/H,MACnD6U,EAAiBjZ,GAAG+P,aAAa5D,EAAa9H,WACvDgR,EAAWC,GAAe2D,EAAiBjZ,GAAImM,EAAa9H,SAC5DgR,EAAS+D,WAAY,GAKnB/D,IACF3C,GAAkB2C,EAAUA,EAASpM,IAEjCoM,EAAS+D,UACX/D,EAASpM,GAAGoL,gBAAgBlI,EAAa9H,SAEzCgR,EAASpM,GAAGoL,gBAAgBlI,EAAa/H,MAG3C0N,GAAyBuD,GACzBnJ,EAAMiJ,MAAMxT,KAAK0T,KAKvB,GAAInJ,EAAMiJ,MAAM5V,OAAQ,CACtB,IAAI8Z,GAAW,EAEf,IAAK,IAAIC,EAAI,EAAGC,EAAcrN,EAAMiJ,MAAM5V,OAAQ+Z,EAAIC,EAAaD,GAAK,EAAG,CACzE,IAAIE,EAOJ,GALItN,EAAMiJ,MAAMmE,GAAGlR,UAEjBoR,EAAetR,EAAsBH,EAAWmE,EAAMiJ,MAAMmE,KAAOpN,EAAMiJ,MAAMmE,GAAGlR,SAGhFoR,IAAiBtN,EAAMrD,YAAYkP,oBAAsB7L,EAAMiJ,MAAMmE,GAAGF,UAAW,CACrFC,GAAW,EAEX9E,GAAgB,CACdxC,YAAa7F,EAAMiJ,MAAMmE,GACzBvR,UAAWA,EACXoE,aAAcA,IAGhB+I,GAAmBhJ,EAAMiJ,MAAOmE,GAChC,OAKCD,GACHnE,GAAmBhJ,EAAMiJ,UAwTvB4D,CAAc7M,EAAOnE,EAAWoE,EAAciL,EAAajJ,gBAK3DiJ,EAAaqC,aAAerN,EAAaD,EAAa9I,OAAS+I,EAAaD,EAAa9I,MAAM9D,QACjG6M,EAAaD,EAAa9I,MAAM8G,SAAQ+B,IAzwC1B,EAACA,EAAOnE,EAAWoE,EAAcgC,KACnD,MAAM/F,EAAU8D,EAAM9D,QAChBmG,EAAMxG,EAAUwG,KAAOxG,EAAUyG,MAAMD,IAE7C,IAAKnG,IAAY+F,IAAgBI,EAAIE,aAAaC,SAASxC,EAAMjD,IAC/D,OAGF,MAAMrH,EAAWsG,EAAsBH,EAAWmE,GAC5CoC,EAAWpC,EAAMjD,GAAGsJ,iBAEF,IAAb3Q,GAAgD,iBAAbA,GAAsC,OAAbA,GACjEA,IAAa0M,IACfpC,EAAMjD,GAAGsJ,YAAc3Q,IA6vCrB6X,CAAYvN,EAAOnE,EAAWoE,EAAciL,EAAajJ,gBAKzDiJ,EAAasC,YAActN,EAAaD,EAAapI,MAAQqI,EAAaD,EAAapI,KAAKxE,QAC9F6M,EAAaD,EAAapI,KAAKoG,SAAQ+B,IAxqC1B,EAACA,EAAOnE,EAAWoE,EAAcgC,KAClD,MAAM/F,EAAU8D,EAAM9D,QAChBmG,EAAMxG,EAAUwG,KAAOxG,EAAUyG,MAAMD,IAE7C,IAAKnG,IAAY+F,IAAgBI,EAAIE,aAAaC,SAASxC,EAAMjD,IAC/D,OAGFiD,EAAMrD,YAAcqD,EAAMrD,aAAe,GACzCqD,EAAMrD,YAAYkP,mBAAqB7L,EAAMrD,YAAYkP,oBAAsB,GAC/E,MAAM4B,EAAazN,EAAMrD,YAAYkP,mBACrC,IAAI6B,EAAa,GACjB,MAAMC,EAAe3R,EAAsBH,EAAWmE,GACtD,IAAI4N,EAAiB,GACjBC,GAAmB,EACnBC,GAAmB,EACnBC,EAAU,GAEd,GAA4B,iBAAjBJ,EACTG,GAAmB,MACd,CAAA,IAAI7T,EAAc0T,GAIvB,OAHAE,GAAmB,EAcrB,GARIA,EACFH,EAAarN,KAAKqL,UAAUiC,IAE5BD,EAAaC,EAAahT,QAAQ,SAAU,KAAKwE,OACjDyO,EAAiBF,EAAW1O,MAAM,MAIhCyO,IAAeC,EACjB,OAIF,MAAMM,EAAahO,EAAMjD,GAAGkR,UAEtBC,EAAmBF,EAAW3a,OAEpC,IAAK,IAAIS,EAAI,EAAGA,EAAIoa,EAAkBpa,GAAK,EACzCia,EAAQtY,KAAKuY,EAAWla,IA1uBH,IAAUqa,EA6uB7BN,EACF3Q,EAAKyQ,GAAc,SAAUS,EAAGhK,GAC9B,MAAMtQ,EAAIia,EAAQhF,QAAQqF,IAEhB,IAANhK,EACF2J,EAAQtY,KAAK2Y,IACG,IAAPta,GACTia,EAAQzJ,OAAOxQ,EAAG,MAGbga,IAvvBsBK,EAyvBKV,EAApCM,EAA2BA,EAxvBd3Q,QAAO,CAACrK,EAAOoK,IACrBgR,EAAWpF,QAAQhW,GAAS,IAwvBnCgb,EAAUA,EAAQjR,OAAO8Q,IAI3BG,EAAUA,EAAQ3Q,QAAO,CAACgH,EAAGtQ,EAAGua,IACvBA,EAAEtF,QAAQ3E,KAAOtQ,IAE1Bia,EAAUA,EAAQO,KAAK,KAEvBtO,EAAMrD,YAAYkP,mBAAqB6B,EAEvC1N,EAAMjD,GAAG4O,aAAa,QAASoC,IAimCzBP,CAAWxN,EAAOnE,EAAWoE,EAAciL,EAAajJ,gBAKxDiJ,EAAaqD,cAAgBrO,EAAaD,EAAatI,QAAUuI,EAAaD,EAAatI,OAAOtE,QACpG6M,EAAaD,EAAatI,OAAOsG,SAAQ+B,IAx0C1B,EAACA,EAAOnE,EAAWoE,EAAcgC,KACpD,MAAM/F,EAAU8D,EAAM9D,QACtB,IAAIxG,EAAW,GACf,MAAM2M,EAAMxG,EAAUwG,KAAOxG,EAAUyG,MAAMD,IAE7C,GAAKnG,IAAY+F,GAAgBI,EAAIE,aAAaC,SAASxC,EAAMjD,OAIjErH,EAAWkG,EAAkBC,EAAWK,GAEpC,MAAOxG,GAA+C,CACxD,MAAMqL,EAAWf,EAAMjD,GACjB6F,EAA+B,aAAlB7B,EAAS8B,KACtB2L,EAA4B,UAAlBzN,EAAS8B,KACnB4L,EAAY1N,EAASwE,KACrBmJ,EAAcF,EAAUnM,EAAIE,aAAaX,iBAAiB,eAAe6M,OAAiB,GAGhG,GAAI/Y,KAFakN,EAAa7B,EAAS+B,QAAU/B,EAAShO,OAGxD,GAAI6P,EACF7B,EAAS+B,QAAUxO,QAAQoB,QACtB,GAAI8Y,EAAS,CAClB,IAAI1a,EAAI,EACR,MAAM6a,EAAmBD,EAAYrb,OAErC,IAAKS,EAAI,EAAGA,EAAI6a,EAAkB7a,GAAK,EACrC,GAAI4a,EAAY5a,GAAGf,QAAU2C,EAAU,CACrCgZ,EAAY5a,GAAGgP,SAAU,EACzB,YAIJ/B,EAAShO,MAAQ2C,IAwyCjB6Y,CAAavO,EAAOnE,EAAWoE,EAAciL,EAAajJ,gBAK1DiJ,EAAalJ,eAAiB9B,EAAaD,EAAaxI,SAAWyI,EAAaD,EAAaxI,QAAQpE,QACvG6M,EAAaD,EAAaxI,QAAQwG,SAAQ+B,IACxCgC,GAAchC,EAAOnE,EAAWoE,EAAciL,EAAajJ,gBAK3DiJ,EAAa0D,eAAiB1O,EAAaD,EAAavI,SAAWwI,EAAaD,EAAavI,QAAQrE,QACvG6M,EAAaD,EAAavI,QAAQuG,SAAQ+B,IACxC6O,GAAmB,CACjB7O,MAAAA,EACAiC,YAAaiJ,EAAajJ,YAC1BY,KAAM,SACNhH,UAAAA,OAMFqP,EAAa4D,cAAgB5O,EAAaD,EAAa7I,QAAU8I,EAAaD,EAAa7I,OAAO/D,QACpG6M,EAAaD,EAAa7I,OAAO6G,SAAQ+B,IACvC6O,GAAmB,CACjB7O,MAAAA,EACAiC,YAAaiJ,EAAajJ,YAC1BY,KAAM,QACNhH,UAAAA,OAMFqP,EAAa6D,iBAAmB7O,EAAaD,EAAa5I,WAAa6I,EAAaD,EAAa5I,UAAUhE,QAC7G6M,EAAaD,EAAa5I,UAAU4G,SAAQ+B,IAC1C6O,GAAmB,CACjB7O,MAAAA,EACAiC,YAAaiJ,EAAajJ,YAC1BY,KAAM,WACNhH,UAAAA,OAMFqP,EAAa8D,aAAe9O,EAAaD,EAAa3I,OAAS4I,EAAaD,EAAa3I,MAAMjE,QACjG6M,EAAaD,EAAa3I,MAAM2G,SAAQ+B,IACtC6O,GAAmB,CACjB7O,MAAAA,EACAiC,YAAaiJ,EAAajJ,YAC1BY,KAAM,OACNhH,UAAAA,OAMFqP,EAAa+D,cAAgB/O,EAAaD,EAAa1I,QAAU2I,EAAaD,EAAa1I,OAAOlE,QACpG6M,EAAaD,EAAa1I,OAAO0G,SAAQ+B,IACvC6O,GAAmB,CACjB7O,MAAAA,EACAiC,YAAaiJ,EAAajJ,YAC1BY,KAAM,QACNhH,UAAAA,OAMFqP,EAAagE,cAAgBhP,EAAaD,EAAazI,QAAU0I,EAAaD,EAAazI,OAAOnE,QACpG6M,EAAaD,EAAazI,OAAOyG,SAAQ+B,IAj/C1B,EAACA,EAAOnE,EAAWoE,EAAcgC,KACpD,MAAMC,EAAclC,EAAM9D,QAC1B,IAAIC,EAAY6D,EAAM5D,WACtB,MAAM+S,EAAgB5W,EAChB6W,EAAiB7W,EACvB,IAAIiE,EACJ,MAAM6F,EAAMxG,EAAUwG,KAAOxG,EAAUyG,MAAMD,IAG7C,GAFArC,EAAMrD,YAAcqD,EAAMrD,aAAe,IAEpCuF,IAAgBD,IAAgBI,EAAIE,aAAaC,SAASxC,EAAMjD,IACnE,OAGF,MAAMsS,EAAWzT,EAAkBC,EAAWqG,GAE9C,GAAImN,GAA+C,mBAA5BA,EAASF,IAAqE,mBAA7BE,EAASD,GAAgC,CAI/G,SAASE,EAAoBtb,GAC3B,MAAMT,EAAO,CAACS,EAAGgM,EAAMjD,IAAID,OAAOX,GAClCkT,EAASF,GAAetZ,MAAM2G,EAAkBjJ,GAGlD,SAASgc,EAAoBvb,GAC3B,MAAMT,EAAO,CAACS,EAAGgM,EAAMjD,IAAID,OAAOX,GAClCkT,EAASD,GAAgBvZ,MAAM2G,EAAkBjJ,GAVnDiJ,EAAmBC,EAAwBZ,EAAWqG,GACtD/F,EAAYA,EAAYU,EAAiBhB,EAAWM,GAAa,GAYjE6D,EAAMjD,GAAGmG,oBAAoB,aAAcoM,GAAqB,GAChEtP,EAAMjD,GAAGmG,oBAAoB,aAAcqM,GAAqB,GAChEvP,EAAMjD,GAAGoG,iBAAiB,aAAcmM,GAAqB,GAC7DtP,EAAMjD,GAAGoG,iBAAiB,aAAcoM,GAAqB,KAk9CzDL,CAAalP,EAAOnE,EAAWoE,EAAciL,EAAajJ,iBAKhEqJ,mBAAmBkE,GACZA,GAAUA,EAAMnc,QAIrB6J,EAAKsS,GAAO,CAACrS,EAAOsS,KAClB,GAAoB,mBAATA,EACT,IACEA,IACA,MAAOjZ,GACP8G,GAAkB9G,EAAK,sBAAwBkZ,OAAOD,QAM9DE,UAAUlG,EAAY,GAAIhV,GAExB,OADA8U,GAAe1W,KAAM4W,EAAWhV,GACzB5B,KAGT+c,cAAcnG,EAAY,GAAIhV,GAE5B,MAlXuB,EAAC+U,EAAW,KAAMC,EAAY,GAAIhV,KAC3D8U,GAAeC,EAAUC,EAAWhV,GAAI,IAgXtCob,CAAmBhd,KAAM4W,EAAWhV,GAC7B5B,KAGTid,YAAYrG,EAAY,IAEtB,OADAM,GAAiBlX,KAAK6W,OAAQD,GACvB5W,KAGTkd,iBAEE,MArVwB,EAACrG,EAAS,MAC/BA,GAIL5P,OAAOkE,KAAKsL,IAAQrL,SAAQwL,IAC1BM,GAAiBL,EAAQD,OA8UzBuG,CAAoBnd,KAAK6W,QAClB7W,KAGTod,QAAQxG,EAAY,MAAOlW,GAEzB,MAhViB,EAACkW,EAAY,MAAOlW,KAClCkW,GAAcH,GAAOG,KAI1BA,EAAYA,EAAU9O,QAAQ7B,EAAmB,IACjDwQ,GAAOG,GAAWxL,SAAQ0L,IACxB7P,OAAOkE,KAAK2L,GAAY1L,SAAQyL,IAC9B,GAAkC,mBAAvBC,EAAWD,GAAwB,CAC5C,MAAMnU,EAAMoU,EAAWD,MAAWnW,GAMlC,OAJIoW,EAAWtF,QACb0F,GAAiBL,EAAQD,GAGpBlU,WAgUX2a,CAAazG,KAAclW,GACpBV,MAKX,MAAMuY,GAAyB,EAC7Bf,IAAAA,EACAnK,aAAAA,EACAgL,aAAAA,EACAjL,aAAAA,EACApE,UAAAA,QAEKqE,IAAiBD,KAKlBC,EAAaD,EAAa/I,MAAQgJ,EAAaD,EAAa/I,KAAK7D,SAG/D6X,EAAaiF,kBAEfjF,EAAeC,GAAoB3S,GACnC0H,EAAaD,EAAa/I,KAAK+G,SAAQ8C,IACrChB,GAAegB,EAAUlF,EAAWoE,EAAcC,MAGpDmK,EAAIQ,mBAAmB,CACrB/K,eAAe,EACfI,aAAcA,EACd+K,qBAAqB,KAKzBC,EAAajJ,aAAc,EAE3B/B,EAAaD,EAAa/I,KAAK+G,SAAQ+B,IACrCkK,GAAOmB,aAAa,CAClBnL,aAAcF,EAAM/D,aACpBiP,aAAcA,EACdjL,aAAcA,EACdpE,UAAWA,SAKV,GAYHsP,GAAsB,CAACiF,EAAY,GAAItF,EAAM,MACjD,MAAMuF,EAAuB,CAC3BF,iBAAiB,EACjB5C,aAAa,EACbC,YAAY,EACZ5B,WAAW,EACXG,aAAa,EACbwC,cAAc,EACdhD,aAAa,EACbtD,cAAc,EACd4E,eAAe,GAEXyD,EAAuB,CAC3BtO,eAAe,EACf8M,cAAc,EACdC,iBAAiB,EACjBC,aAAa,EACbC,cAAc,EACdC,cAAc,EACdN,eAAe,GAIX2B,EAAwB,CAC5BJ,iBAAiB,EACjB5C,aAAa,EACbC,YAAY,EACZ5B,WAAW,EACXG,aAAa,EACbwC,cAAc,EACdhD,aAAa,EACbtD,cAAc,EACd4E,eAAe,GAEjB,IAAI3B,EAAe,GAEnB,OAAQkF,GACN,KAAK5X,EACH0S,EAAezN,EAAO,GAAI6S,EAAsBC,EAAuBzF,GACvE,MAEF,KAAKtS,EAEHsS,EAAIqF,iBAAkB,EACtBjF,EAAezN,EAAO,GAAI4S,EAAsBC,EAAsBxF,GACtE,MAEF,QAEEI,EAAezN,EAAO,GAAI4S,EAAsBvF,GAGpD,OAAOI,GAUHnD,GAAkB,EACtB7H,aAAAA,EACAqH,YAAAA,EACAtH,aAAAA,EACA+H,aAAAA,MAEA,MAAMwI,EAAsBxI,EAAemD,GAAoB3S,GAAgC2S,KAE/FqF,EAAoBvO,aAAc,EAIlCmJ,GAAuB,CACrBf,IAAK9C,EAAYjF,MAAQiF,EAAYjF,MAAMD,IAAMkF,EAAYlF,IAC7DnC,aAAcA,EACdgL,aAAcsF,EACdvQ,aAAcA,EACdpE,UAAW0L,IAEb2C,GAAOmB,aAAa,CAClBnL,aAAcA,EACdgL,aAAcsF,EACdvQ,aAAcA,EACdpE,UAAW0L,KAITsH,GAAqB,EACzB7O,MAAAA,EAAQ,GACRiC,YAAAA,GAAc,EACdY,KAAAA,EAAO,GACPhH,UAAAA,EAAY,OAEZ,MAAMqG,EAAclC,EAAM9D,QAC1B,IACIM,EADAL,EAAY6D,EAAM5D,WAEtB,MAAMiG,EAAMxG,EAAUwG,KAAOxG,EAAUyG,MAAMD,IAE7C,IAAKQ,IAASX,IAAgBD,IAAgBI,EAAIE,aAAaC,SAASxC,EAAMjD,IAC5E,OAGF,MAAM0F,EAAY7G,EAAkBC,EAAWqG,GAE/C,GAAyB,mBAAdO,EAA0B,CACnCjG,EAAmBC,EAAwBZ,EAAWqG,GACtD/F,EAAYA,EAAYU,EAAiBhB,EAAWM,GAAa,GAEjE,MAAMsU,EAAczc,IAClB,IAAI0c,EACAnd,EAAO,GAEE,WAATsP,GACF6N,EA1oEYC,CAAAA,IAClB,MAAMlQ,EAAO,GAEb,OAAKkQ,aAAiBC,iBAIL,IAAIC,SAASF,GACrB1S,SAAQ,CAAClL,EAAOmL,KAClBpE,OAAOrG,UAAU2G,eAAezG,KAAKmG,OAAQoE,IAK7C1K,MAAMqF,QAAQ4H,EAAKvC,MACtBuC,EAAKvC,GAAO,CAACuC,EAAKvC,KAGpBuC,EAAKvC,GAAKzI,KAAK1C,IARb0N,EAAKvC,GAAOnL,KANP0N,GAsoEQqQ,CAAY9c,EAAEiP,eACzB1P,EAAO,CAACS,EAAGA,EAAEiP,cAAeyN,GAAU5T,OAAOX,IAE7C5I,EAAO,CAACS,EAAGA,EAAEiP,eAAenG,OAAOX,GAGrCsG,EAAU5M,MAAM2G,EAAkBjJ,IAGpCyM,EAAMjD,GAAGmG,oBAAoBL,EAAM4N,GAAa,GAChDzQ,EAAMjD,GAAGoG,iBAAiBN,EAAM4N,GAAa,KAIjD,IAAIxQ,GAAejJ,EACf+Z,GA33EuB,CACzBC,SAAU,kBACVC,YAAa,kBACblO,OAAQ,kBA04EVnM,OAAOsa,SAAW,CAChBC,IAjBU,CAAChR,EAAW,MAClBA,EAASF,eACXA,GAAexC,EAAO,GAAI0C,EAASF,eAGjCE,EAAS4Q,mBACXA,GAAmBtT,EAAO,GAAI0C,EAAS4Q,oBAYzCK,KARW,CAAC7O,EAAc1G,EAAY,QACtClD,EAAEoY,iBAAmBA,GACd,IAAI7G,GAAO3H,EAAc1G,EAAWoE,KAO3CoR,QAAS,aAvxFb","file":"dataBind.min.js","sourcesContent":["/**\n * dataBind\n * version 1.9.0\n * By Adam Chow\n * link https://gogocat.github.io/dataBind/\n * license MIT\n * \n */\n\n(function () {\n  'use strict';\n\n  /**\n   * @this {Promise}\n   */\n  function finallyConstructor(callback) {\n    var constructor = this.constructor;\n    return this.then(function (value) {\n      // @ts-ignore\n      return constructor.resolve(callback()).then(function () {\n        return value;\n      });\n    }, function (reason) {\n      // @ts-ignore\n      return constructor.resolve(callback()).then(function () {\n        // @ts-ignore\n        return constructor.reject(reason);\n      });\n    });\n  }\n\n  function allSettled(arr) {\n    var P = this;\n    return new P(function (resolve, reject) {\n      if (!(arr && typeof arr.length !== 'undefined')) {\n        return reject(new TypeError(typeof arr + ' ' + arr + ' is not iterable(cannot read property Symbol(Symbol.iterator))'));\n      }\n\n      var args = Array.prototype.slice.call(arr);\n      if (args.length === 0) return resolve([]);\n      var remaining = args.length;\n\n      function res(i, val) {\n        if (val && (typeof val === 'object' || typeof val === 'function')) {\n          var then = val.then;\n\n          if (typeof then === 'function') {\n            then.call(val, function (val) {\n              res(i, val);\n            }, function (e) {\n              args[i] = {\n                status: 'rejected',\n                reason: e\n              };\n\n              if (--remaining === 0) {\n                resolve(args);\n              }\n            });\n            return;\n          }\n        }\n\n        args[i] = {\n          status: 'fulfilled',\n          value: val\n        };\n\n        if (--remaining === 0) {\n          resolve(args);\n        }\n      }\n\n      for (var i = 0; i < args.length; i++) {\n        res(i, args[i]);\n      }\n    });\n  }\n\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n\n  var setTimeoutFunc = setTimeout;\n\n  function isArray$1(x) {\n    return Boolean(x && typeof x.length !== 'undefined');\n  }\n\n  function noop() {} // Polyfill for Function.prototype.bind\n\n\n  function bind(fn, thisArg) {\n    return function () {\n      fn.apply(thisArg, arguments);\n    };\n  }\n  /**\n   * @constructor\n   * @param {Function} fn\n   */\n\n\n  function Promise$1(fn) {\n    if (!(this instanceof Promise$1)) throw new TypeError('Promises must be constructed via new');\n    if (typeof fn !== 'function') throw new TypeError('not a function');\n    /** @type {!number} */\n\n    this._state = 0;\n    /** @type {!boolean} */\n\n    this._handled = false;\n    /** @type {Promise|undefined} */\n\n    this._value = undefined;\n    /** @type {!Array<!Function>} */\n\n    this._deferreds = [];\n    doResolve(fn, this);\n  }\n\n  function handle(self, deferred) {\n    while (self._state === 3) {\n      self = self._value;\n    }\n\n    if (self._state === 0) {\n      self._deferreds.push(deferred);\n\n      return;\n    }\n\n    self._handled = true;\n\n    Promise$1._immediateFn(function () {\n      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n\n      if (cb === null) {\n        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n        return;\n      }\n\n      var ret;\n\n      try {\n        ret = cb(self._value);\n      } catch (e) {\n        reject(deferred.promise, e);\n        return;\n      }\n\n      resolve(deferred.promise, ret);\n    });\n  }\n\n  function resolve(self, newValue) {\n    try {\n      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');\n\n      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        var then = newValue.then;\n\n        if (newValue instanceof Promise$1) {\n          self._state = 3;\n          self._value = newValue;\n          finale(self);\n          return;\n        } else if (typeof then === 'function') {\n          doResolve(bind(then, newValue), self);\n          return;\n        }\n      }\n\n      self._state = 1;\n      self._value = newValue;\n      finale(self);\n    } catch (e) {\n      reject(self, e);\n    }\n  }\n\n  function reject(self, newValue) {\n    self._state = 2;\n    self._value = newValue;\n    finale(self);\n  }\n\n  function finale(self) {\n    if (self._state === 2 && self._deferreds.length === 0) {\n      Promise$1._immediateFn(function () {\n        if (!self._handled) {\n          Promise$1._unhandledRejectionFn(self._value);\n        }\n      });\n    }\n\n    for (var i = 0, len = self._deferreds.length; i < len; i++) {\n      handle(self, self._deferreds[i]);\n    }\n\n    self._deferreds = null;\n  }\n  /**\n   * @constructor\n   */\n\n\n  function Handler(onFulfilled, onRejected, promise) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.promise = promise;\n  }\n  /**\n   * Take a potentially misbehaving resolver function and make sure\n   * onFulfilled and onRejected are only called once.\n   *\n   * Makes no guarantees about asynchrony.\n   */\n\n\n  function doResolve(fn, self) {\n    var done = false;\n\n    try {\n      fn(function (value) {\n        if (done) return;\n        done = true;\n        resolve(self, value);\n      }, function (reason) {\n        if (done) return;\n        done = true;\n        reject(self, reason);\n      });\n    } catch (ex) {\n      if (done) return;\n      done = true;\n      reject(self, ex);\n    }\n  }\n\n  Promise$1.prototype['catch'] = function (onRejected) {\n    return this.then(null, onRejected);\n  };\n\n  Promise$1.prototype.then = function (onFulfilled, onRejected) {\n    // @ts-ignore\n    var prom = new this.constructor(noop);\n    handle(this, new Handler(onFulfilled, onRejected, prom));\n    return prom;\n  };\n\n  Promise$1.prototype['finally'] = finallyConstructor;\n\n  Promise$1.all = function (arr) {\n    return new Promise$1(function (resolve, reject) {\n      if (!isArray$1(arr)) {\n        return reject(new TypeError('Promise.all accepts an array'));\n      }\n\n      var args = Array.prototype.slice.call(arr);\n      if (args.length === 0) return resolve([]);\n      var remaining = args.length;\n\n      function res(i, val) {\n        try {\n          if (val && (typeof val === 'object' || typeof val === 'function')) {\n            var then = val.then;\n\n            if (typeof then === 'function') {\n              then.call(val, function (val) {\n                res(i, val);\n              }, reject);\n              return;\n            }\n          }\n\n          args[i] = val;\n\n          if (--remaining === 0) {\n            resolve(args);\n          }\n        } catch (ex) {\n          reject(ex);\n        }\n      }\n\n      for (var i = 0; i < args.length; i++) {\n        res(i, args[i]);\n      }\n    });\n  };\n\n  Promise$1.allSettled = allSettled;\n\n  Promise$1.resolve = function (value) {\n    if (value && typeof value === 'object' && value.constructor === Promise$1) {\n      return value;\n    }\n\n    return new Promise$1(function (resolve) {\n      resolve(value);\n    });\n  };\n\n  Promise$1.reject = function (value) {\n    return new Promise$1(function (resolve, reject) {\n      reject(value);\n    });\n  };\n\n  Promise$1.race = function (arr) {\n    return new Promise$1(function (resolve, reject) {\n      if (!isArray$1(arr)) {\n        return reject(new TypeError('Promise.race accepts an array'));\n      }\n\n      for (var i = 0, len = arr.length; i < len; i++) {\n        Promise$1.resolve(arr[i]).then(resolve, reject);\n      }\n    });\n  }; // Use polyfill for setImmediate for performance gains\n\n\n  Promise$1._immediateFn = // @ts-ignore\n  typeof setImmediate === 'function' && function (fn) {\n    // @ts-ignore\n    setImmediate(fn);\n  } || function (fn) {\n    setTimeoutFunc(fn, 0);\n  };\n\n  Promise$1._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n    if (typeof console !== 'undefined' && console) {\n      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n    }\n  };\n\n  /** @suppress {undefinedVars} */\n\n  var globalNS = function () {\n    // the only reliable means to get the global object is\n    // `Function('return this')()`\n    // However, this causes CSP violations in Chrome apps.\n    if (typeof self !== 'undefined') {\n      return self;\n    }\n\n    if (typeof window !== 'undefined') {\n      return window;\n    }\n\n    if (typeof global !== 'undefined') {\n      return global;\n    }\n\n    throw new Error('unable to locate global object');\n  }(); // Expose the polyfill if Promise is undefined or set to a\n  // non-function value. The latter can be due to a named HTMLElement\n  // being exposed by browsers for legacy reasons.\n  // https://github.com/taylorhakes/promise-polyfill/issues/114\n\n\n  if (typeof globalNS['Promise'] !== 'function') {\n    globalNS['Promise'] = Promise$1;\n  } else if (!globalNS.Promise.prototype['finally']) {\n    globalNS.Promise.prototype['finally'] = finallyConstructor;\n  } else if (!globalNS.Promise.allSettled) {\n    globalNS.Promise.allSettled = allSettled;\n  }\n\n  const bindingAttrs$1 = {\n    comp: 'data-jq-comp',\n    tmp: 'data-jq-tmp',\n    text: 'data-jq-text',\n    click: 'data-jq-click',\n    dblclick: 'data-jq-dblclick',\n    blur: 'data-jq-blur',\n    focus: 'data-jq-focus',\n    hover: 'data-jq-hover',\n    change: 'data-jq-change',\n    submit: 'data-jq-submit',\n    model: 'data-jq-model',\n    show: 'data-jq-show',\n    css: 'data-jq-css',\n    attr: 'data-jq-attr',\n    forOf: 'data-jq-for',\n    if: 'data-jq-if',\n    switch: 'data-jq-switch',\n    case: 'data-jq-case',\n    default: 'data-jq-default'\n  };\n  const serverRenderedAttr = 'data-server-rendered';\n  const dataIndexAttr = 'data-index';\n  const commentPrefix = {\n    forOf: 'data-forOf_',\n    if: 'data-if_',\n    case: 'data-case_',\n    default: 'data-default_'\n  };\n  const commentSuffix = '_end'; // global setting of underscore template inteprolate default token\n\n  const templateSettings$1 = {\n    evaluate: /<%([\\s\\S]+?)%>/g,\n    interpolate: /\\{\\{=(.+?)\\}\\}/g,\n    escape: /\\{\\{(.+?)\\}\\}/g\n  };\n  const bindingDataReference = {\n    rootDataKey: '$root',\n    currentData: '$data',\n    currentIndex: '$index',\n    mouseEnterHandlerName: 'in',\n    mouseLeaveHandlerName: 'out'\n  };\n  const bindingUpdateConditions = {\n    serverRendered: 'SERVER-RENDERED',\n    init: 'INIT'\n  }; // maximum string length before running regex\n\n  const maxDatakeyLength = 50;\n  const constants = {\n    filters: {\n      ONCE: 'once'\n    },\n    PARENT_REF: '_parent'\n  };\n\n  _ = window._ || {};\n  const hasIsArray = Array.isArray;\n  const REGEX = {\n    FUNCTIONPARAM: /\\((.*?)\\)/,\n    WHITESPACES: /\\s+/g,\n    FOROF: /(.*?)\\s+(?:in|of)\\s+(.*)/,\n    PIPE: /\\|/,\n    HTML_TAG: /^[\\s]*<([a-z][^\\/\\s>]+)/i,\n    BAG_TAGS: /<(script|del)(?=[\\s>])[\\w\\W]*?<\\/\\1\\s*>/ig\n  };\n  const IS_SUPPORT_TEMPLATE = ('content' in document.createElement('template'));\n  const WRAP_MAP = {\n    div: ['div', '<div>', '</div>'],\n    thead: ['table', '<table>', '</table>'],\n    col: ['colgroup', '<table><colgroup>', '</colgroup></table>'],\n    tr: ['tbody', '<table><tbody>', '</tbody></table>'],\n    td: ['tr', '<table><tr>', '</tr></table>']\n  };\n  WRAP_MAP.caption = WRAP_MAP.colgroup = WRAP_MAP.tbody = WRAP_MAP.tfoot = WRAP_MAP.thead;\n  WRAP_MAP.th = WRAP_MAP.td;\n\n  const isArray = obj => {\n    return hasIsArray ? Array.isArray(obj) : Object.prototype.toString.call(obj) === '[object Array]';\n  };\n\n  const isJsObject = obj => {\n    return obj !== null && typeof obj === 'object' && Object.prototype.toString.call(obj) === '[object Object]';\n  };\n\n  const isPlainObject = obj => {\n    if (!isJsObject(obj)) {\n      return false;\n    } // If has modified constructor\n\n\n    const ctor = obj.constructor;\n    if (typeof ctor !== 'function') return false; // If has modified prototype\n\n    const prot = ctor.prototype;\n    if (isJsObject(prot) === false) return false; // If constructor does not have an Object-specific method\n\n    if (prot.hasOwnProperty('isPrototypeOf') === false) {\n      return false;\n    } // Most likely a plain Object\n\n\n    return true;\n  };\n\n  const isEmptyObject = obj => {\n    if (isJsObject(obj)) {\n      return Object.getOwnPropertyNames(obj).length === 0;\n    }\n\n    return false;\n  };\n\n  function getFirstHtmlStringTag(htmlString) {\n    const match = htmlString.match(REGEX.HTML_TAG);\n\n    if (match) {\n      return match[1];\n    }\n\n    return null;\n  }\n\n  function removeBadTags(htmlString = '') {\n    return htmlString.replace(REGEX.BAG_TAGS, '');\n  }\n\n  function createHtmlFragment(htmlString) {\n    if (typeof htmlString !== 'string') {\n      return null;\n    } // use template element\n\n\n    if (IS_SUPPORT_TEMPLATE) {\n      const template = document.createElement('template');\n      template.innerHTML = removeBadTags(htmlString);\n      return template.content;\n    } // use document fragment with wrap html tag for tr, td etc.\n\n\n    const fragment = document.createDocumentFragment();\n    const queryContainer = document.createElement('div');\n    const firstTag = getFirstHtmlStringTag(htmlString);\n    const wrap = WRAP_MAP[firstTag || 'div'];\n\n    if (wrap[0] === 'div') {\n      return document.createRange().createContextualFragment(htmlString);\n    }\n\n    queryContainer.insertAdjacentHTML('beforeend', `${wrap[1]}${htmlString}${wrap[2]}`);\n    const query = queryContainer.querySelector(wrap[0]);\n\n    while (query.firstChild) {\n      fragment.appendChild(query.firstChild);\n    }\n\n    return fragment;\n  }\n  /**\r\n   * getViewModelValue\r\n   * @description walk a object by provided string path. eg 'a.b.c'\r\n   * @param {object} viewModel\r\n   * @param {string} prop\r\n   * @return {object}\r\n   */\n\n\n  const getViewModelValue = (viewModel, prop) => {\n    return _.get(viewModel, prop);\n  };\n  /**\r\n   * setViewModelValue\r\n   * @description populate viewModel object by path string\r\n   * @param {object} obj\r\n   * @param {string} prop\r\n   * @param {string} value\r\n   * @return {call} underscore set\r\n   */\n\n\n  const setViewModelValue = (obj, prop, value) => {\n    return _.set(obj, prop, value);\n  };\n\n  const getViewModelPropValue = (viewModel, bindingCache) => {\n    let dataKey = bindingCache.dataKey;\n    let paramList = bindingCache.parameters;\n    const isInvertBoolean = dataKey.charAt(0) === '!';\n\n    if (isInvertBoolean) {\n      dataKey = isInvertBoolean ? dataKey.substring(1) : dataKey;\n    }\n\n    let ret = getViewModelValue(viewModel, dataKey);\n\n    if (typeof ret === 'function') {\n      const viewModelContext = resolveViewModelContext(viewModel, dataKey);\n      const oldViewModelProValue = bindingCache.elementData ? bindingCache.elementData.viewModelProValue : null;\n      paramList = paramList ? resolveParamList(viewModel, paramList) : []; // let args = [oldViewModelProValue, bindingCache.el].concat(paramList);\n\n      const args = paramList.concat([oldViewModelProValue, bindingCache.el]);\n      ret = ret.apply(viewModelContext, args);\n    }\n\n    ret = isInvertBoolean ? !Boolean(ret) : ret; // call through fitlers to get final value\n\n    ret = filtersViewModelPropValue({\n      value: ret,\n      viewModel: viewModel,\n      bindingCache: bindingCache\n    });\n    return ret;\n  };\n\n  const filtersViewModelPropValue = ({\n    value,\n    viewModel,\n    bindingCache\n  }) => {\n    let ret = value;\n\n    if (bindingCache.filters) {\n      each(bindingCache.filters, (index, filter) => {\n        const viewModelContext = resolveViewModelContext(viewModel, filter);\n        const filterFn = getViewModelValue.call(viewModelContext, viewModelContext, filter);\n\n        try {\n          ret = filterFn.call(viewModelContext, ret);\n        } catch (err) {\n          throwErrorMessage(err, `Invalid filter: ${filter}`);\n        }\n      });\n    }\n\n    return ret;\n  };\n\n  const parseStringToJson = str => {\n    // fix unquote or single quote keys and replace single quote to double quote\n    const ret = str.replace(/(\\s*?{\\s*?|\\s*?,\\s*?)(['\"])?([a-zA-Z0-9]+)(['\"])?:/g, '$1\"$3\":').replace(/'/g, '\"');\n    return JSON.parse(ret);\n  };\n  /**\r\n   * arrayRemoveMatch\r\n   * @description remove match items in fromArray out of toArray\r\n   * @param {array} toArray\r\n   * @param {array} frommArray\r\n   * @return {boolean}\r\n   */\n\n\n  const arrayRemoveMatch = (toArray, frommArray) => {\n    return toArray.filter((value, index) => {\n      return frommArray.indexOf(value) < 0;\n    });\n  };\n\n  const getFormData = $form => {\n    const data = {};\n\n    if (!$form instanceof HTMLFormElement) {\n      return data;\n    }\n\n    const formData = new FormData($form);\n    formData.forEach((value, key) => {\n      if (!Object.prototype.hasOwnProperty.call(Object, key)) {\n        data[key] = value;\n        return;\n      }\n\n      if (!Array.isArray(data[key])) {\n        data[key] = [data[key]];\n      }\n\n      data[key].push(value);\n    });\n    return data;\n  };\n  /**\r\n   * getFunctionParameterList\r\n   * @description convert parameter string to arrary\r\n   * eg. '(\"a\",\"b\",\"c\")' > [\"a\",\"b\",\"c\"]\r\n   * @param {string} str\r\n   * @return {array} paramlist\r\n   */\n\n\n  const getFunctionParameterList = str => {\n    if (!str || str.length > maxDatakeyLength) {\n      return;\n    }\n\n    let paramlist = str.match(REGEX.FUNCTIONPARAM);\n\n    if (paramlist && paramlist[1]) {\n      paramlist = paramlist[1].split(',');\n      paramlist.forEach(function (v, i) {\n        paramlist[i] = v.trim();\n      });\n    }\n\n    return paramlist;\n  };\n\n  const extractFilterList = cacheData => {\n    if (!cacheData || !cacheData.dataKey || cacheData.dataKey.length > maxDatakeyLength) {\n      return cacheData;\n    }\n\n    const filterList = cacheData.dataKey.split(REGEX.PIPE);\n    let isOnceIndex;\n    cacheData.dataKey = filterList[0].trim();\n\n    if (filterList.length > 1) {\n      filterList.shift(0);\n      filterList.forEach(function (v, i) {\n        filterList[i] = v.trim();\n\n        if (filterList[i] === constants.filters.ONCE) {\n          cacheData.isOnce = true;\n          isOnceIndex = i;\n        }\n      }); // don't store filter 'once' - because it is internal logic not a property from viewModel\n\n      if (isOnceIndex >= 0) {\n        filterList.splice(isOnceIndex, 1);\n      }\n\n      cacheData.filters = filterList;\n    }\n\n    return cacheData;\n  };\n\n  const invertObj = sourceObj => {\n    return Object.keys(sourceObj).reduce(function (obj, key) {\n      obj[sourceObj[key]] = key;\n      return obj;\n    }, {});\n  };\n\n  const createDeferredObj = () => {\n    const dfObj = {};\n    dfObj.promise = new Promise((resolve, reject) => {\n      dfObj.resolve = resolve;\n      dfObj.reject = reject;\n    });\n    return dfObj;\n  };\n  /**\r\n   * debounce\r\n   * @description decorate a function to be debounce using requestAnimationFrame\r\n   * @param {function} fn\r\n   * @param {context} ctx\r\n   * @return {function}\r\n   */\n\n\n  const debounceRaf = (fn, ctx = null) => {\n    return function (fn, ctx) {\n      let dfObj = createDeferredObj();\n      let rafId = 0; // return decorated fn\n\n      return function () {\n        /* eslint-disable prefer-rest-params */\n        const args = Array.from ? Array.from(arguments) : Array.prototype.slice.call(arguments);\n        window.cancelAnimationFrame(rafId);\n        rafId = window.requestAnimationFrame(() => {\n          try {\n            // fn is Binder.render function\n            fn.apply(ctx, args); // dfObj.resolve is function provided in .then promise chain\n            // ctx is the current component\n\n            dfObj.resolve(ctx);\n          } catch (err) {\n            console.error('error in rendering: ', err);\n            dfObj.reject(err);\n          } // reset dfObj - otherwise then callbacks will not be in execution order\n          // example:\n          // myApp.render().then(function(){console.log('ok1')});\n          // myApp.render().then(function(){console.log('ok2')});\n          // myApp.render().then(function(){console.log('ok3')});\n          // >> ok1, ok2, ok3\n\n\n          dfObj = createDeferredObj();\n          window.cancelAnimationFrame(rafId);\n        });\n        return dfObj.promise;\n      };\n    }(fn, ctx);\n  };\n  /**\r\n   * extend\r\n   * @param {boolean} isDeepMerge\r\n   * @param {object} target\r\n   * @param {object} sources\r\n   * @return {object} merged object\r\n   */\n\n\n  const extend = (isDeepMerge = false, target, ...sources) => {\n    if (!sources.length) {\n      return target;\n    }\n\n    const source = sources.shift();\n\n    if (source === undefined) {\n      return target;\n    }\n\n    if (!isDeepMerge) {\n      return Object.assign(target, ...sources);\n    }\n\n    if (isMergebleObject(target) && isMergebleObject(source)) {\n      Object.keys(source).forEach(key => {\n        if (isMergebleObject(source[key])) {\n          if (!target[key]) {\n            target[key] = {};\n          }\n\n          extend(target[key], source[key]);\n        } else {\n          target[key] = source[key];\n        }\n      });\n    }\n\n    return extend(true, target, ...sources);\n  };\n\n  const each = (obj, fn) => {\n    if (typeof obj !== 'object' || typeof fn !== 'function') {\n      return;\n    }\n\n    let keys = [];\n    let keysLength = 0;\n    const isArrayObj = isArray(obj);\n    let key;\n    let value;\n    let i = 0;\n\n    if (isArrayObj) {\n      keysLength = obj.length;\n    } else if (isJsObject(obj)) {\n      keys = Object.keys(obj);\n      keysLength = keys.length;\n    } else {\n      throw new TypeError('Object is not an array or object');\n    }\n\n    for (i = 0; i < keysLength; i += 1) {\n      if (isArrayObj) {\n        key = i;\n        value = obj[i];\n      } else {\n        key = keys[i];\n        value = obj[key];\n      }\n\n      fn(key, value);\n    }\n  };\n\n  const isMergebleObject = item => {\n    return isJsObject(item) && !isArray(item);\n  };\n  /**\r\n   * cloneDomNode\r\n   * @param {object} element\r\n   * @return {object} cloned element\r\n   * @description helper function to clone node\r\n   */\n\n\n  const cloneDomNode = element => {\n    return element.cloneNode(true);\n  };\n  /**\r\n   * insertAfter\r\n   * @param {object} parentNode\r\n   * @param {object} newNode\r\n   * @param {object} referenceNode\r\n   * @return {object} node\r\n   * @description helper function to insert new node before the reference node\r\n   */\n\n\n  const insertAfter = (parentNode, newNode, referenceNode) => {\n    const refNextElement = referenceNode && referenceNode.nextSibling ? referenceNode.nextSibling : null;\n    return parentNode.insertBefore(newNode, refNextElement);\n  };\n\n  const resolveViewModelContext = (viewModel, datakey) => {\n    let ret = viewModel;\n\n    if (typeof datakey !== 'string') {\n      return ret;\n    }\n\n    const bindingDataContext = datakey.split('.');\n\n    if (bindingDataContext.length > 1) {\n      if (bindingDataContext[0] === bindingDataReference.rootDataKey) {\n        ret = viewModel[bindingDataReference.rootDataKey] || viewModel;\n      } else if (bindingDataContext[0] === bindingDataReference.currentData) {\n        ret = viewModel[bindingDataReference.currentData] || viewModel;\n      }\n    }\n\n    return ret;\n  };\n\n  const resolveParamList = (viewModel, paramList) => {\n    if (!viewModel || !isArray(paramList)) {\n      return;\n    }\n\n    return paramList.map(param => {\n      param = param.trim();\n\n      if (param === bindingDataReference.currentIndex) {\n        // convert '$index' to value\n        param = viewModel[bindingDataReference.currentIndex];\n      } else if (param === bindingDataReference.currentData) {\n        // convert '$data' to value or current viewModel\n        param = viewModel[bindingDataReference.currentData] || viewModel;\n      } else if (param === bindingDataReference.rootDataKey) {\n        // convert '$root' to root viewModel\n        param = viewModel[bindingDataReference.rootDataKey] || viewModel;\n      }\n\n      return param;\n    });\n  };\n\n  const removeElement = el => {\n    if (el && el.parentNode) {\n      el.parentNode.removeChild(el);\n    }\n  };\n\n  const emptyElement = node => {\n    if (node && node.firstChild) {\n      while (node.firstChild) {\n        node.removeChild(node.firstChild);\n      }\n    }\n\n    return node;\n  };\n\n  const throwErrorMessage = (err = null, errorMessage = '') => {\n    const message = err && err.message ? err.message : errorMessage;\n\n    if (typeof console.error === 'function') {\n      return console.error(message);\n    }\n\n    return console.log(message);\n  };\n\n  let $domFragment = null;\n  let $templateRoot = null;\n  let nestTemplatesCount = 0;\n  const templateCache = {};\n  /**\n   * compileTemplate\n   * @description compile underscore template and store in templateCache\n   * @param {string} id\n   * @param {object} templateData\n   * @return {string} rendered html string\n   */\n\n  const compileTemplate = (id, templateData = null) => {\n    let templateString;\n    let templateElement;\n\n    if (!templateCache[id]) {\n      templateElement = document.getElementById(id);\n      templateString = templateElement ? templateElement.innerHTML : '';\n      templateCache[id] = _.template(templateString, {\n        variable: 'data'\n      });\n    }\n\n    return templateCache[id](templateData);\n  };\n  /**\n   * renderTemplate\n   * @description\n   * get template setting from DOM attribute then call compileTemplate\n   * to render and append to target DOM\n   * @param {object} cache\n   * @param {object} viewModel\n   * @param {object} bindingAttrs\n   * @param {object} elementCache\n   */\n\n\n  const renderTemplate = (cache, viewModel, bindingAttrs, elementCache) => {\n    const settings = typeof cache.dataKey === 'string' ? parseStringToJson(cache.dataKey) : cache.dataKey;\n    let viewData = settings.data;\n    const isAppend = settings.append;\n    const isPrepend = settings.prepend;\n    let $currentElement;\n    cache.dataKey = settings;\n    viewData = typeof viewData === 'undefined' || viewData === '$root' ? viewModel : getViewModelPropValue(viewModel, {\n      dataKey: settings.data,\n      parameters: cache.parameters\n    });\n\n    if (!viewData) {\n      return;\n    }\n\n    const $element = cache.el;\n    const $index = typeof viewModel.$index !== 'undefined' ? viewModel.$index : $element.getAttribute(dataIndexAttr);\n\n    if (typeof $index !== 'undefined') {\n      viewData.$index = $index;\n    }\n\n    $domFragment = $domFragment || document.createDocumentFragment();\n    $templateRoot = $templateRoot || $element;\n    const htmlString = compileTemplate(settings.id, viewData);\n    const htmlFragment = createHtmlFragment(htmlString); // append rendered html\n\n    if (!$domFragment.childNodes.length) {\n      // domFragment should be empty in first run\n      $currentElement = $domFragment; // copy of $domFragment for later find nested template check\n\n      $domFragment.appendChild(htmlFragment);\n    } else {\n      // during recursive run keep append to current fragment\n      $currentElement = $element; // reset to current nested template element\n\n      if (!isAppend && !isPrepend) {\n        $currentElement = emptyElement($currentElement);\n      }\n\n      if (isPrepend) {\n        $currentElement.insertBefore(htmlFragment, $currentElement.firstChild);\n      } else {\n        $currentElement.appendChild(htmlFragment);\n      }\n    } // check if there are nested template then recurisive render them\n\n\n    const $nestedTemplates = $currentElement.querySelectorAll('[' + bindingAttrs.tmp + ']');\n    const nestedTemplatesLength = $nestedTemplates.length;\n\n    if (nestedTemplatesLength) {\n      nestTemplatesCount += nestedTemplatesLength;\n\n      for (let i = 0; i < nestedTemplatesLength; i += 1) {\n        const thisTemplateCache = {\n          el: $nestedTemplates[i],\n          dataKey: $nestedTemplates[i].getAttribute(bindingAttrs.tmp)\n        };\n        elementCache[bindingAttrs.tmp].push(thisTemplateCache); // recursive template render\n\n        renderTemplate(thisTemplateCache, viewModel, bindingAttrs, elementCache);\n        nestTemplatesCount -= 1;\n      }\n    } // no more nested tempalted to render, start to append $domFragment into $templateRoot\n\n\n    if (nestTemplatesCount === 0) {\n      // append to DOM once\n      if (!isAppend && !isPrepend) {\n        $templateRoot = emptyElement($templateRoot);\n      }\n\n      if (isPrepend) {\n        $templateRoot.insertBefore($domFragment, $templateRoot.firstChild);\n      } else {\n        $templateRoot.appendChild($domFragment);\n      } // clear cached fragment\n\n\n      $domFragment = $templateRoot = null; // trigger callback if provided\n\n      if (typeof viewModel.afterTemplateRender === 'function') {\n        viewModel.afterTemplateRender(viewData);\n      }\n    }\n  };\n\n  /* eslint-disable no-invalid-this */\n  /**\r\n   * blurBinding\r\n   * DOM decleartive on blur event binding\r\n   * event handler bind to viewModel method according to the DOM attribute\r\n   * @param {object} cache\r\n   * @param {object} viewModel\r\n   * @param {object} bindingAttrs\r\n   * @param {boolean} forceRender\r\n   */\n\n  const hoverBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n    const handlerName = cache.dataKey;\n    let paramList = cache.parameters;\n    const inHandlerName = bindingDataReference.mouseEnterHandlerName;\n    const outHandlerName = bindingDataReference.mouseLeaveHandlerName;\n    let viewModelContext;\n    const APP = viewModel.APP || viewModel.$root.APP;\n    cache.elementData = cache.elementData || {}; // TODO: check what is APP.$rootElement.contains(cache.el)\n\n    if (!handlerName || !forceRender && !APP.$rootElement.contains(cache.el)) {\n      return;\n    }\n\n    const handlers = getViewModelValue(viewModel, handlerName);\n\n    if (handlers && typeof handlers[inHandlerName] === 'function' && typeof handlers[outHandlerName] === 'function') {\n      viewModelContext = resolveViewModelContext(viewModel, handlerName);\n      paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n\n      function onMouseEnterHandler(e) {\n        const args = [e, cache.el].concat(paramList);\n        handlers[inHandlerName].apply(viewModelContext, args);\n      }\n\n      function onMouseLeaveHandler(e) {\n        const args = [e, cache.el].concat(paramList);\n        handlers[outHandlerName].apply(viewModelContext, args);\n      }\n\n      cache.el.removeEventListener('mouseenter', onMouseEnterHandler, false);\n      cache.el.removeEventListener('mouseleave', onMouseLeaveHandler, false);\n      cache.el.addEventListener('mouseenter', onMouseEnterHandler, false);\n      cache.el.addEventListener('mouseleave', onMouseLeaveHandler, false);\n    }\n  };\n\n  /* eslint-disable no-invalid-this */\n  /**\n   * changeBinding\n   * @description input element on change event binding. DOM -> viewModel update\n   * @param {object} cache\n   * @param {object} viewModel\n   * @param {object} bindingAttrs\n   * @param {boolean} forceRender\n   */\n\n  const changeBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n    const handlerName = cache.dataKey;\n    let paramList = cache.parameters;\n    const modelDataKey = cache.el.getAttribute(bindingAttrs.model);\n    let newValue = '';\n    let oldValue = '';\n    let viewModelContext;\n    const APP = viewModel.APP || viewModel.$root.APP;\n\n    if (!handlerName || !forceRender && !APP.$rootElement.contains(cache.el)) {\n      return;\n    }\n\n    const handlerFn = getViewModelValue(viewModel, handlerName);\n\n    if (typeof handlerFn === 'function') {\n      viewModelContext = resolveViewModelContext(viewModel, handlerName);\n      paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n\n      function changeHandler(e) {\n        const $this = this;\n        const isCheckbox = $this.type === 'checkbox';\n        newValue = isCheckbox ? $this.checked : _.escape($this.value); // set data to viewModel\n\n        if (modelDataKey) {\n          oldValue = getViewModelValue(viewModel, modelDataKey);\n          setViewModelValue(viewModel, modelDataKey, newValue);\n        }\n\n        const args = [e, e.currentTarget, newValue, oldValue].concat(paramList);\n        handlerFn.apply(viewModelContext, args);\n        oldValue = newValue;\n      } // assing on change event\n\n\n      cache.el.removeEventListener('change', changeHandler, false);\n      cache.el.addEventListener('change', changeHandler, false);\n    }\n  };\n\n  /**\r\n   * modelBinding\r\n   * @description input element data binding. viewModel -> DOM update\r\n   * @param {object} cache\r\n   * @param {object} viewModel\r\n   * @param {object} bindingAttrs\r\n   * @param {boolean} forceRender\r\n   */\n\n  const modelBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n    const dataKey = cache.dataKey;\n    let newValue = '';\n    const APP = viewModel.APP || viewModel.$root.APP;\n\n    if (!dataKey || !forceRender && !APP.$rootElement.contains(cache.el)) {\n      return;\n    }\n\n    newValue = getViewModelValue(viewModel, dataKey);\n\n    if (typeof newValue !== 'undefined' && newValue !== null) {\n      const $element = cache.el;\n      const isCheckbox = $element.type === 'checkbox';\n      const isRadio = $element.type === 'radio';\n      const inputName = $element.name;\n      const $radioGroup = isRadio ? APP.$rootElement.querySelectorAll(`input[name=\"${inputName}\"]`) : [];\n      const oldValue = isCheckbox ? $element.checked : $element.value; // update element value\n\n      if (newValue !== oldValue) {\n        if (isCheckbox) {\n          $element.checked = Boolean(newValue);\n        } else if (isRadio) {\n          let i = 0;\n          const radioGroupLength = $radioGroup.length;\n\n          for (i = 0; i < radioGroupLength; i += 1) {\n            if ($radioGroup[i].value === newValue) {\n              $radioGroup[i].checked = true;\n              break;\n            }\n          }\n        } else {\n          $element.value = newValue;\n        }\n      }\n    }\n  };\n\n  /**\r\n   * textBinding\r\n   * * @description\r\n   * DOM decleartive text binding update dom textnode with viewModel data\r\n   * @param {object} cache\r\n   * @param {object} viewModel\r\n   * @param {object} bindingAttrs\r\n   * @param {boolean} forceRender\r\n   */\n\n  const textBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n    const dataKey = cache.dataKey;\n    const APP = viewModel.APP || viewModel.$root.APP; // NOTE: this doesn't work for for-of, if and switch bindings because element was not in DOM\n\n    if (!dataKey || !forceRender && !APP.$rootElement.contains(cache.el)) {\n      return;\n    }\n\n    const newValue = getViewModelPropValue(viewModel, cache);\n    const oldValue = cache.el.textContent;\n\n    if (typeof newValue !== 'undefined' && typeof newValue !== 'object' && newValue !== null) {\n      if (newValue !== oldValue) {\n        cache.el.textContent = newValue;\n      }\n    }\n  };\n\n  /**\r\n   * showBinding\r\n   * @description\r\n   * DOM decleartive show binding. Make binding show/hide according to viewModel data (boolean)\r\n   * viewModel data can function but must return boolean\r\n   * @param {object} cache\r\n   * @param {object} viewModel\r\n   * @param {object} bindingAttrs\r\n   */\n\n  const showBinding = (cache, viewModel, bindingAttrs) => {\n    const dataKey = cache.dataKey;\n    let currentInlineSytle = {};\n    let currentInlineDisplaySytle = '';\n    let shouldShow = true;\n\n    if (!dataKey) {\n      return;\n    }\n\n    cache.elementData = cache.elementData || {};\n    const oldShowStatus = cache.elementData.viewModelPropValue; // store current element display default style once only\n\n    if (typeof cache.elementData.displayStyle === 'undefined' || typeof cache.elementData.computedStyle === 'undefined') {\n      currentInlineSytle = cache.el.style;\n      currentInlineDisplaySytle = currentInlineSytle.display; // use current inline style if defined\n\n      if (currentInlineDisplaySytle) {\n        // set to 'block' if is 'none'\n        cache.elementData.displayStyle = currentInlineDisplaySytle === 'none' ? 'block' : currentInlineDisplaySytle;\n        cache.elementData.computedStyle = null;\n      } else {\n        const computeStyle = window.getComputedStyle(cache.el, null).getPropertyValue('display');\n        cache.elementData.displayStyle = null;\n        cache.elementData.computedStyle = computeStyle;\n      }\n    }\n\n    shouldShow = getViewModelPropValue(viewModel, cache); // treat undefined || null as false.\n    // eg if property doesn't exsits in viewModel, it will treat as false to hide element\n\n    shouldShow = Boolean(shouldShow); // reject if nothing changed\n\n    if (oldShowStatus === shouldShow) {\n      return;\n    }\n\n    if (!shouldShow) {\n      if (cache.el.style.display !== 'none') {\n        cache.el.style.setProperty('display', 'none');\n      }\n    } else {\n      if (cache.elementData.computedStyle || cache.el.style.display === 'none') {\n        if (cache.elementData.computedStyle === 'none') {\n          // default display is none in css rule, so use display 'block'\n          cache.el.style.setProperty('display', 'block');\n        } else {\n          // has default displayable type so just remove inline display 'none'\n          if (currentInlineSytle.length > 1) {\n            cache.el.style.removeProperty('display');\n          } else {\n            cache.el.removeAttribute('style');\n          }\n        }\n      } else {\n        // element default display was inline style, so restore it\n        cache.el.style.setProperty('display', cache.elementData.displayStyle);\n      }\n    } // store new show status\n\n\n    cache.elementData.viewModelPropValue = shouldShow;\n  };\n\n  /**\r\n   * cssBinding\r\n   * @description\r\n   * DOM decleartive css binding. update classlist.\r\n   * viewModel data can function but must return JSOL.\r\n   * added css class if value is true\r\n   * @param {object} cache\r\n   * @param {object} viewModel\r\n   * @param {object} bindingAttrs\r\n   * @param {boolean} forceRender\r\n   */\n\n  const cssBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n    const dataKey = cache.dataKey;\n    const APP = viewModel.APP || viewModel.$root.APP;\n\n    if (!dataKey || !forceRender && !APP.$rootElement.contains(cache.el)) {\n      return;\n    }\n\n    cache.elementData = cache.elementData || {};\n    cache.elementData.viewModelPropValue = cache.elementData.viewModelPropValue || '';\n    const oldCssList = cache.elementData.viewModelPropValue;\n    let newCssList = '';\n    const vmCssListObj = getViewModelPropValue(viewModel, cache);\n    let vmCssListArray = [];\n    let isViewDataObject = false;\n    let isViewDataString = false;\n    let cssList = [];\n\n    if (typeof vmCssListObj === 'string') {\n      isViewDataString = true;\n    } else if (isPlainObject(vmCssListObj)) {\n      isViewDataObject = true;\n    } else {\n      // reject if vmCssListObj is not an object or string\n      return;\n    }\n\n    if (isViewDataObject) {\n      newCssList = JSON.stringify(vmCssListObj);\n    } else {\n      newCssList = vmCssListObj.replace(/\\s\\s+/g, ' ').trim();\n      vmCssListArray = newCssList.split(' ');\n    } // reject if nothing changed\n\n\n    if (oldCssList === newCssList) {\n      return;\n    } // get current css classes from element\n\n\n    const domCssList = cache.el.classList; // clone domCssList as new array\n\n    const domCssListLength = domCssList.length;\n\n    for (let i = 0; i < domCssListLength; i += 1) {\n      cssList.push(domCssList[i]);\n    }\n\n    if (isViewDataObject) {\n      each(vmCssListObj, function (k, v) {\n        const i = cssList.indexOf(k);\n\n        if (v === true) {\n          cssList.push(k);\n        } else if (i !== -1) {\n          cssList.splice(i, 1);\n        }\n      });\n    } else if (isViewDataString) {\n      // remove oldCssList items from cssList\n      cssList = arrayRemoveMatch(cssList, oldCssList);\n      cssList = cssList.concat(vmCssListArray);\n    } // unique cssList array\n\n\n    cssList = cssList.filter((v, i, a) => {\n      return a.indexOf(v) === i;\n    });\n    cssList = cssList.join(' '); // update element data\n\n    cache.elementData.viewModelPropValue = newCssList; // replace all css classes\n\n    cache.el.setAttribute('class', cssList);\n  };\n\n  /**\r\n   * attrBinding\r\n   * @description\r\n   * DOM decleartive attr binding. update elenment attributes\r\n   * @param {object} cache\r\n   * @param {object} viewModel\r\n   * @param {object} bindingAttrs\r\n   */\n\n  const attrBinding = (cache, viewModel, bindingAttrs) => {\n    const dataKey = cache.dataKey;\n\n    if (!dataKey) {\n      return;\n    }\n\n    cache.elementData = cache.elementData || {};\n    cache.elementData.viewModelProValue = cache.elementData.viewModelProValue || {};\n    const oldAttrObj = cache.elementData.viewModelProValue;\n    const vmAttrObj = getViewModelPropValue(viewModel, cache);\n\n    if (!isPlainObject(vmAttrObj)) {\n      return;\n    } // reject if nothing changed\n\n\n    if (JSON.stringify(oldAttrObj) === JSON.stringify(vmAttrObj)) {\n      return;\n    } // reset old data and update it\n\n\n    cache.elementData.viewModelProValue = {};\n\n    if (isEmptyObject(oldAttrObj)) {\n      each(vmAttrObj, (key, value) => {\n        cache.el.setAttribute(key, value); // populate with vmAttrObj data\n\n        cache.elementData.viewModelProValue[key] = value;\n      });\n    } else {\n      each(oldAttrObj, (key, value) => {\n        if (typeof vmAttrObj[key] === 'undefined') {\n          // remove attribute if not present in current vm\n          cache.el.removeAttribute(key);\n        }\n      });\n      each(vmAttrObj, (key, value) => {\n        if (oldAttrObj[key] !== vmAttrObj[key]) {\n          // update attribute if value changed\n          cache.el.setAttribute(key, vmAttrObj[key]);\n        } // populate with vmAttrObj data\n\n\n        cache.elementData.viewModelProValue[key] = value;\n      });\n    }\n  };\n\n  let bindingAttrsMap;\n  /**\r\n   * walkDOM\r\n   * @description by Douglas Crockford - walk each DOM node and calls provided callback function\r\n   * start walk from firstChild\r\n   * @param {object} node\r\n   * @param {function} func\r\n   */\n\n  const walkDOM = (node, func) => {\n    let parseChildNode = true;\n    node = node.firstElementChild;\n\n    while (node) {\n      parseChildNode = func(node);\n\n      if (parseChildNode) {\n        walkDOM(node, func);\n      }\n\n      node = node.nextElementSibling;\n    }\n  };\n\n  const getAttributesObject = node => {\n    const ret = {};\n    Array.prototype.slice.call(node.attributes).forEach(item => {\n      ret[item.name] = item.value;\n    });\n    return ret;\n  };\n\n  const checkSkipChildParseBindings = (attrObj = {}, bindingAttrs) => {\n    return [bindingAttrs.forOf, bindingAttrs.if, bindingAttrs.case, bindingAttrs.default].filter(type => {\n      return typeof attrObj[type] !== 'undefined';\n    });\n  };\n\n  const rootSkipCheck = node => {\n    return node.tagName === 'SVG';\n  };\n\n  const defaultSkipCheck = (node, bindingAttrs) => {\n    return node.tagName === 'SVG' || node.hasAttribute(bindingAttrs.comp);\n  };\n\n  const populateBindingCache = ({\n    node,\n    attrObj,\n    bindingCache,\n    type\n  }) => {\n    let attrValue;\n    let cacheData;\n\n    if (bindingAttrsMap && bindingAttrsMap[type] && typeof attrObj[type] !== 'undefined') {\n      bindingCache[type] = bindingCache[type] || [];\n      attrValue = attrObj[type].trim();\n      cacheData = {\n        el: node,\n        dataKey: attrValue\n      }; // populate cacheData.filters. update filterList first item as dataKey\n\n      cacheData = extractFilterList(cacheData); // populate cacheData.parameters\n      // for store function call parameters eg. '$index', '$root'\n      // useful with DOM for-loop template as reference to binding data\n\n      const paramList = getFunctionParameterList(cacheData.dataKey);\n\n      if (paramList) {\n        cacheData.parameters = paramList;\n        cacheData.dataKey = cacheData.dataKey.replace(REGEX.FUNCTIONPARAM, '').trim();\n      } // store parent array reference to cacheData\n\n\n      cacheData[constants.PARENT_REF] = bindingCache[type];\n      bindingCache[type].push(cacheData);\n    }\n\n    return bindingCache;\n  };\n\n  const createBindingCache = ({\n    rootNode = null,\n    bindingAttrs = {},\n    skipCheck,\n    isRenderedTemplate = false\n  }) => {\n    let bindingCache = {};\n\n    if (!rootNode instanceof window.Node) {\n      throw new TypeError('walkDOM: Expected a DOM node');\n    }\n\n    bindingAttrsMap = bindingAttrsMap || invertObj(bindingAttrs);\n\n    const parseNode = (node, skipNodeCheckFn = defaultSkipCheck) => {\n      let isSkipForOfChild = false;\n\n      if (node.nodeType !== 1 || !node.hasAttributes()) {\n        return true;\n      }\n\n      if (skipNodeCheckFn(node, bindingAttrs) || typeof skipCheck === 'function' && skipCheck(node)) {\n        return false;\n      } // when creating sub bindingCache if is for tmp binding\n      // skip same element that has forOf binding the  forOf is alredy parsed\n\n\n      const attrObj = getAttributesObject(node);\n      const hasSkipChildParseBindings = checkSkipChildParseBindings(attrObj, bindingAttrs);\n      let iterateList = [];\n\n      if (hasSkipChildParseBindings.length) {\n        isSkipForOfChild = true;\n        iterateList = hasSkipChildParseBindings;\n      } else if (isRenderedTemplate && attrObj[bindingAttrs.tmp]) {\n        // skip current node parse if was called by node has template binding and already rendered\n        return true;\n      } else {\n        iterateList = Object.keys(attrObj);\n      }\n\n      iterateList.forEach(key => {\n        // skip for switch case and default bining\n        if (key !== bindingAttrs.case && key !== bindingAttrs.default) {\n          bindingCache = populateBindingCache({\n            node: node,\n            attrObj: attrObj,\n            bindingCache: bindingCache,\n            type: key\n          });\n        }\n      }); // after cache forOf skip parse child nodes\n\n      if (isSkipForOfChild) {\n        return false;\n      }\n\n      return true;\n    };\n\n    if (parseNode(rootNode, rootSkipCheck)) {\n      walkDOM(rootNode, parseNode);\n    }\n\n    return bindingCache;\n  };\n\n  /* eslint-disable no-invalid-this */\n\n  const createClonedElementCache = bindingData => {\n    const clonedElement = bindingData.el.cloneNode(true);\n    bindingData.fragment = document.createDocumentFragment();\n    bindingData.fragment.appendChild(clonedElement);\n    return bindingData;\n  };\n\n  const setCommentPrefix = bindingData => {\n    if (!bindingData || !bindingData.type) {\n      return bindingData;\n    }\n\n    let commentPrefix$1 = '';\n    const dataKeyMarker = bindingData.dataKey ? bindingData.dataKey.replace(REGEX.WHITESPACES, '_') : '';\n\n    switch (bindingData.type) {\n      case bindingAttrs$1.forOf:\n        commentPrefix$1 = commentPrefix.forOf;\n        break;\n\n      case bindingAttrs$1.if:\n        commentPrefix$1 = commentPrefix.if;\n        break;\n\n      case bindingAttrs$1.case:\n        commentPrefix$1 = commentPrefix.case;\n        break;\n\n      case bindingAttrs$1.default:\n        commentPrefix$1 = commentPrefix.default;\n        break;\n    }\n\n    bindingData.commentPrefix = commentPrefix$1 + dataKeyMarker;\n    return bindingData;\n  };\n  /**\r\n   * setDocRangeEndAfter\r\n   * @param {object} node\r\n   * @param {object} bindingData\r\n   * @description\r\n   * recursive execution to find last wrapping comment node\r\n   * and set as bindingData.docRange.setEndAfter\r\n   * if not found deleteContents will has no operation\r\n   * @return {undefined}\r\n   */\n\n\n  const setDocRangeEndAfter = (node, bindingData) => {\n    if (!bindingData.commentPrefix) {\n      setCommentPrefix(bindingData);\n    }\n\n    const startTextContent = bindingData.commentPrefix;\n    const endTextContent = startTextContent + commentSuffix;\n    node = node.nextSibling; // check last wrap comment node\n\n    if (node) {\n      if (node.nodeType === 8 && node.textContent === endTextContent) {\n        return bindingData.docRange.setEndBefore(node);\n      }\n\n      setDocRangeEndAfter(node, bindingData);\n    }\n  };\n  /**\r\n   * wrapCommentAround\r\n   * @param {object} bindingData\r\n   * @param {Node} node\r\n   * @return {object} DOM fragment\r\n   * @description\r\n   * wrap frament with comment node\r\n   */\n\n\n  const wrapCommentAround = (bindingData, node) => {\n    let prefix = '';\n\n    if (!bindingData.commentPrefix) {\n      setCommentPrefix(bindingData);\n    }\n\n    prefix = bindingData.commentPrefix;\n    const commentBegin = document.createComment(prefix);\n    const commentEnd = document.createComment(prefix + commentSuffix); // document fragment - logic for ForOf binding\n    // check node.parentNode because node could be from cache and no longer in DOM\n\n    if (node.nodeType === 11) {\n      node.insertBefore(commentBegin, node.firstChild);\n      node.appendChild(commentEnd);\n    } else if (node.parentNode) {\n      node.parentNode.insertBefore(commentBegin, node);\n      insertAfter(node.parentNode, commentEnd, node); // update bindingData details\n\n      bindingData.previousNonTemplateElement = node.previousSibling;\n      bindingData.nextNonTemplateElement = node.nextSibling;\n      bindingData.parentElement = node.previousSibling.parentElement;\n    }\n\n    return node;\n  };\n  /**\r\n   * removeElemnetsByCommentWrap\r\n   * @param {object} bindingData\r\n   * @return {undefined}\r\n   * @description remove elments by range\r\n   */\n\n\n  const removeElemnetsByCommentWrap = bindingData => {\n    if (!bindingData.docRange) {\n      bindingData.docRange = document.createRange();\n    }\n\n    try {\n      if (bindingData.previousNonTemplateElement) {\n        // update docRange start and end match the wrapped comment node\n        bindingData.docRange.setStartBefore(bindingData.previousNonTemplateElement.nextSibling);\n        setDocRangeEndAfter(bindingData.previousNonTemplateElement.nextSibling, bindingData);\n      } else {\n        // insert before next non template element\n        bindingData.docRange.setStartBefore(bindingData.parentElement.firstChild);\n        setDocRangeEndAfter(bindingData.parentElement.firstChild, bindingData);\n      }\n    } catch (err) {\n      console.log('error removeElemnetsByCommentWrap: ', err.message);\n    }\n\n    return bindingData.docRange.deleteContents();\n  };\n\n  const insertRenderedElements = (bindingData, fragment) => {\n    // insert rendered fragment after the previousNonTemplateElement\n    if (bindingData.previousNonTemplateElement) {\n      insertAfter(bindingData.parentElement, fragment, bindingData.previousNonTemplateElement);\n    } else {\n      // insert before next non template element\n      if (bindingData.nextNonTemplateElement) {\n        bindingData.parentElement.insertBefore(fragment, bindingData.nextNonTemplateElement);\n      } else if (bindingData.parentElement) {\n        // insert from parent\n        bindingData.parentElement.appendChild(fragment);\n      }\n    }\n  };\n\n  /* eslint-disable no-invalid-this */\n\n  const renderForOfBinding = ({\n    bindingData,\n    viewModel,\n    bindingAttrs\n  }) => {\n    if (!bindingData || !viewModel || !bindingAttrs) {\n      return;\n    }\n\n    let keys;\n    let iterationDataLength;\n    const iterationData = getViewModelPropValue(viewModel, bindingData.iterator);\n    let isRegenerate = false; // check iterationData and set iterationDataLength\n\n    if (isArray(iterationData)) {\n      iterationDataLength = iterationData.length;\n    } else if (isPlainObject(iterationData)) {\n      keys = Object.keys(iterationData);\n      iterationDataLength = keys.length;\n    } else {\n      // throw error but let script contince to run\n      return throwErrorMessage(null, 'iterationData is not an plain object or array');\n    } // flag as pared for-of logic with bindingData.type\n\n\n    if (!bindingData.type) {\n      bindingData.type = bindingAttrs$1.forOf;\n      wrapCommentAround(bindingData, bindingData.el);\n    } // assign forOf internal id to bindingData once\n\n\n    if (typeof bindingData.iterationSize === 'undefined') {\n      // store iterationDataLength\n      bindingData.iterationSize = iterationDataLength; // remove orignal node for-of attributes\n\n      bindingData.el.removeAttribute(bindingAttrs.forOf);\n      isRegenerate = true;\n    } else {\n      // only regenerate cache if iterationDataLength changed\n      isRegenerate = bindingData.iterationSize !== iterationDataLength; // update iterationSize\n\n      bindingData.iterationSize = iterationDataLength;\n    }\n\n    if (!isRegenerate) {\n      bindingData.iterationBindingCache.forEach(function (elementCache, i) {\n        if (!isEmptyObject(elementCache)) {\n          const iterationVm = createIterationViewModel({\n            bindingData: bindingData,\n            viewModel: viewModel,\n            iterationData: iterationData,\n            keys: keys,\n            index: i\n          });\n          renderIteration({\n            elementCache: elementCache,\n            iterationVm: iterationVm,\n            bindingAttrs: bindingAttrs,\n            isRegenerate: false\n          });\n        }\n      });\n      return;\n    } // generate forOfBinding elements into fragment\n\n\n    const fragment = generateForOfElements(bindingData, viewModel, bindingAttrs, iterationData, keys);\n    removeElemnetsByCommentWrap(bindingData); // insert fragment content into DOM\n\n    return insertRenderedElements(bindingData, fragment);\n  };\n\n  const createIterationViewModel = ({\n    bindingData,\n    viewModel,\n    iterationData,\n    keys,\n    index\n  }) => {\n    const iterationVm = {};\n    iterationVm[bindingData.iterator.alias] = keys ? iterationData[keys[index]] : iterationData[index]; // populate common binding data reference\n\n    iterationVm[bindingDataReference.rootDataKey] = viewModel.$root || viewModel;\n    iterationVm[bindingDataReference.currentData] = iterationVm[bindingData.iterator.alias];\n    iterationVm[bindingDataReference.currentIndex] = index;\n    return iterationVm;\n  };\n\n  const generateForOfElements = (bindingData, viewModel, bindingAttrs, iterationData, keys) => {\n    const fragment = document.createDocumentFragment();\n    const iterationDataLength = bindingData.iterationSize;\n    let clonedItem;\n    let iterationVm;\n    let iterationBindingCache;\n    let i = 0; // create or clear exisitng iterationBindingCache\n\n    if (isArray(bindingData.iterationBindingCache)) {\n      bindingData.iterationBindingCache.length = 0;\n    } else {\n      bindingData.iterationBindingCache = [];\n    } // generate forOf and append to DOM\n\n\n    for (i = 0; i < iterationDataLength; i += 1) {\n      clonedItem = cloneDomNode(bindingData.el); // create bindingCache per iteration\n\n      iterationBindingCache = createBindingCache({\n        rootNode: clonedItem,\n        bindingAttrs: bindingAttrs\n      });\n      bindingData.iterationBindingCache.push(iterationBindingCache);\n\n      if (!isEmptyObject(iterationBindingCache)) {\n        // create an iterationVm match iterator alias\n        iterationVm = createIterationViewModel({\n          bindingData: bindingData,\n          viewModel: viewModel,\n          iterationData: iterationData,\n          keys: keys,\n          index: i\n        });\n        renderIteration({\n          elementCache: bindingData.iterationBindingCache[i],\n          iterationVm: iterationVm,\n          bindingAttrs: bindingAttrs,\n          isRegenerate: true\n        });\n      }\n\n      fragment.appendChild(clonedItem);\n    }\n\n    return fragment;\n  };\n\n  /**\r\n   * forOfBinding\r\n   * @description\r\n   * DOM decleartive for binding.\r\n   * @param {object} cache\r\n   * @param {object} viewModel\r\n   * @param {object} bindingAttrs\r\n   */\n\n  const forOfBinding = (cache, viewModel, bindingAttrs) => {\n    const dataKey = cache.dataKey;\n\n    if (!dataKey || dataKey.length > maxDatakeyLength) {\n      return;\n    }\n\n    if (!cache.iterator) {\n      if (dataKey.length > maxDatakeyLength) {\n        return;\n      } // replace mess spaces with single space\n\n\n      cache.dataKey = cache.dataKey.replace(REGEX.WHITESPACES, ' ');\n      const forExpMatch = dataKey.match(REGEX.FOROF);\n\n      if (!forExpMatch) {\n        return;\n      }\n\n      cache.iterator = {};\n      cache.iterator.alias = forExpMatch[1].trim();\n\n      if (forExpMatch[2]) {\n        cache.iterator.dataKey = forExpMatch[2].trim();\n        cache.parentElement = cache.el.parentElement;\n        cache.previousNonTemplateElement = cache.el.previousSibling;\n        cache.nextNonTemplateElement = cache.el.nextSibling;\n      }\n    }\n\n    renderForOfBinding({\n      bindingData: cache,\n      viewModel: viewModel,\n      bindingAttrs: bindingAttrs\n    });\n  };\n\n  /**\r\n   * isTargetDomRemoved\r\n   * @description check if DOM between 'start' and 'end' comment tag has been removed\r\n   * @param {object} bindingData\r\n   * @return {boolean}\r\n   */\n\n  const isTargetDomRemoved = bindingData => {\n    let ret = false;\n\n    if (bindingData && bindingData.previousNonTemplateElement) {\n      const commentStartTextContent = bindingData.previousNonTemplateElement.textContent;\n      const endCommentTag = bindingData.previousNonTemplateElement.nextSibling;\n\n      if (endCommentTag.nodeType === 8) {\n        if (endCommentTag.textContent === commentStartTextContent + commentSuffix) {\n          ret = true;\n        }\n      }\n    }\n\n    return ret;\n  };\n\n  const renderIfBinding = ({\n    bindingData,\n    viewModel,\n    bindingAttrs\n  }) => {\n    if (!bindingData.fragment) {\n      return;\n    }\n\n    const isDomRemoved = isTargetDomRemoved(bindingData);\n    let rootElement = bindingData.el; // remove current old DOM.\n    // TODO: try preserve DOM\n\n    if (!isDomRemoved && !bindingData.isOnce) {\n      removeIfBinding(bindingData); // use fragment for create iterationBindingCache\n\n      rootElement = bindingData.fragment.firstChild.cloneNode(true);\n    } // walk clonedElement to create iterationBindingCache once\n\n\n    if (!bindingData.iterationBindingCache || !bindingData.hasIterationBindingCache) {\n      bindingData.iterationBindingCache = createBindingCache({\n        rootNode: rootElement,\n        bindingAttrs: bindingAttrs\n      });\n    } // only render if has iterationBindingCache\n    // means has other dataBindings to be render\n\n\n    if (!isEmptyObject(bindingData.iterationBindingCache)) {\n      bindingData.hasIterationBindingCache = true;\n      renderIteration({\n        elementCache: bindingData.iterationBindingCache,\n        iterationVm: viewModel,\n        bindingAttrs: bindingAttrs,\n        isRegenerate: true\n      });\n    } // insert to new rendered DOM\n    // TODO: check unnecessary insertion when DOM is preserved\n\n\n    insertRenderedElements(bindingData, rootElement);\n  };\n\n  const removeIfBinding = bindingData => {\n    removeElemnetsByCommentWrap(bindingData); // remove cache.IterationBindingCache to prevent memory leak\n\n    if (bindingData.hasIterationBindingCache) {\n      delete bindingData.iterationBindingCache;\n      delete bindingData.hasIterationBindingCache;\n    }\n  };\n\n  /**\r\n   * if-Binding\r\n   * @description\r\n   * DOM decleartive for binding.\r\n   * @param {object} cache\r\n   * @param {object} viewModel\r\n   * @param {object} bindingAttrs\r\n   */\n\n  const ifBinding = (cache, viewModel, bindingAttrs) => {\n    const dataKey = cache.dataKey; // isOnce only return if there is no child bindings\n\n    if (!dataKey || cache.isOnce && cache.hasIterationBindingCache === false) {\n      return;\n    }\n\n    cache.elementData = cache.elementData || {};\n    cache.type = cache.type || bindingAttrs$1.if;\n    const oldViewModelProValue = cache.elementData.viewModelPropValue; // getViewModelPropValue could be return undefined or null\n\n    const viewModelPropValue = getViewModelPropValue(viewModel, cache) || false; // do nothing if viewModel value not changed and no child bindings\n\n    if (oldViewModelProValue === viewModelPropValue && !cache.hasIterationBindingCache) {\n      return;\n    }\n\n    const shouldRender = Boolean(viewModelPropValue); // remove this cache from parent array\n\n    if (!shouldRender && cache.isOnce && cache.el.parentNode) {\n      removeElement(cache.el); // delete cache.fragment;\n\n      removeBindingInQueue({\n        viewModel: viewModel,\n        cache: cache\n      });\n      return;\n    } // store new show status\n\n\n    cache.elementData.viewModelPropValue = viewModelPropValue; // only create fragment once\n    // wrap comment tag around\n    // remove if attribute from original element to allow later dataBind parsing\n\n    if (!cache.fragment) {\n      wrapCommentAround(cache, cache.el);\n      cache.el.removeAttribute(bindingAttrs.if);\n      createClonedElementCache(cache);\n    }\n\n    if (!shouldRender) {\n      // remove element\n      removeIfBinding(cache);\n    } else {\n      // render element\n      renderIfBinding({\n        bindingData: cache,\n        viewModel: viewModel,\n        bindingAttrs: bindingAttrs\n      }); // if render once\n      // remove this cache from parent array if no child caches\n\n      if (cache.isOnce && !cache.hasIterationBindingCache) {\n        // delete cache.fragment;\n        removeBindingInQueue({\n          viewModel: viewModel,\n          cache: cache\n        });\n      }\n    }\n  };\n\n  const removeBindingInQueue = ({\n    viewModel,\n    cache\n  }) => {\n    let ret = false;\n\n    if (viewModel.APP.postProcessQueue) {\n      viewModel.APP.postProcessQueue.push(((cache, index) => () => {\n        cache[constants.PARENT_REF].splice(index, 1);\n      })(cache, cache[constants.PARENT_REF].indexOf(cache)));\n      ret = true;\n    }\n\n    return ret;\n  };\n\n  /**\r\n   * switch-Binding\r\n   * @description\r\n   * DOM decleartive switch binding.\r\n   * switch parent element wrap direct child with case bindings\r\n   * @param {object} cache\r\n   * @param {object} viewModel\r\n   * @param {object} bindingAttrs\r\n   */\n\n  const switchBinding = (cache, viewModel, bindingAttrs) => {\n    const dataKey = cache.dataKey;\n\n    if (!dataKey) {\n      return;\n    }\n\n    cache.elementData = cache.elementData || {};\n    const newExpression = getViewModelPropValue(viewModel, cache);\n\n    if (newExpression === cache.elementData.viewModelPropValue) {\n      return;\n    }\n\n    cache.elementData.viewModelPropValue = newExpression; // build switch cases if not yet defined\n\n    if (!cache.cases) {\n      const childrenElements = cache.el.children;\n\n      if (!childrenElements.length) {\n        return;\n      }\n\n      cache.cases = [];\n\n      for (let i = 0, elementLength = childrenElements.length; i < elementLength; i += 1) {\n        let caseData = null;\n\n        if (childrenElements[i].hasAttribute(bindingAttrs.case)) {\n          caseData = createCaseData(childrenElements[i], bindingAttrs.case);\n        } else if (childrenElements[i].hasAttribute(bindingAttrs.default)) {\n          caseData = createCaseData(childrenElements[i], bindingAttrs.default);\n          caseData.isDefault = true;\n        } // create fragment by clone node\n        // wrap with comment tag\n\n\n        if (caseData) {\n          wrapCommentAround(caseData, caseData.el); // remove binding attribute for later dataBind parse\n\n          if (caseData.isDefault) {\n            caseData.el.removeAttribute(bindingAttrs.default);\n          } else {\n            caseData.el.removeAttribute(bindingAttrs.case);\n          }\n\n          createClonedElementCache(caseData);\n          cache.cases.push(caseData);\n        }\n      }\n    }\n\n    if (cache.cases.length) {\n      let hasMatch = false; // do switch operation - reuse if binding logic\n\n      for (let j = 0, casesLength = cache.cases.length; j < casesLength; j += 1) {\n        let newCaseValue;\n\n        if (cache.cases[j].dataKey) {\n          // set back to dataKey if nothing found in viewModel\n          newCaseValue = getViewModelPropValue(viewModel, cache.cases[j]) || cache.cases[j].dataKey;\n        }\n\n        if (newCaseValue === cache.elementData.viewModelPropValue || cache.cases[j].isDefault) {\n          hasMatch = true; // render element\n\n          renderIfBinding({\n            bindingData: cache.cases[j],\n            viewModel: viewModel,\n            bindingAttrs: bindingAttrs\n          }); // remove other elements\n\n          removeUnmatchCases(cache.cases, j);\n          break;\n        }\n      } // no match remove all cases\n\n\n      if (!hasMatch) {\n        removeUnmatchCases(cache.cases);\n      }\n    }\n  };\n\n  function removeUnmatchCases(cases, matchedIndex) {\n    cases.forEach((caseData, index) => {\n      if (index !== matchedIndex || typeof matchedIndex === 'undefined') {\n        removeIfBinding(caseData); // remove cache.IterationBindingCache to prevent memory leak\n\n        if (caseData.hasIterationBindingCache) {\n          caseData.iterationBindingCache = null;\n          caseData.hasIterationBindingCache = false;\n        }\n      }\n    });\n  }\n\n  function createCaseData(node, attrName) {\n    const caseData = {\n      el: node,\n      dataKey: node.getAttribute(attrName),\n      type: attrName\n    };\n    return caseData;\n  }\n\n  /**\r\n   *  pubSub\r\n   * @description use jQuery object as pubSub\r\n   * @example EVENTS object strucure:\r\n   *  EVENTS = {\r\n          'EVENT-NAME': [{ 'comp-id': fn }],\r\n          'EVENT-NAME2': [{ 'comp-id': fn }]\r\n      };\r\n   */\n\n  const EVENTS = {};\n\n  const subscribeEvent = (instance = null, eventName = '', fn, isOnce = false) => {\n    if (!instance || !instance.compId || !eventName || typeof fn !== 'function') {\n      return;\n    }\n\n    let subscriber;\n    let isSubscribed = false;\n    eventName = eventName.replace(REGEX.WHITESPACES, '');\n    EVENTS[eventName] = EVENTS[eventName] || []; // check if already subscribed and update callback fn\n\n    isSubscribed = EVENTS[eventName].some(subscriber => {\n      if (subscriber[instance.compId]) {\n        subscriber[instance.compId] = fn.bind(instance.viewModel);\n        subscriber.isOnce = isOnce;\n        return true;\n      }\n    }); // push if not yet subscribe\n\n    if (!isSubscribed) {\n      subscriber = {};\n      subscriber[instance.compId] = fn.bind(instance.viewModel);\n      subscriber.isOnce = isOnce;\n      EVENTS[eventName].push(subscriber);\n    }\n  };\n\n  const subscribeEventOnce = (instance = null, eventName = '', fn) => {\n    subscribeEvent(instance, eventName, fn, true);\n  };\n\n  const unsubscribeEvent = (compId = '', eventName = '') => {\n    if (!compId || !eventName) {\n      return;\n    }\n\n    let i = 0;\n    let subscribersLength = 0;\n    let subscriber;\n    eventName = eventName.replace(REGEX.WHITESPACES, '');\n\n    if (EVENTS[eventName]) {\n      subscribersLength = EVENTS[eventName].length;\n\n      for (i = 0; i < subscribersLength; i += 1) {\n        subscriber = EVENTS[eventName][i];\n\n        if (subscriber[compId]) {\n          EVENTS[eventName].splice(i, 1);\n          break;\n        }\n      }\n    } // delete the event if no more subscriber\n\n\n    if (!EVENTS[eventName].length) {\n      delete EVENTS[eventName];\n    }\n  };\n  /**\r\n   * unsubscribeAllEvent\r\n   * @description unsubscribe all event by compId. eg when a component removed\r\n   * @param {string} compId\r\n   */\n\n\n  const unsubscribeAllEvent = (compId = '') => {\n    if (!compId) {\n      return;\n    }\n\n    Object.keys(EVENTS).forEach(eventName => {\n      unsubscribeEvent(compId, eventName);\n    });\n  };\n\n  const publishEvent = (eventName = '', ...args) => {\n    if (!eventName || !EVENTS[eventName]) {\n      return;\n    }\n\n    eventName = eventName.replace(REGEX.WHITESPACES, '');\n    EVENTS[eventName].forEach(subscriber => {\n      Object.keys(subscriber).forEach(compId => {\n        if (typeof subscriber[compId] === 'function') {\n          const ret = subscriber[compId](...args);\n\n          if (subscriber.isOnce) {\n            unsubscribeEvent(compId, eventName);\n          }\n\n          return ret;\n        }\n      });\n    });\n  };\n\n  let compIdIndex = 0;\n\n  class Binder {\n    constructor($rootElement, viewModel, bindingAttrs) {\n      if (!$rootElement || $rootElement.nodeType !== 1 || viewModel === null || typeof viewModel !== 'object') {\n        throw new TypeError('$rootElement or viewModel is invalid');\n      }\n\n      this.initRendered = false;\n      this.compId = compIdIndex += 1;\n      this.$rootElement = $rootElement;\n      this.viewModel = viewModel;\n      this.bindingAttrs = bindingAttrs;\n      this.render = debounceRaf(this.render, this);\n      this.isServerRendered = this.$rootElement.getAttribute(serverRenderedAttr) !== null; // inject instance into viewModel\n\n      this.viewModel.APP = this;\n      this.viewModel.$root = this.viewModel;\n      this.parseView(); // for jquery user set viewModel referece to $rootElement for easy debug\n      // otherwise use Expando to attach viewModel to $rootElement\n\n      this.$rootElement[bindingDataReference.rootDataKey] = this.viewModel;\n      return this;\n    }\n    /**\r\n     * parseView\r\n     * @description\r\n     * @return {this}\r\n     * traver from $rootElement to find each data-bind-* element\r\n     * then apply data binding\r\n     */\n\n\n    parseView() {\n      this.elementCache = createBindingCache({\n        rootNode: this.$rootElement,\n        bindingAttrs: this.bindingAttrs\n      }); // updateElementCache if server rendered on init\n\n      if (this.isServerRendered && !this.initRendered) {\n        this.updateElementCache({\n          templateCache: true\n        });\n      }\n\n      return this;\n    }\n    /**\r\n     * updateElementCache\r\n     * @param {object} opt\r\n     * @description call createBindingCache to parse view and generate bindingCache\r\n     */\n\n\n    updateElementCache(opt = {}) {\n      const elementCache = opt.elementCache || this.elementCache;\n\n      if (opt.allCache) {\n        // walk dom from root element to regenerate elementCache\n        this.elementCache = createBindingCache({\n          rootNode: this.$rootElement,\n          bindingAttrs: this.bindingAttrs\n        });\n      } // walk from first rendered template node to create/update child bindingCache\n\n\n      if (opt.allCache || opt.templateCache) {\n        if (elementCache[this.bindingAttrs.tmp] && elementCache[this.bindingAttrs.tmp].length) {\n          elementCache[this.bindingAttrs.tmp].forEach(cache => {\n            // set skipCheck as skipForOfParseFn whenever an node has\n            // both template and forOf bindings\n            // then the template bindingCache should be an empty object\n            let skipForOfParseFn = null;\n\n            if (cache.el.hasAttribute(this.bindingAttrs.forOf)) {\n              skipForOfParseFn = () => {\n                return true;\n              };\n            }\n\n            cache.bindingCache = createBindingCache({\n              rootNode: cache.el,\n              bindingAttrs: this.bindingAttrs,\n              skipCheck: skipForOfParseFn,\n              isRenderedTemplate: opt.isRenderedTemplates\n            });\n          });\n        }\n      }\n    }\n\n    render(opt = {}) {\n      let updateOption = {};\n\n      if (!this.initRendered) {\n        // only update eventsBinding if server rendered\n        if (this.isServerRendered) {\n          this.$rootElement.removeAttribute(serverRenderedAttr);\n          updateOption = createBindingOption(bindingUpdateConditions.serverRendered, opt);\n        } else {\n          updateOption = createBindingOption(bindingUpdateConditions.init, opt);\n        }\n      } else {\n        // when called again only update visualBinding options\n        updateOption = createBindingOption('', opt);\n      } // create postProcessQueue before start rendering\n\n\n      this.postProcessQueue = []; // render and apply binding to template(s)\n      // this is an share function therefore passing 'this' context\n\n      renderTemplatesBinding({\n        ctx: this,\n        elementCache: this.elementCache,\n        updateOption: updateOption,\n        bindingAttrs: this.bindingAttrs,\n        viewModel: this.viewModel\n      }); // apply bindings to rest of the DOM\n\n      Binder.applyBinding({\n        ctx: this,\n        elementCache: this.elementCache,\n        updateOption: updateOption,\n        bindingAttrs: this.bindingAttrs,\n        viewModel: this.viewModel\n      }); // trigger postProcess\n\n      Binder.postProcess(this.postProcessQueue); // clear postProcessQueue\n\n      this.postProcessQueue.length = 0;\n      delete this.postProcessQueue;\n      this.initRendered = true;\n    }\n\n    static applyBinding({\n      ctx,\n      elementCache,\n      updateOption,\n      bindingAttrs,\n      viewModel\n    }) {\n      if (!elementCache || !updateOption) {\n        return;\n      } // the follow binding should be in order for better efficiency\n      // apply forOf Binding\n\n\n      if (updateOption.forOfBinding && elementCache[bindingAttrs.forOf] && elementCache[bindingAttrs.forOf].length) {\n        elementCache[bindingAttrs.forOf].forEach(cache => {\n          forOfBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n      } // apply attr Binding\n\n\n      if (updateOption.attrBinding && elementCache[bindingAttrs.attr] && elementCache[bindingAttrs.attr].length) {\n        elementCache[bindingAttrs.attr].forEach(cache => {\n          attrBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n      } // apply if Binding\n\n\n      if (updateOption.ifBinding && elementCache[bindingAttrs.if] && elementCache[bindingAttrs.if].length) {\n        elementCache[bindingAttrs.if].forEach(cache => {\n          ifBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n      } // apply show Binding\n\n\n      if (updateOption.showBinding && elementCache[bindingAttrs.show] && elementCache[bindingAttrs.show].length) {\n        elementCache[bindingAttrs.show].forEach(cache => {\n          showBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n      } // apply switch Binding\n\n\n      if (updateOption.switchBinding && elementCache[bindingAttrs.switch] && elementCache[bindingAttrs.switch].length) {\n        elementCache[bindingAttrs.switch].forEach(cache => {\n          switchBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n      } // apply text binding\n\n\n      if (updateOption.textBinding && elementCache[bindingAttrs.text] && elementCache[bindingAttrs.text].length) {\n        elementCache[bindingAttrs.text].forEach(cache => {\n          textBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n      } // apply cssBinding\n\n\n      if (updateOption.cssBinding && elementCache[bindingAttrs.css] && elementCache[bindingAttrs.css].length) {\n        elementCache[bindingAttrs.css].forEach(cache => {\n          cssBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n      } // apply model binding\n\n\n      if (updateOption.modelBinding && elementCache[bindingAttrs.model] && elementCache[bindingAttrs.model].length) {\n        elementCache[bindingAttrs.model].forEach(cache => {\n          modelBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n      } // apply change binding\n\n\n      if (updateOption.changeBinding && elementCache[bindingAttrs.change] && elementCache[bindingAttrs.change].length) {\n        elementCache[bindingAttrs.change].forEach(cache => {\n          changeBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n      } // apply submit binding\n\n\n      if (updateOption.submitBinding && elementCache[bindingAttrs.submit] && elementCache[bindingAttrs.submit].length) {\n        elementCache[bindingAttrs.submit].forEach(cache => {\n          createEventBinding({\n            cache,\n            forceRender: updateOption.forceRender,\n            type: 'submit',\n            viewModel\n          });\n        });\n      } // apply click binding\n\n\n      if (updateOption.clickBinding && elementCache[bindingAttrs.click] && elementCache[bindingAttrs.click].length) {\n        elementCache[bindingAttrs.click].forEach(cache => {\n          createEventBinding({\n            cache,\n            forceRender: updateOption.forceRender,\n            type: 'click',\n            viewModel\n          });\n        });\n      } // apply double click binding\n\n\n      if (updateOption.dblclickBinding && elementCache[bindingAttrs.dblclick] && elementCache[bindingAttrs.dblclick].length) {\n        elementCache[bindingAttrs.dblclick].forEach(cache => {\n          createEventBinding({\n            cache,\n            forceRender: updateOption.forceRender,\n            type: 'dblclick',\n            viewModel\n          });\n        });\n      } // apply blur binding\n\n\n      if (updateOption.blurBinding && elementCache[bindingAttrs.blur] && elementCache[bindingAttrs.blur].length) {\n        elementCache[bindingAttrs.blur].forEach(cache => {\n          createEventBinding({\n            cache,\n            forceRender: updateOption.forceRender,\n            type: 'blur',\n            viewModel\n          });\n        });\n      } // apply focus binding\n\n\n      if (updateOption.focusBinding && elementCache[bindingAttrs.focus] && elementCache[bindingAttrs.focus].length) {\n        elementCache[bindingAttrs.focus].forEach(cache => {\n          createEventBinding({\n            cache,\n            forceRender: updateOption.forceRender,\n            type: 'focus',\n            viewModel\n          });\n        });\n      } // apply hover binding\n\n\n      if (updateOption.hoverBinding && elementCache[bindingAttrs.hover] && elementCache[bindingAttrs.hover].length) {\n        elementCache[bindingAttrs.hover].forEach(cache => {\n          hoverBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n      }\n    }\n\n    static postProcess(tasks) {\n      if (!tasks || !tasks.length) {\n        return;\n      }\n\n      each(tasks, (index, task) => {\n        if (typeof task === 'function') {\n          try {\n            task();\n          } catch (err) {\n            throwErrorMessage(err, 'Error postProcess: ' + String(task));\n          }\n        }\n      });\n    }\n\n    subscribe(eventName = '', fn) {\n      subscribeEvent(this, eventName, fn);\n      return this;\n    }\n\n    subscribeOnce(eventName = '', fn) {\n      subscribeEventOnce(this, eventName, fn);\n      return this;\n    }\n\n    unsubscribe(eventName = '') {\n      unsubscribeEvent(this.compId, eventName);\n      return this;\n    }\n\n    unsubscribeAll() {\n      unsubscribeAllEvent(this.compId);\n      return this;\n    }\n\n    publish(eventName = '', ...args) {\n      publishEvent(eventName, ...args);\n      return this;\n    }\n\n  }\n\n  const renderTemplatesBinding = ({\n    ctx,\n    elementCache,\n    updateOption,\n    bindingAttrs,\n    viewModel\n  }) => {\n    if (!elementCache || !bindingAttrs) {\n      return false;\n    } // render and apply binding to template(s) and forOf DOM\n\n\n    if (elementCache[bindingAttrs.tmp] && elementCache[bindingAttrs.tmp].length) {\n      // when re-render call with {templateBinding: true}\n      // template and nested templates\n      if (updateOption.templateBinding) {\n        // overwrite updateOption with 'init' bindingUpdateConditions\n        updateOption = createBindingOption(bindingUpdateConditions.init);\n        elementCache[bindingAttrs.tmp].forEach($element => {\n          renderTemplate($element, viewModel, bindingAttrs, elementCache);\n        }); // update cache after all template(s) rendered\n\n        ctx.updateElementCache({\n          templateCache: true,\n          elementCache: elementCache,\n          isRenderedTemplates: true\n        });\n      } // enforce render even element is not in DOM tree\n\n\n      updateOption.forceRender = true; // apply bindings to rendered templates element\n\n      elementCache[bindingAttrs.tmp].forEach(cache => {\n        Binder.applyBinding({\n          elementCache: cache.bindingCache,\n          updateOption: updateOption,\n          bindingAttrs: bindingAttrs,\n          viewModel: viewModel\n        });\n      });\n    }\n\n    return true;\n  };\n  /**\r\n   * createBindingOption\r\n   * @param {string} condition\r\n   * @param {object} opt\r\n   * @description\r\n   * generate binding update option object by condition\r\n   * @return {object} updateOption\r\n   */\n\n\n  const createBindingOption = (condition = '', opt = {}) => {\n    const visualBindingOptions = {\n      templateBinding: false,\n      textBinding: true,\n      cssBinding: true,\n      ifBinding: true,\n      showBinding: true,\n      modelBinding: true,\n      attrBinding: true,\n      forOfBinding: true,\n      switchBinding: true\n    };\n    const eventsBindingOptions = {\n      changeBinding: true,\n      clickBinding: true,\n      dblclickBinding: true,\n      blurBinding: true,\n      focusBinding: true,\n      hoverBinding: true,\n      submitBinding: true\n    }; // this is visualBindingOptions but everything false\n    // concrete declear for performance purpose\n\n    const serverRenderedOptions = {\n      templateBinding: false,\n      textBinding: false,\n      cssBinding: false,\n      ifBinding: false,\n      showBinding: false,\n      modelBinding: false,\n      attrBinding: false,\n      forOfBinding: false,\n      switchBinding: false\n    };\n    let updateOption = {};\n\n    switch (condition) {\n      case bindingUpdateConditions.serverRendered:\n        updateOption = extend({}, eventsBindingOptions, serverRenderedOptions, opt);\n        break;\n\n      case bindingUpdateConditions.init:\n        // flag templateBinding to true to render tempalte(s)\n        opt.templateBinding = true;\n        updateOption = extend({}, visualBindingOptions, eventsBindingOptions, opt);\n        break;\n\n      default:\n        // when called again only update visualBinding options\n        updateOption = extend({}, visualBindingOptions, opt);\n    }\n\n    return updateOption;\n  };\n  /**\r\n   * renderIteration\r\n   * @param {object} opt\r\n   * @description\r\n   * render element's binding by supplied elementCache\r\n   * This function is desidned for FoOf, If, switch bindings\r\n   */\n\n  const renderIteration = ({\n    elementCache,\n    iterationVm,\n    bindingAttrs,\n    isRegenerate\n  }) => {\n    const bindingUpdateOption = isRegenerate ? createBindingOption(bindingUpdateConditions.init) : createBindingOption(); // enforce render even element is not in DOM tree\n\n    bindingUpdateOption.forceRender = true; // render and apply binding to template(s)\n    // this is an share function therefore passing current APP 'this' context\n    // viewModel is a dynamic generated iterationVm\n\n    renderTemplatesBinding({\n      ctx: iterationVm.$root ? iterationVm.$root.APP : iterationVm.APP,\n      elementCache: elementCache,\n      updateOption: bindingUpdateOption,\n      bindingAttrs: bindingAttrs,\n      viewModel: iterationVm\n    });\n    Binder.applyBinding({\n      elementCache: elementCache,\n      updateOption: bindingUpdateOption,\n      bindingAttrs: bindingAttrs,\n      viewModel: iterationVm\n    });\n  };\n\n  const createEventBinding = ({\n    cache = {},\n    forceRender = false,\n    type = '',\n    viewModel = {}\n  }) => {\n    const handlerName = cache.dataKey;\n    let paramList = cache.parameters;\n    let viewModelContext;\n    const APP = viewModel.APP || viewModel.$root.APP;\n\n    if (!type || !handlerName || !forceRender && !APP.$rootElement.contains(cache.el)) {\n      return;\n    }\n\n    const handlerFn = getViewModelValue(viewModel, handlerName);\n\n    if (typeof handlerFn === 'function') {\n      viewModelContext = resolveViewModelContext(viewModel, handlerName);\n      paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n\n      const handlerWrap = e => {\n        let formData;\n        let args = [];\n\n        if (type === 'submit') {\n          formData = getFormData(e.currentTarget);\n          args = [e, e.currentTarget, formData].concat(paramList);\n        } else {\n          args = [e, e.currentTarget].concat(paramList);\n        }\n\n        handlerFn.apply(viewModelContext, args);\n      };\n\n      cache.el.removeEventListener(type, handlerWrap, false);\n      cache.el.addEventListener(type, handlerWrap, false);\n    }\n  };\n\n  let bindingAttrs = bindingAttrs$1;\n  let templateSettings = templateSettings$1;\n\n  const use = (settings = {}) => {\n    if (settings.bindingAttrs) {\n      bindingAttrs = extend({}, settings.bindingAttrs);\n    }\n\n    if (settings.templateSettings) {\n      templateSettings = extend({}, settings.templateSettings);\n    }\n  };\n\n  const init = ($rootElement, viewModel = null) => {\n    _.templateSettings = templateSettings;\n    return new Binder($rootElement, viewModel, bindingAttrs);\n  }; // expose to global\n\n\n  window.dataBind = {\n    use: use,\n    init: init,\n    version: '@version@'\n  };\n\n}());\n"]}