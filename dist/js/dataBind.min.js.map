{"version":3,"file":"dataBind.min.js","sources":["../../../src/config.ts","../../../src/util.ts","../../../src/domWalker.ts","../../../src/createBindingOption.ts","../../../src/_escape.ts","../../../src/changeBinding.ts","../../../src/attrBinding.ts","../../../src/renderTemplate.ts","../../../src/renderTemplatesBinding.ts","../../../src/renderIteration.ts","../../../src/commentWrapper.ts","../../../src/renderForOfBinding.ts","../../../src/forOfBinding.ts","../../../src/renderIfBinding.ts","../../../src/ifBinding.ts","../../../src/switchBinding.ts","../../../src/createEventBinding.ts","../../../src/applyBinding.ts","../../../src/showBinding.ts","../../../src/textBinding.ts","../../../src/cssBinding.ts","../../../src/modelBinding.ts","../../../src/hoverBinding.ts","../../../src/pubSub.ts","../../../src/binder.ts","../../../src/postProcess.ts","../../../src/index.ts"],"sourcesContent":["export interface BindingAttrs {\n    comp: string;\n    tmp: string;\n    text: string;\n    click: string;\n    dblclick: string;\n    blur: string;\n    focus: string;\n    hover: string;\n    input: string;\n    change: string;\n    submit: string;\n    model: string;\n    show: string;\n    css: string;\n    attr: string;\n    forOf: string;\n    if: string;\n    switch: string;\n    case: string;\n    default: string;\n}\n\nexport const bindingAttrs: BindingAttrs = {\n    comp: 'data-bind-comp',\n    tmp: 'data-bind-tmp',\n    text: 'data-bind-text',\n    click: 'data-bind-click',\n    dblclick: 'data-bind-dblclick',\n    blur: 'data-bind-blur',\n    focus: 'data-bind-focus',\n    hover: 'data-bind-hover',\n    input: 'data-bind-input',\n    change: 'data-bind-change',\n    submit: 'data-bind-submit',\n    model: 'data-bind-model',\n    show: 'data-bind-show',\n    css: 'data-bind-css',\n    attr: 'data-bind-attr',\n    forOf: 'data-bind-for',\n    if: 'data-bind-if',\n    switch: 'data-bind-switch',\n    case: 'data-bind-case',\n    default: 'data-bind-default',\n};\n\nexport const serverRenderedAttr = 'data-server-rendered';\nexport const dataIndexAttr = 'data-index';\n\nexport interface CommentPrefix {\n    forOf: string;\n    if: string;\n    case: string;\n    default: string;\n}\n\nexport const commentPrefix: CommentPrefix = {\n    forOf: 'data-forOf_',\n    if: 'data-if_',\n    case: 'data-case_',\n    default: 'data-default_',\n};\n\nexport const commentSuffix = '_end';\n\nexport interface BindingDataReference {\n    rootDataKey: string;\n    currentData: string;\n    currentIndex: string;\n    mouseEnterHandlerName: string;\n    mouseLeaveHandlerName: string;\n}\n\nexport const bindingDataReference: BindingDataReference = {\n    rootDataKey: '$root',\n    currentData: '$data',\n    currentIndex: '$index',\n    mouseEnterHandlerName: 'in',\n    mouseLeaveHandlerName: 'out',\n};\n\nexport interface BindingUpdateConditions {\n    serverRendered: string;\n    init: string;\n}\n\nexport const bindingUpdateConditions: BindingUpdateConditions = {\n    serverRendered: 'SERVER-RENDERED',\n    init: 'INIT',\n};\n\n// maximum string length before running regex\nexport const maxDatakeyLength = 250;\n\nexport interface Constants {\n    filters: {\n        ONCE: string;\n    };\n    PARENT_REF: string;\n}\n\nexport const constants: Constants = {\n    filters: {\n        ONCE: 'once',\n    },\n    PARENT_REF: '_parent',\n};\n","import * as config from './config';\nimport type {ViewModel, BindingCache, ElementCache, DeferredObj, WrapMap, PlainObject} from './types';\n\nconst hasIsArray = Array.isArray;\n\nexport const REGEX = {\n    BAD_TAGS: /<(script|del)(?=[\\s>])[\\w\\W]*?<\\/\\1\\s*>/ig,\n    FOR_OF: /(.*?)\\s+(?:in|of)\\s+(.*)/,\n    FUNCTION_PARAM: /\\((.*?)\\)/,\n    HTML_TAG: /^[\\s]*<([a-z][^\\/\\s>]+)/i,\n    OBJECT_LITERAL: /^\\{.+\\}$/,\n    PIPE: /\\|/,\n    WHITE_SPACES: /\\s+/g,\n    LINE_BREAKS_TABS: /(\\r\\n|\\n|\\r|\\t)/gm,\n};\n\nconst IS_SUPPORT_TEMPLATE = 'content' in document.createElement('template');\n\nconst WRAP_MAP: WrapMap = {\n    div: ['div', '<div>', '</div>'],\n    thead: ['table', '<table>', '</table>'],\n    col: ['colgroup', '<table><colgroup>', '</colgroup></table>'],\n    tr: ['tbody', '<table><tbody>', '</tbody></table>'],\n    td: ['tr', '<table><tr>', '</tr></table>'],\n};\nWRAP_MAP.caption = WRAP_MAP.colgroup = WRAP_MAP.tbody = WRAP_MAP.tfoot = WRAP_MAP.thead;\nWRAP_MAP.th = WRAP_MAP.td;\n\nexport const isArray = (obj: unknown): obj is unknown[] => {\n    return hasIsArray ? Array.isArray(obj) : Object.prototype.toString.call(obj) === '[object Array]';\n};\n\nexport const isJsObject = (obj: unknown): obj is object => {\n    return obj !== null && typeof obj === 'object' && Object.prototype.toString.call(obj) === '[object Object]';\n};\n\nexport const isPlainObject = (obj: unknown): obj is PlainObject => {\n    if (!isJsObject(obj)) {\n        return false;\n    }\n\n    // If has modified constructor\n    const ctor = (obj as PlainObject).constructor;\n    if (typeof ctor !== 'function') return false;\n\n    // If has modified prototype\n    const prot = ctor.prototype;\n    if (isJsObject(prot) === false) return false;\n\n    // If constructor does not have an Object-specific method\n    if (prot.hasOwnProperty('isPrototypeOf') === false) {\n        return false;\n    }\n\n    // Most likely a plain Object\n    return true;\n};\n\n// test if string contains '{...}'. string must not contains tab, line breaks\nexport const isObjectLiteralString = (str: string = ''): boolean => {\n    return REGEX.OBJECT_LITERAL.test(str);\n};\n\nexport const isEmptyObject = (obj: unknown): boolean => {\n    if (isJsObject(obj)) {\n        return Object.getOwnPropertyNames(obj).length === 0;\n    }\n    return false;\n};\n\nconst getFirstHtmlStringTag = (htmlString: string): string | null => {\n    const match = htmlString.match(REGEX.HTML_TAG);\n    if (match) {\n        return match[1];\n    }\n    return null;\n};\n\nconst removeBadTags = (htmlString: string = ''): string => {\n    return htmlString.replace(REGEX.BAD_TAGS, '');\n};\n\nexport const createHtmlFragment = (htmlString: unknown): DocumentFragment | null => {\n    if (typeof htmlString !== 'string') {\n        return null;\n    }\n    // use template element\n    if (IS_SUPPORT_TEMPLATE) {\n        const template = document.createElement('template');\n        template.innerHTML = removeBadTags(htmlString);\n        return template.content;\n    }\n    // use document fragment with wrap html tag for tr, td etc.\n    const fragment = document.createDocumentFragment();\n    const queryContainer = document.createElement('div');\n    const firstTag = getFirstHtmlStringTag(htmlString);\n    const wrap = WRAP_MAP[firstTag || 'div'];\n\n    if (wrap[0] === 'div') {\n        return document.createRange().createContextualFragment(htmlString);\n    }\n\n    queryContainer.insertAdjacentHTML('beforeend', `${wrap[1]}${htmlString}${wrap[2]}`);\n\n    const query = queryContainer.querySelector(wrap[0]);\n\n    while (query && query.firstChild) {\n        fragment.appendChild(query.firstChild);\n    }\n\n    return fragment;\n};\n\nexport const generateElementCache = (bindingAttrs: PlainObject | unknown[]): ElementCache => {\n    const elementCache: ElementCache = {};\n\n    for (const i in bindingAttrs) {\n        if (bindingAttrs.hasOwnProperty(i)) {\n            if (isArray(bindingAttrs)) {\n                elementCache[bindingAttrs[i] as string] = [];\n            } else {\n                elementCache[i] = [];\n            }\n        }\n    }\n\n    return elementCache;\n};\n\n\n/**\n * List of dangerous property names that should not be accessed\n * to prevent prototype pollution attacks\n */\nconst DANGEROUS_PROPS = ['__proto__', 'constructor', 'prototype'];\n\n/**\n * Check if a property name is safe to access\n */\nconst isSafeProperty = (prop: string): boolean => {\n    return !DANGEROUS_PROPS.includes(prop);\n};\n\n// simplified version of Lodash _.get with prototype pollution protection\nconst _get = (obj: unknown, path: string, def?: unknown): unknown => {\n    const fullPath = path\n        .replace(/\\[/g, '.')\n        .replace(/]/g, '')\n        .split('.')\n        .filter(Boolean);\n\n    let current: unknown = obj;\n    for (const step of fullPath) {\n        // Prevent access to dangerous properties\n        if (!step || !isSafeProperty(step)) {\n            return def;\n        }\n\n        if (current == null) {\n            return def;\n        }\n\n        current = (current as PlainObject)[step];\n\n        if (current === undefined) {\n            return def;\n        }\n    }\n\n    return current;\n};\n\n/**\n * getViewModelValue\n * @description walk a object by provided string path. eg 'a.b.c'\n * @param {object} viewModel\n * @param {string} prop\n * @return {object}\n */\nexport const getViewModelValue = (viewModel: ViewModel, prop: string): unknown => {\n    return _get(viewModel, prop);\n};\n\n// simplified version of Lodash _.set with prototype pollution protection\n// https://stackoverflow.com/questions/54733539/javascript-implementation-of-lodash-set-method\nconst _set = (obj: PlainObject, path: string | string[], value: unknown): PlainObject => {\n    if (Object(obj) !== obj) return obj; // When obj is not an object\n\n    // If not yet an array, get the keys from the string-path\n    let pathArray: string[];\n    if (!Array.isArray(path)) {\n        pathArray = path.toString().match(/[^.[\\]]+/g) || [];\n    } else {\n        pathArray = path;\n    }\n\n    // Check all keys in path for dangerous properties\n    for (const key of pathArray) {\n        if (!isSafeProperty(key)) {\n            console.warn(`Blocked attempt to set dangerous property: ${key}`);\n            return obj;\n        }\n    }\n\n    // Iterate all of them except the last one\n    const lastKey = pathArray[pathArray.length - 1];\n    const target = pathArray.slice(0, -1).reduce((a: PlainObject, c: string, i: number) => {\n        // Prevent setting dangerous properties\n        if (!isSafeProperty(c)) {\n            return a;\n        }\n\n        if (Object(a[c]) === a[c]) {\n            // Key exists and is an object, follow that path\n            return a[c] as PlainObject;\n        }\n\n        // Create the key. Is the next key a potential array-index?\n        const nextKey = pathArray[i + 1];\n        a[c] = Math.abs(Number(nextKey)) >> 0 === +nextKey ? [] : {};\n        return a[c] as PlainObject;\n    }, obj);\n\n    // Set the final value only if the key is safe\n    if (isSafeProperty(lastKey)) {\n        target[lastKey] = value;\n    }\n\n    // Return the top-level object to allow chaining\n    return obj;\n};\n\n/**\n * setViewModelValue\n * @description populate viewModel object by path string\n * @param {object} obj\n * @param {string} prop\n * @param {string} value\n * @return {call} underscore set\n */\nexport const setViewModelValue = (obj: PlainObject, prop: string, value: unknown): PlainObject => {\n    return _set(obj, prop, value);\n};\n\nexport const getViewModelPropValue = (viewModel: ViewModel, bindingCache: BindingCache): unknown => {\n    let dataKey = bindingCache.dataKey;\n    let paramList = bindingCache.parameters;\n    const isInvertBoolean = dataKey && dataKey.charAt(0) === '!';\n\n    if (isInvertBoolean && dataKey) {\n        dataKey = isInvertBoolean ? dataKey.substring(1) : dataKey;\n    }\n\n    let ret = dataKey ? getViewModelValue(viewModel, dataKey) : undefined;\n\n    if (typeof ret === 'function') {\n        const viewModelContext = resolveViewModelContext(viewModel, dataKey || '');\n        const oldViewModelProValue = bindingCache.elementData ? bindingCache.elementData.viewModelPropValue : null;\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n        // let args = [oldViewModelProValue, bindingCache.el].concat(paramList);\n        const args = paramList.concat([oldViewModelProValue, bindingCache.el]);\n        ret = (ret as Function).apply(viewModelContext, args);\n    }\n\n    ret = isInvertBoolean ? !ret : ret;\n\n    // call through fitlers to get final value\n    ret = filtersViewModelPropValue({\n        value: ret,\n        viewModel,\n        bindingCache,\n    });\n\n    return ret;\n};\n\nconst filtersViewModelPropValue = ({value, viewModel, bindingCache}: {value: unknown, viewModel: ViewModel, bindingCache: BindingCache}): unknown => {\n    let ret = value;\n    if (bindingCache.filters) {\n        each(bindingCache.filters, (index: string | number, filter: string) => {\n            const viewModelContext = resolveViewModelContext(viewModel, filter);\n            const filterFn = getViewModelValue.call(viewModelContext, viewModelContext, filter);\n            try {\n                ret = (filterFn as Function).call(viewModelContext, ret);\n            } catch (err) {\n                throwErrorMessage(err, `Invalid filter: ${filter}`);\n            }\n        });\n    }\n    return ret;\n};\n\nexport const parseStringToJson = (str: string): PlainObject => {\n    // fix unquote or single quote keys and replace single quote to double quote\n    const ret = str.replace(/(\\s*?{\\s*?|\\s*?,\\s*?)(['\"])?([a-zA-Z0-9]+)(['\"])?:/g, '$1\"$3\":').replace(/'/g, '\"');\n    return JSON.parse(ret) as PlainObject;\n};\n\n/**\n * arrayRemoveMatch\n * @description remove match items in fromArray out of toArray\n * @param {array} toArray\n * @param {array} frommArray\n * @return {boolean}\n */\nexport const arrayRemoveMatch = (toArray: unknown[], frommArray: unknown[]): unknown[] => {\n    return toArray.filter((value, _index) => {\n        return frommArray.indexOf(value) < 0;\n    });\n};\n\nexport const getFormData = ($form: HTMLFormElement): PlainObject => {\n    const data: PlainObject = {};\n\n    if (!($form instanceof HTMLFormElement)) {\n        return data;\n    }\n\n    const formData = new FormData($form);\n\n    formData.forEach((value, key) => {\n        if (!Object.prototype.hasOwnProperty.call(Object, key)) {\n            data[key] = value;\n            return;\n        }\n        if (!Array.isArray(data[key])) {\n            data[key] = [data[key]];\n        }\n        (data[key] as unknown[]).push(value);\n    });\n\n    return data;\n};\n\n/**\n * getFunctionParameterList\n * @description convert parameter string to arrary\n * eg. '(\"a\",\"b\",\"c\")' > [\"a\",\"b\",\"c\"]\n * @param {string} str\n * @return {array} paramlist\n */\nexport const getFunctionParameterList = (str: string): string[] | undefined => {\n    if (!str || str.length > config.maxDatakeyLength) {\n        return;\n    }\n    const paramlist = str.match(REGEX.FUNCTION_PARAM);\n\n    if (paramlist && paramlist[1]) {\n        const params = paramlist[1].split(',');\n        params.forEach((v, i) => {\n            params[i] = v.trim();\n        });\n        return params;\n    }\n    return undefined;\n};\n\nexport const extractFilterList = (cacheData: Partial<BindingCache>): Partial<BindingCache> => {\n    if (!cacheData || !cacheData.dataKey || cacheData.dataKey.length > config.maxDatakeyLength) {\n        return cacheData;\n    }\n    const filterList = cacheData.dataKey.split(REGEX.PIPE);\n    let isOnceIndex: number | undefined;\n    cacheData.dataKey = filterList[0].trim();\n    if (filterList.length > 1) {\n        filterList.shift();\n        filterList.forEach((v, i) => {\n            filterList[i] = v.trim();\n            if (filterList[i] === config.constants.filters.ONCE) {\n                cacheData.isOnce = true;\n                isOnceIndex = i;\n            }\n        });\n        // don't store filter 'once' - because it is internal logic not a property from viewModel\n        if (isOnceIndex !== undefined && isOnceIndex >= 0) {\n            filterList.splice(isOnceIndex, 1);\n        }\n        cacheData.filters = filterList;\n    }\n    return cacheData;\n};\n\nexport const invertObj = (sourceObj: PlainObject): PlainObject => {\n    return Object.keys(sourceObj).reduce((obj: PlainObject, key: string) => {\n        const invertedKey = sourceObj[key];\n        // Prevent prototype pollution by checking if the inverted key is safe\n        if (typeof invertedKey === 'string' && isSafeProperty(invertedKey)) {\n            obj[invertedKey] = key;\n        }\n        return obj;\n    }, {});\n};\n\nexport const createDeferredObj = (): DeferredObj => {\n    const dfObj = {} as DeferredObj;\n\n    dfObj.promise = new Promise((resolve, reject) => {\n        dfObj.resolve = resolve;\n        dfObj.reject = reject;\n    });\n\n    return dfObj;\n};\n\n/**\n * debounce\n * @description decorate a function to be debounce using requestAnimationFrame\n * @param {function} fn\n * @param {context} ctx\n * @return {function}\n */\nexport const debounceRaf = (fn: Function, ctx: unknown = null): Function => {\n    return (function (fn: Function, ctx: unknown) {\n        let dfObj = createDeferredObj();\n        let rafId = 0;\n\n        // return decorated fn\n        return function () {\n\n            const args = Array.from ? Array.from(arguments) : Array.prototype.slice.call(arguments);\n\n            window.cancelAnimationFrame(rafId);\n            rafId = window.requestAnimationFrame(() => {\n                try {\n                    // fn is Binder.render function\n                    fn.apply(ctx, args);\n                    // dfObj.resolve is function provided in .then promise chain\n                    // ctx is the current component\n                    dfObj.resolve(ctx);\n                } catch (err) {\n                    console.error('error in rendering: ', err);\n                    dfObj.reject(err);\n                }\n\n                // reset dfObj - otherwise then callbacks will not be in execution order\n                // example:\n                // myApp.render().then(function(){console.log('ok1')});\n                // myApp.render().then(function(){console.log('ok2')});\n                // myApp.render().then(function(){console.log('ok3')});\n                // >> ok1, ok2, ok3\n                dfObj = createDeferredObj();\n\n                window.cancelAnimationFrame(rafId);\n            });\n\n            return dfObj.promise;\n        };\n    })(fn, ctx);\n};\n\n/**\n * getNodeAttrObj\n * @description convert Node attributes object to a json object\n * @param {object} node\n * @param {array} skipList\n * @return {object}\n */\nexport const getNodeAttrObj = (node: HTMLElement, skipList?: string | string[]): Record<string, string> | undefined => {\n    let attributesLength = 0;\n    let skipArray: string[] | undefined;\n\n    if (!node || node.nodeType !== 1 || !node.hasAttributes()) {\n        return;\n    }\n    if (skipList) {\n        skipArray = [];\n        skipArray = typeof skipList === 'string' ? [skipList] : skipList;\n    }\n    const attrObj: Record<string, string> = {};\n    attributesLength = node.attributes.length;\n\n    if (attributesLength) {\n        for (let i = 0; i < attributesLength; i += 1) {\n            const attribute = node.attributes.item(i);\n            if (attribute) {\n                attrObj[attribute.nodeName] = attribute.nodeValue || '';\n            }\n        }\n    }\n\n    if (isArray(skipArray)) {\n        skipArray.forEach((item) => {\n            if (attrObj[item]) {\n                delete attrObj[item];\n            }\n        });\n    }\n    return attrObj;\n};\n\n/**\n * extend\n * @param {boolean} isDeepMerge\n * @param {object} target\n * @param {object} sources\n * @return {object} merged object\n */\nexport const extend = (isDeepMerge: boolean = false, target?: PlainObject, ...sources: PlainObject[]): PlainObject => {\n    if (!sources.length) {\n        return target || {};\n    }\n    const source = sources.shift();\n    if (source === undefined) {\n        return target || {};\n    }\n\n    if (!isDeepMerge) {\n        return Object.assign(target || {}, source, ...sources);\n    }\n\n    if (isMergebleObject(target) && isMergebleObject(source)) {\n        Object.keys(source).forEach((key) => {\n            if (isMergebleObject(source[key])) {\n                if (!target[key]) {\n                    target[key] = {};\n                }\n                extend(true, target[key] as PlainObject, source[key] as PlainObject);\n            } else {\n                target[key] = source[key];\n            }\n        });\n    }\n\n    return extend(true, target, ...sources);\n};\n\nexport const each = (obj: unknown[] | PlainObject, fn: Function): void => {\n    if (typeof obj !== 'object' || typeof fn !== 'function') {\n        return;\n    }\n    let keys: string[] = [];\n    let keysLength = 0;\n    const isArrayObj = isArray(obj);\n    let key: string | number;\n    let value: unknown;\n    let i = 0;\n\n    if (isArrayObj) {\n        keysLength = obj.length;\n    } else if (isJsObject(obj)) {\n        keys = Object.keys(obj);\n        keysLength = keys.length;\n    } else {\n        throw new TypeError('Object is not an array or object');\n    }\n\n    for (i = 0; i < keysLength; i += 1) {\n        if (isArrayObj) {\n            key = i;\n            value = (obj as unknown[])[i];\n        } else {\n            key = keys[i];\n            value = (obj as PlainObject)[key];\n        }\n        fn(key, value);\n    }\n};\n\nconst isMergebleObject = (item: unknown): item is PlainObject => {\n    return isJsObject(item) && !isArray(item);\n};\n\n/**\n * cloneDomNode\n * @param {object} element\n * @return {object} cloned element\n * @description helper function to clone node\n */\nexport const cloneDomNode = (element: HTMLElement): HTMLElement => {\n    return element.cloneNode(true) as HTMLElement;\n};\n\n/**\n * insertAfter\n * @param {object} parentNode\n * @param {object} newNode\n * @param {object} referenceNode\n * @return {object} node\n * @description helper function to insert new node before the reference node\n */\nexport const insertAfter = (parentNode: Node, newNode: Node, referenceNode: Node | null): Node => {\n    const refNextElement = referenceNode && referenceNode.nextSibling ? referenceNode.nextSibling : null;\n    return parentNode.insertBefore(newNode, refNextElement);\n};\n\nexport const resolveViewModelContext = (viewModel: ViewModel, datakey: string): ViewModel => {\n    let ret = viewModel;\n    if (typeof datakey !== 'string') {\n        return ret;\n    }\n    const bindingDataContext = datakey.split('.');\n    if (bindingDataContext.length > 1) {\n        if (bindingDataContext[0] === config.bindingDataReference.rootDataKey) {\n            ret = (viewModel[config.bindingDataReference.rootDataKey] as ViewModel) || viewModel;\n        } else if (bindingDataContext[0] === config.bindingDataReference.currentData) {\n            ret = (viewModel[config.bindingDataReference.currentData] as ViewModel) || viewModel;\n        }\n    }\n    return ret;\n};\n\nexport const resolveParamList = (viewModel: ViewModel, paramList: unknown[]): unknown[] | undefined => {\n    if (!viewModel || !isArray(paramList)) {\n        return;\n    }\n    return paramList.map((param) => {\n        let resolvedParam: unknown = param;\n        if (typeof param === 'string') {\n            resolvedParam = param.trim();\n\n            if (resolvedParam === config.bindingDataReference.currentIndex) {\n                // convert '$index' to value\n                resolvedParam = viewModel[config.bindingDataReference.currentIndex];\n            } else if (resolvedParam === config.bindingDataReference.currentData) {\n                // convert '$data' to value or current viewModel\n                resolvedParam = viewModel[config.bindingDataReference.currentData] || viewModel;\n            } else if (resolvedParam === config.bindingDataReference.rootDataKey) {\n                // convert '$root' to root viewModel\n                resolvedParam = viewModel[config.bindingDataReference.rootDataKey] || viewModel;\n            }\n        }\n        return resolvedParam;\n    });\n};\n\nexport const removeElement = (el: HTMLElement): void => {\n    if (el && el.parentNode) {\n        el.parentNode.removeChild(el);\n    }\n};\n\nexport const emptyElement = (node: HTMLElement): HTMLElement => {\n    if (node && node.firstChild) {\n        while (node.firstChild) {\n            node.removeChild(node.firstChild);\n        }\n    }\n    return node;\n};\n\n/**\n * areNodesEqual\n * @description Compare two nodes to determine if they are structurally equal\n * @param {Node} node1\n * @param {Node} node2\n * @return {boolean}\n */\nconst areNodesEqual = (node1: Node, node2: Node): boolean => {\n    // Different node types\n    if (node1.nodeType !== node2.nodeType) {\n        return false;\n    }\n\n    // Text nodes - compare content\n    if (node1.nodeType === 3) {\n        return node1.nodeValue === node2.nodeValue;\n    }\n\n    // Element nodes - compare tag names\n    if (node1.nodeType === 1) {\n        const el1 = node1 as HTMLElement;\n        const el2 = node2 as HTMLElement;\n        return el1.tagName === el2.tagName;\n    }\n\n    // Other node types (comments, etc.)\n    return node1.nodeValue === node2.nodeValue;\n};\n\n/**\n * updateElementAttributes\n * @description Update element attributes to match new element\n * Only updates attributes that are in the new element.\n * Does NOT remove attributes that exist only in the existing element,\n * as these might be runtime-added by the binding system.\n * @param {HTMLElement} existingElement\n * @param {HTMLElement} newElement\n */\nconst updateElementAttributes = (existingElement: HTMLElement, newElement: HTMLElement): void => {\n    // Get all attributes from new element\n    const newAttrs = newElement.attributes;\n\n    // Update or add attributes from new element\n    for (let i = 0; i < newAttrs.length; i++) {\n        const attr = newAttrs[i];\n        if (attr && attr.name) {\n            const existingValue = existingElement.getAttribute(attr.name);\n            if (existingValue !== attr.value) {\n                existingElement.setAttribute(attr.name, attr.value || '');\n            }\n        }\n    }\n\n    // NOTE: We deliberately do NOT remove attributes that exist in the existing element\n    // but not in the new element. This preserves runtime-added attributes from the binding\n    // system (like data-bind-*, data-index, event handlers, etc.)\n};\n\n/**\n * createFragmentFromChildren\n * @description Create a DocumentFragment from a node's children\n * @param {Node} node\n * @return {DocumentFragment}\n */\nconst createFragmentFromChildren = (node: Node): DocumentFragment => {\n    const fragment = document.createDocumentFragment();\n    const children = Array.from(node.childNodes);\n    children.forEach(child => {\n        fragment.appendChild(child.cloneNode(true));\n    });\n    return fragment;\n};\n\n/**\n * updateDomWithMinimalChanges\n * @description Updates DOM by comparing existing nodes with new fragment\n * Only modifies what changed - performs minimal DOM manipulation\n * @param {HTMLElement} targetElement - The existing DOM element to update\n * @param {DocumentFragment} newFragment - The new content to apply\n */\nexport const updateDomWithMinimalChanges = (\n    targetElement: HTMLElement,\n    newFragment: DocumentFragment,\n): void => {\n    const newNodes = Array.from(newFragment.childNodes);\n    const existingNodes = Array.from(targetElement.childNodes);\n\n    // Loop through new nodes and compare with existing\n    for (let i = 0; i < newNodes.length; i++) {\n        const newNode = newNodes[i];\n        const existingNode = existingNodes[i];\n\n        if (!existingNode) {\n            // New node doesn't have a corresponding existing node - append it\n            targetElement.appendChild(newNode);\n        } else if (!areNodesEqual(existingNode, newNode)) {\n            // Nodes are different types or tags - replace entire node\n            targetElement.replaceChild(newNode, existingNode);\n        } else {\n            // Nodes are structurally equal - update content/attributes\n            if (newNode.nodeType === 1 && existingNode.nodeType === 1) {\n                // Element nodes - update attributes and recurse into children\n                updateElementAttributes(existingNode as HTMLElement, newNode as HTMLElement);\n                updateDomWithMinimalChanges(\n                    existingNode as HTMLElement,\n                    createFragmentFromChildren(newNode),\n                );\n            } else if (newNode.nodeType === 3) {\n                // Text nodes - update text content if different\n                if (existingNode.nodeValue !== newNode.nodeValue) {\n                    existingNode.nodeValue = newNode.nodeValue;\n                }\n            }\n        }\n    }\n\n    // Remove extra existing nodes that don't have corresponding new nodes\n    for (let i = existingNodes.length - 1; i >= newNodes.length; i--) {\n        if (existingNodes[i] && existingNodes[i].parentNode) {\n            targetElement.removeChild(existingNodes[i]);\n        }\n    }\n};\n\nexport const throwErrorMessage = (err: unknown = null, errorMessage: string = ''): void => {\n    const message = err && typeof err === 'object' && 'message' in err ? (err as Error).message : errorMessage;\n    if (typeof console.error === 'function') {\n        console.error(message);\n        return;\n    }\n    console.log(message);\n};\n\n/**\n * parseBindingObjectString\n * @description parse bining object string to object with value always stringify\n * @param {string} str - eg '{ id: $data.id, name: $data.name }'\n * @return {object} - eg { id: '$data.id', name: '$data.name'}\n */\nexport const parseBindingObjectString = (str: string = ''): Record<string, string> | null => {\n    let objectLiteralString = str.trim();\n    const ret: Record<string, string> = {};\n\n    if (!REGEX.OBJECT_LITERAL.test(str)) {\n        return null;\n    }\n\n    // clearn up line breaks and remove first { character\n    objectLiteralString = objectLiteralString\n        .replace(REGEX.LINE_BREAKS_TABS, '')\n        .substring(1);\n\n    // remove last } character\n    objectLiteralString = objectLiteralString.substring(0, objectLiteralString.length - 1);\n\n    objectLiteralString.split(',').forEach((item) => {\n        const keyVal = item.trim();\n        // ignore if last empty item - eg split last comma in object literal\n        if (keyVal) {\n            const prop = keyVal.split(':');\n            const key = prop[0].trim();\n            ret[key] = `${prop[1]}`.trim();\n        }\n    });\n\n    return ret;\n};\n","import {invertObj, extractFilterList, getFunctionParameterList, REGEX} from './util';\nimport {constants} from './config';\nimport type {PlainObject, BindingAttrs, ElementCache, BindingCache} from './types';\n\nlet bindingAttrsMap: PlainObject | undefined;\n\n/**\n * walkDOM\n * @description by Douglas Crockford - walk each DOM node and calls provided callback function\n * start walk from firstChild\n * @param {object} node\n * @param {function} func\n */\nconst walkDOM = (node: HTMLElement, func: (node: HTMLElement) => boolean): void => {\n    let parseChildNode = true;\n    let currentNode = node.firstElementChild as HTMLElement | null;\n    while (currentNode) {\n        parseChildNode = func(currentNode);\n        if (parseChildNode) {\n            walkDOM(currentNode, func);\n        }\n        currentNode = currentNode.nextElementSibling as HTMLElement | null;\n    }\n};\n\nconst getAttributesObject = (node: HTMLElement): PlainObject => {\n    const ret: PlainObject = {};\n    Array.prototype.slice.call(node.attributes).forEach((item: Attr) => {\n        ret[item.name] = item.value;\n    });\n    return ret;\n};\n\nconst checkSkipChildParseBindings = (attrObj: PlainObject = {}, bindingAttrs: BindingAttrs): string[] => {\n    return [bindingAttrs.forOf, bindingAttrs.if, bindingAttrs.case, bindingAttrs.default].filter((type: string) => {\n        return typeof attrObj[type] !== 'undefined';\n    });\n};\n\nconst rootSkipCheck = (node: HTMLElement): boolean => {\n    return node.tagName === 'SVG';\n};\n\nconst defaultSkipCheck = (node: HTMLElement, bindingAttrs: BindingAttrs): boolean => {\n    return node.tagName === 'SVG' || node.hasAttribute(bindingAttrs.comp);\n};\n\nconst populateBindingCache = ({node, attrObj, bindingCache, type}: {\n    node: HTMLElement;\n    attrObj: PlainObject;\n    bindingCache: ElementCache;\n    type: string;\n}): ElementCache => {\n    let attrValue: string;\n    let cacheData: Partial<BindingCache>;\n\n    if (bindingAttrsMap && bindingAttrsMap[type] && typeof attrObj[type] !== 'undefined') {\n        bindingCache[type] = bindingCache[type] || [];\n        attrValue = (attrObj[type] as string) || '';\n\n        if (attrValue) {\n            attrValue = attrValue.replace(REGEX.LINE_BREAKS_TABS, '').replace(REGEX.WHITE_SPACES, ' ').trim();\n        }\n\n        cacheData = {\n            el: node,\n            dataKey: attrValue,\n        };\n\n        // populate cacheData.filters. update filterList first item as dataKey\n        cacheData = extractFilterList(cacheData);\n\n        // populate cacheData.parameters\n        // for store function call parameters eg. '$index', '$root'\n        // useful with DOM for-loop template as reference to binding data\n        const paramList = getFunctionParameterList(cacheData.dataKey || '');\n        if (paramList) {\n            cacheData.parameters = paramList;\n            cacheData.dataKey = (cacheData.dataKey || '').replace(REGEX.FUNCTION_PARAM, '').trim();\n        }\n        // store parent array reference to cacheData\n        cacheData[constants.PARENT_REF] = bindingCache[type];\n        bindingCache[type].push(cacheData as BindingCache);\n    }\n    return bindingCache;\n};\n\nconst createBindingCache = ({rootNode = null, bindingAttrs = {} as BindingAttrs, skipCheck, isRenderedTemplate = false}: {\n    rootNode?: HTMLElement | null;\n    bindingAttrs?: BindingAttrs;\n    skipCheck?: (node: HTMLElement) => boolean;\n    isRenderedTemplate?: boolean;\n}): ElementCache => {\n    let bindingCache: ElementCache = {};\n\n    if (!(rootNode instanceof window.Node)) {\n        throw new TypeError('walkDOM: Expected a DOM node');\n    }\n\n    bindingAttrsMap = bindingAttrsMap || invertObj(bindingAttrs);\n\n    const parseNode = (\n        node: HTMLElement,\n        skipNodeCheckFn: (node: HTMLElement, bindingAttrs: BindingAttrs) => boolean = defaultSkipCheck,\n    ): boolean => {\n        let isSkipForOfChild = false;\n\n        if (node.nodeType !== 1 || !node.hasAttributes()) {\n            return true;\n        }\n        if (skipNodeCheckFn(node, bindingAttrs) || (typeof skipCheck === 'function' && skipCheck(node))) {\n            return false;\n        }\n\n        // when creating sub bindingCache if is for tmp binding\n        // skip same element that has forOf binding the  forOf is alredy parsed\n        const attrObj = getAttributesObject(node);\n        const hasSkipChildParseBindings = checkSkipChildParseBindings(attrObj, bindingAttrs);\n        let iterateList: string[] = [];\n\n        if (hasSkipChildParseBindings.length) {\n            isSkipForOfChild = true;\n            iterateList = hasSkipChildParseBindings;\n        } else if (isRenderedTemplate && attrObj[bindingAttrs.tmp]) {\n            // skip current node parse if was called by node has template binding and already rendered\n            return true;\n        } else {\n            iterateList = Object.keys(attrObj);\n        }\n\n        iterateList.forEach((key: string) => {\n            // skip for switch case and default bining\n            if (key !== bindingAttrs.case && key !== bindingAttrs.default) {\n                bindingCache = populateBindingCache({\n                    node,\n                    attrObj,\n                    bindingCache,\n                    type: key,\n                });\n            }\n        });\n\n        // after cache forOf skip parse child nodes\n        if (isSkipForOfChild) {\n            return false;\n        }\n\n        return true;\n    };\n\n    if (parseNode(rootNode, rootSkipCheck)) {\n        walkDOM(rootNode, parseNode);\n    }\n    return bindingCache;\n};\n\nexport default createBindingCache;\n","import {\n    bindingUpdateConditions,\n} from './config';\nimport {extend} from './util';\n\nexport interface BindingOption {\n    templateBinding?: boolean;\n    textBinding?: boolean;\n    cssBinding?: boolean;\n    ifBinding?: boolean;\n    showBinding?: boolean;\n    modelBinding?: boolean;\n    attrBinding?: boolean;\n    forOfBinding?: boolean;\n    switchBinding?: boolean;\n    changeBinding?: boolean;\n    clickBinding?: boolean;\n    dblclickBinding?: boolean;\n    blurBinding?: boolean;\n    focusBinding?: boolean;\n    hoverBinding?: boolean;\n    inputBinding?: boolean;\n    submitBinding?: boolean;\n    forceRender?: boolean;\n    [key: string]: unknown;\n}\n\n/**\n * createBindingOption\n * @param {string} condition\n * @param {object} opt\n * @description\n * generate binding update option object by condition\n * @return {object} updateOption\n */\nconst createBindingOption = (condition: string = '', opt: BindingOption = {}): BindingOption => {\n    const visualBindingOptions: BindingOption = {\n        templateBinding: false,\n        textBinding: true,\n        cssBinding: true,\n        ifBinding: true,\n        showBinding: true,\n        modelBinding: true,\n        attrBinding: true,\n        forOfBinding: true,\n        switchBinding: true,\n    };\n    const eventsBindingOptions: BindingOption = {\n        changeBinding: true,\n        clickBinding: true,\n        dblclickBinding: true,\n        blurBinding: true,\n        focusBinding: true,\n        hoverBinding: true,\n        inputBinding: true,\n        submitBinding: true,\n    };\n    // this is visualBindingOptions but everything false\n    // concrete declear for performance purpose\n    const serverRenderedOptions: BindingOption = {\n        templateBinding: false,\n        textBinding: false,\n        cssBinding: false,\n        ifBinding: false,\n        showBinding: false,\n        modelBinding: false,\n        attrBinding: false,\n        forOfBinding: false,\n        switchBinding: false,\n    };\n    let updateOption: BindingOption = {};\n\n    switch (condition) {\n        case bindingUpdateConditions.serverRendered:\n            updateOption = extend(false, {}, eventsBindingOptions, serverRenderedOptions, opt);\n            break;\n        case bindingUpdateConditions.init:\n        // flag templateBinding to true to render tempalte(s)\n            opt.templateBinding = true;\n            opt.forceRender = true;\n            updateOption = extend(false, {}, visualBindingOptions, eventsBindingOptions, opt);\n            break;\n        default:\n        // when called again only update visualBinding options\n            updateOption = extend(false, {}, visualBindingOptions, opt);\n    }\n\n    return updateOption;\n};\n\nexport default createBindingOption;\n","/**\n * _escape\n * @description\n * https://github.com/lodash/lodash/blob/master/escape.js\n */\n\nconst baseToString = (value: unknown): string => {\n    if (typeof value == 'string') {\n        return value;\n    }\n    return value == null ? '' : `${value}`;\n};\n\n/** Used to match HTML entities and HTML characters. */\nconst reUnescapedHtml = /[&<>\"'`]/g;\nconst reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n/** Used to map characters to HTML entities. */\nconst htmlEscapes: Record<string, string> = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    '\\'': '&#39;',\n    '`': '&#96;',\n};\n\n/**\n  * escapeHtmlChar\n  * @description convert characters to HTML entities.\n  * @private\n  * @param {string} chr The matched character to escape.\n  * @return {string} Returns the escaped character.\n  */\nconst escapeHtmlChar = (chr: string): string => {\n    return htmlEscapes[chr];\n};\n\n/**\n * Converts the characters \"&\", \"<\", \">\", '\"', \"'\", and \"\\`\", in `string` to\n * their corresponding HTML entities.\n * @param {string} string\n * @return {string} string\n */\nconst escape = (string: unknown): string => {\n    // Reset `lastIndex` because in IE < 9 `String#replace` does not.\n    const strValue = baseToString(string);\n    return (strValue && reHasUnescapedHtml.test(strValue)) ?\n        strValue.replace(reUnescapedHtml, escapeHtmlChar) :\n        strValue;\n};\n\nexport default escape;\n","\nimport {\n    getViewModelValue,\n    setViewModelValue,\n    resolveViewModelContext,\n    resolveParamList,\n} from './util';\nimport _escape from './_escape';\nimport type {BindingCache, ViewModel, BindingAttrs} from './types';\n\n/**\n * Create change handler\n */\nconst createChangeHandler = (\n    viewModel: ViewModel,\n    modelDataKey: string | null,\n    paramList: unknown[],\n    handlerFn: Function,\n    viewModelContext: ViewModel,\n): EventListener => {\n    let oldValue: unknown = '';\n    let newValue: unknown = '';\n\n    return function changeHandler(this: HTMLInputElement, e: Event) {\n        const $this = this;\n        const isCheckbox = $this.type === 'checkbox';\n        newValue = isCheckbox ? $this.checked : _escape($this.value);\n        // set data to viewModel\n        if (modelDataKey) {\n            oldValue = getViewModelValue(viewModel, modelDataKey);\n            setViewModelValue(viewModel, modelDataKey, newValue);\n        }\n        const args = [e, e.currentTarget, newValue, oldValue, ...paramList];\n        handlerFn.apply(viewModelContext, args);\n        oldValue = newValue;\n    };\n};\n\ninterface ChangeBindingParams {\n    cache: BindingCache;\n    viewModel: ViewModel;\n    bindingAttrs: BindingAttrs;\n    forceRender: boolean;\n    type?: string;\n}\n\n/**\n * changeBinding\n * @description input element on change event binding. DOM -> viewModel update\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {boolean} forceRender\n */\nconst changeBinding = ({\n    cache,\n    viewModel,\n    bindingAttrs,\n    forceRender,\n    type = 'change',\n}: ChangeBindingParams): void => {\n    const handlerName = cache.dataKey;\n    let paramList = cache.parameters;\n    const modelDataKey = cache.el.getAttribute(bindingAttrs.model);\n    let viewModelContext: ViewModel;\n    const APP = viewModel.APP || viewModel.$root?.APP;\n    const rootElement = APP?.$rootElement as HTMLElement | undefined;\n\n    if (!handlerName || (!forceRender && rootElement && !rootElement.contains(cache.el))) {\n        return;\n    }\n\n    const handlerFn = getViewModelValue(viewModel, handlerName);\n\n    if (typeof handlerFn === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n\n        const changeHandler = createChangeHandler(\n            viewModel,\n            modelDataKey,\n            paramList,\n            handlerFn,\n            viewModelContext,\n        );\n\n        // assign on change event\n        cache.el.removeEventListener(type, changeHandler, false);\n        cache.el.addEventListener(type, changeHandler, false);\n    }\n};\n\nexport default changeBinding;\n","import {\n    extend,\n    getViewModelPropValue,\n    isPlainObject,\n    isEmptyObject,\n    isObjectLiteralString,\n    parseBindingObjectString,\n    each,\n} from './util';\nimport type {BindingCache, ViewModel, PlainObject} from './types';\n\n/**\n * attrBinding\n * @description\n * DOM decleartive attr binding. update elenment attributes\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n */\nconst attrBinding = (cache: BindingCache = {} as BindingCache, viewModel: ViewModel, _bindingAttrs?: unknown, _forceRender?: unknown): void => {\n    if (!cache.dataKey) {\n        return;\n    }\n    // check if Object Literal String style dataKey\n    const isObjLiteralStr = isObjectLiteralString(cache.dataKey);\n\n    // resolve vmAttrObj, when Object Literal String style if will be object without resolve each value\n    // otherwise, resolve value from viewModel\n    const vmAttrObj = isObjLiteralStr ? parseBindingObjectString(cache.dataKey) : getViewModelPropValue(viewModel, cache);\n\n    // vmAttrObj must be a plain object\n    if (!isPlainObject(vmAttrObj)) {\n        return;\n    }\n\n    // populate cache.elementData if not exits\n    // check and set default cache.elementData.viewModelPropValue\n    cache.elementData = cache.elementData || {};\n    cache.elementData.viewModelPropValue = cache.elementData.viewModelPropValue || {};\n\n    // start diff comparison\n    // reject if nothing changed by comparing\n    // cache.elementData.viewModelPropValue (previous render) vs vmAttrObj(current render)\n    if (JSON.stringify(cache.elementData.viewModelPropValue) === JSON.stringify(vmAttrObj)) {\n        return;\n    }\n\n    if (isObjLiteralStr) {\n        // resolve each value in vmAttrObj\n        each(vmAttrObj, (key: string, value: unknown) => {\n            // resolve value from viewModel including $data and $root\n            // from viewModel.$data or viewModel.$root\n            (vmAttrObj as PlainObject)[key] = getViewModelPropValue(viewModel, {dataKey: value, el: cache.el} as BindingCache);\n        });\n    }\n\n    // shortcut for reading cache.elementData.viewModelPropValue\n    const oldAttrObj = cache.elementData.viewModelPropValue;\n\n    // start set element attribute - oldAttrObj is empty meaning no previous render\n    if (isEmptyObject(oldAttrObj)) {\n        each(vmAttrObj, (key: string, value: unknown) => {\n            if (typeof value !== 'undefined') {\n                cache.el.setAttribute(key, String(value));\n                // populate cache.elementData.viewModelPropValue for future comparison\n                if (!isObjLiteralStr && cache.elementData) {\n                    cache.elementData.viewModelPropValue[key] = value;\n                }\n            }\n        });\n    } else {\n        // loop oldAttrObj, remove attribute not present in current vmAttrObj\n        each(oldAttrObj as PlainObject, (key: string, _value: unknown) => {\n            if (typeof (vmAttrObj as PlainObject)[key] === 'undefined') {\n                cache.el.removeAttribute(key);\n            }\n        });\n\n        // loop vmAttrObj, set attribute not present in oldAttrObj\n        each(vmAttrObj, (key: string, value: unknown) => {\n            if (typeof value !== 'undefined') {\n                if ((oldAttrObj as PlainObject)[key] !== (vmAttrObj as PlainObject)[key]) {\n                    cache.el.setAttribute(key, String((vmAttrObj as PlainObject)[key]));\n                    // populate cache.elementData.viewModelPropValue for future comparison\n                    if (!isObjLiteralStr && cache.elementData) {\n                        cache.elementData.viewModelPropValue[key] = value;\n                    }\n                }\n            }\n        });\n    }\n\n    // for object literal style binding\n    // set viewModelPropValue for future diff comaprison\n    // note: vmAttrObj is a not fully resolve object, each value is still string unresloved\n    if (isObjLiteralStr) {\n        cache.elementData.viewModelPropValue = extend(false, {}, vmAttrObj);\n    }\n};\n\nexport default attrBinding;\n","import {dataIndexAttr} from './config';\nimport {\n    createHtmlFragment,\n    emptyElement,\n    getViewModelPropValue,\n    parseStringToJson,\n    updateDomWithMinimalChanges,\n} from './util';\nimport type {BindingCache, ViewModel, BindingAttrs, ElementCache, PlainObject} from './types';\n\nlet $domFragment: DocumentFragment | null = null;\nlet $templateRoot: HTMLElement | null = null;\nlet $templateRootPrepend = false;\nlet $templateRootAppend = false;\nlet nestTemplatesCount = 0;\n\n/**\n * getTemplateString\n * @description get Template tag innerHTML string\n * @param {string} id\n * @return {string} rendered html string\n */\nconst getTemplateString = (id: string): string => {\n    const templateElement = document.getElementById(id);\n\n    return templateElement ? templateElement.innerHTML : '';\n};\n\n/**\n * renderTemplate\n * @description\n * get template setting from DOM attribute then call compileTemplate\n * to render and append to target DOM\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {object} elementCache\n */\nconst renderTemplate = (cache: BindingCache, viewModel: ViewModel, bindingAttrs: BindingAttrs, elementCache: ElementCache): void => {\n    const settings = typeof cache.dataKey === 'string' ? parseStringToJson(cache.dataKey) : cache.dataKey as PlainObject;\n    let viewData: unknown = (settings as PlainObject).data;\n    const isAppend = (settings as PlainObject).append;\n    const isPrepend = (settings as PlainObject).prepend;\n    let $currentElement: DocumentFragment | HTMLElement;\n\n    cache.dataKey = settings as unknown as string;\n\n    viewData = (typeof viewData === 'undefined' || viewData === '$root') ?\n        viewModel :\n        getViewModelPropValue(viewModel, {\n            dataKey: (settings as PlainObject).data,\n            parameters: cache.parameters,\n        } as BindingCache);\n\n    if (!viewData) {\n        return;\n    }\n\n    const $element = cache.el;\n    const $indexAttr = $element.getAttribute(dataIndexAttr);\n    const $index = typeof viewModel.$index !== 'undefined' ? viewModel.$index : ($indexAttr ? parseInt($indexAttr, 10) : undefined);\n\n    if (typeof $index !== 'undefined' && viewData && typeof viewData === 'object') {\n        (viewData as ViewModel).$index = $index;\n    }\n\n    $domFragment = $domFragment || document.createDocumentFragment();\n\n    if (!$templateRoot) {\n        $templateRoot = $element;\n        // Store the prepend/append flags from the root template only\n        $templateRootPrepend = Boolean(isPrepend);\n        $templateRootAppend = Boolean(isAppend);\n    }\n\n    const htmlString = getTemplateString((settings as PlainObject).id as string);\n\n    const htmlFragment = createHtmlFragment(htmlString);\n\n    // Return early if htmlFragment is null (invalid template)\n    if (!htmlFragment) {\n        return;\n    }\n\n    // append rendered html\n    if (!$domFragment.childNodes.length) {\n        // domFragment should be empty in first run\n        $currentElement = $domFragment; // copy of $domFragment for later find nested template check\n        $domFragment.appendChild(htmlFragment);\n    } else {\n        // during recursive run keep append to current fragment\n        // For nested templates, use the original behavior (clear and append)\n        // because they may contain forOf bindings or other dynamic content\n        // that manages its own DOM structure\n        $currentElement = $element; // reset to current nested template element\n        if (!isAppend && !isPrepend) {\n            $currentElement = emptyElement($currentElement);\n        }\n        if (isPrepend) {\n            $currentElement.insertBefore(htmlFragment, $currentElement.firstChild);\n        } else {\n            $currentElement.appendChild(htmlFragment);\n        }\n    }\n\n    // check if there are nested template then recurisive render them\n    const $nestedTemplates = $currentElement.querySelectorAll(`[${  bindingAttrs.tmp  }]`);\n\n    const nestedTemplatesLength = $nestedTemplates.length;\n\n    if (nestedTemplatesLength) {\n        nestTemplatesCount += nestedTemplatesLength;\n\n        for (let i=0; i < nestedTemplatesLength; i+=1) {\n            const thisTemplateCache = {\n                el: $nestedTemplates[i] as HTMLElement,\n                dataKey: $nestedTemplates[i].getAttribute(bindingAttrs.tmp),\n            } as BindingCache;\n            elementCache[bindingAttrs.tmp].push(thisTemplateCache);\n            // recursive template render\n            renderTemplate(thisTemplateCache, viewModel, bindingAttrs, elementCache);\n            nestTemplatesCount -= 1;\n        }\n    }\n\n    // no more nested tempalted to render, start to append $domFragment into $templateRoot\n    if (nestTemplatesCount === 0) {\n        // append to DOM once\n        // Use the prepend/append flags from the root template, not the current nested template\n        if (!$templateRootAppend && !$templateRootPrepend) {\n            // Check if this is a re-render by looking for a marker attribute\n            // This is more reliable than checking childNodes.length because templates\n            // may have placeholder content\n            const isRerender = $templateRoot.hasAttribute('data-template-rendered');\n\n            if (isRerender) {\n                // Re-render: Use minimal DOM updates to preserve unchanged elements\n                // This is faster and preserves DOM state (focus, scroll, animations)\n                updateDomWithMinimalChanges($templateRoot, $domFragment);\n            } else {\n                // Initial render: Clear any placeholder content and render fresh\n                $templateRoot = emptyElement($templateRoot);\n                $templateRoot.appendChild($domFragment);\n                // Mark this template as rendered for future re-renders\n                $templateRoot.setAttribute('data-template-rendered', 'true');\n            }\n        } else {\n            // For prepend/append modes, use the original behavior\n            if ($templateRootPrepend) {\n                $templateRoot.insertBefore($domFragment, $templateRoot.firstChild);\n            } else {\n                $templateRoot.appendChild($domFragment);\n            }\n        }\n        // clear cached fragment and flags\n        $domFragment = $templateRoot = null;\n        $templateRootPrepend = $templateRootAppend = false;\n        // trigger callback if provided\n        if (viewModel.afterTemplateRender && typeof viewModel.afterTemplateRender === 'function') {\n            (viewModel.afterTemplateRender as Function)(viewData);\n        }\n    }\n};\n\nexport default renderTemplate;\n","import {bindingUpdateConditions} from './config';\nimport * as applyBindingModule from './applyBinding';\nimport createBindingOption from './createBindingOption';\nimport renderTemplate from './renderTemplate';\nimport type {ElementCache, ViewModel, BindingAttrs, BindingCache} from './types';\nimport type {BindingOption} from './createBindingOption';\n\ninterface BinderContext {\n    updateElementCache: (opt: {\n        allCache?: boolean;\n        templateCache?: boolean;\n        elementCache?: ElementCache;\n        isRenderedTemplates?: boolean;\n    }) => void;\n}\n\nconst renderTemplatesBinding = ({\n    ctx,\n    elementCache,\n    updateOption,\n    bindingAttrs,\n    viewModel,\n}: {\n    ctx: BinderContext;\n    elementCache: ElementCache;\n    updateOption: BindingOption;\n    bindingAttrs: BindingAttrs;\n    viewModel: ViewModel;\n}): boolean => {\n    if (!elementCache || !bindingAttrs) {\n        return false;\n    }\n    // render and apply binding to template(s) and forOf DOM\n    if (elementCache[bindingAttrs.tmp] && elementCache[bindingAttrs.tmp].length) {\n        // when re-render call with {templateBinding: true}\n        // template and nested templates\n        if (updateOption.templateBinding) {\n            // overwrite updateOption with 'init' bindingUpdateConditions\n            updateOption = createBindingOption(bindingUpdateConditions.init);\n\n            // forEach is correct here - nested templates are added to array but rendered recursively\n            // We don't want the loop to re-render templates that were already rendered via recursion\n            elementCache[bindingAttrs.tmp].forEach(($element: unknown) => {\n                renderTemplate($element as BindingCache, viewModel, bindingAttrs, elementCache);\n            });\n            // update cache after all template(s) rendered\n            ctx.updateElementCache({\n                templateCache: true,\n                elementCache,\n                isRenderedTemplates: true,\n            });\n        }\n        // enforce render even element is not in DOM tree\n        updateOption.forceRender = true;\n\n        // apply bindings to rendered templates element\n        // Use namespace import to access the function at runtime,\n        // which breaks the circular dependency during module initialization\n        // Use for loop to handle templates added during rendering\n        for (let i = 0; i < elementCache[bindingAttrs.tmp].length; i++) {\n            applyBindingModule.default({\n                ctx,\n                elementCache: elementCache[bindingAttrs.tmp][i].bindingCache as ElementCache,\n                updateOption,\n                bindingAttrs,\n                viewModel,\n            });\n        }\n    }\n    return true;\n};\n\nexport default renderTemplatesBinding;\n","import {bindingUpdateConditions} from './config';\nimport createBindingOption from './createBindingOption';\nimport renderTemplatesBinding from './renderTemplatesBinding';\nimport * as applyBindingModule from './applyBinding';\nimport type {ElementCache, ViewModel, BindingAttrs} from './types';\nimport type Binder from './binder';\n\n/**\n * renderIteration\n * @param {object} opt\n * @description\n * render element's binding by supplied elementCache\n * This function is desidned for FoOf, If, switch bindings\n */\nconst renderIteration = ({\n    elementCache,\n    iterationVm,\n    bindingAttrs,\n    isRegenerate,\n}: {\n    elementCache: ElementCache;\n    iterationVm: ViewModel;\n    bindingAttrs: BindingAttrs;\n    isRegenerate: boolean;\n}): void => {\n    const bindingUpdateOption = isRegenerate ? createBindingOption(bindingUpdateConditions.init) : createBindingOption();\n\n    // enforce render even element is not in DOM tree\n    bindingUpdateOption.forceRender = true;\n\n    // render and apply binding to template(s)\n    // this is an share function therefore passing current APP 'this' context\n    // viewModel is a dynamic generated iterationVm\n    renderTemplatesBinding({\n        ctx: (iterationVm.$root ? iterationVm.$root.APP : iterationVm.APP) as Binder,\n        elementCache,\n        updateOption: bindingUpdateOption,\n        bindingAttrs,\n        viewModel: iterationVm,\n    });\n\n    // Use namespace import to access the function at runtime,\n    // which breaks the circular dependency during module initialization\n    applyBindingModule.default({\n        ctx: (iterationVm.$root ? iterationVm.$root.APP : iterationVm.APP) as Binder,\n        elementCache,\n        updateOption: bindingUpdateOption,\n        bindingAttrs,\n        viewModel: iterationVm,\n    });\n};\n\nexport default renderIteration;\n","\nimport * as config from './config';\nimport * as util from './util';\nimport type {BindingCache} from './types';\n\nconst createClonedElementCache = (bindingData: BindingCache): BindingCache => {\n    const clonedElement = bindingData.el.cloneNode(true);\n    bindingData.fragment = document.createDocumentFragment();\n    bindingData.fragment.appendChild(clonedElement);\n    return bindingData;\n};\n\nconst setCommentPrefix = (bindingData: BindingCache): BindingCache => {\n    if (!bindingData || !bindingData.type) {\n        return bindingData;\n    }\n    let commentPrefix = '';\n    const dataKeyMarker = bindingData.dataKey ? bindingData.dataKey.replace(util.REGEX.WHITE_SPACES, '_') : '';\n\n    switch (bindingData.type) {\n        case config.bindingAttrs.forOf:\n            commentPrefix = config.commentPrefix.forOf;\n            break;\n        case config.bindingAttrs.if:\n            commentPrefix = config.commentPrefix.if;\n            break;\n        case config.bindingAttrs.case:\n            commentPrefix = config.commentPrefix.case;\n            break;\n        case config.bindingAttrs.default:\n            commentPrefix = config.commentPrefix.default;\n            break;\n    }\n    bindingData.commentPrefix = commentPrefix + dataKeyMarker;\n    return bindingData;\n};\n\n/**\n * setDocRangeEndAfter\n * @param {object} node\n * @param {object} bindingData\n * @description\n * recursive execution to find last wrapping comment node\n * and set as bindingData.docRange.setEndAfter\n * if not found deleteContents will has no operation\n * @return {undefined}\n */\nconst setDocRangeEndAfter = (node: Node | null, bindingData: BindingCache): void => {\n    if (!bindingData.commentPrefix) {\n        setCommentPrefix(bindingData);\n    }\n    const startTextContent = bindingData.commentPrefix as string;\n    const endTextContent = startTextContent + config.commentSuffix;\n    node = node.nextSibling;\n\n    // check last wrap comment node\n    if (node) {\n        if (node.nodeType === 8 && node.textContent === endTextContent) {\n            return (bindingData.docRange as Range).setEndBefore(node);\n        }\n        setDocRangeEndAfter(node, bindingData);\n    }\n};\n\n/**\n * wrapCommentAround\n * @param {object} bindingData\n * @param {Node} node\n * @return {object} DOM fragment\n * @description\n * wrap frament with comment node\n */\nconst wrapCommentAround = (bindingData: BindingCache, node: Node | DocumentFragment): Node | DocumentFragment => {\n    let prefix = '';\n    if (!bindingData.commentPrefix) {\n        setCommentPrefix(bindingData);\n    }\n    prefix = bindingData.commentPrefix as string;\n    const commentBegin = document.createComment(prefix);\n    const commentEnd = document.createComment(prefix + config.commentSuffix);\n    // document fragment - logic for ForOf binding\n    // check node.parentNode because node could be from cache and no longer in DOM\n    if (node.nodeType === 11) {\n        node.insertBefore(commentBegin, node.firstChild);\n        node.appendChild(commentEnd);\n    } else if (node.parentNode) {\n        node.parentNode.insertBefore(commentBegin, node);\n        util.insertAfter(node.parentNode, commentEnd, node);\n        // update bindingData details\n        bindingData.previousNonTemplateElement = node.previousSibling;\n        bindingData.nextNonTemplateElement = node.nextSibling;\n        bindingData.parentElement = node.previousSibling.parentElement;\n    }\n\n    return node;\n};\n\n/**\n * removeElemnetsByCommentWrap\n * @param {object} bindingData\n * @return {undefined}\n * @description remove elments by range\n */\nconst removeElemnetsByCommentWrap = (bindingData: BindingCache): void => {\n    if (!bindingData.docRange) {\n        bindingData.docRange = document.createRange();\n    }\n    const docRange = bindingData.docRange as Range;\n    try {\n        if (bindingData.previousNonTemplateElement) {\n            // update docRange start and end match the wrapped comment node\n            docRange.setStartBefore(bindingData.previousNonTemplateElement.nextSibling as Node);\n            setDocRangeEndAfter(bindingData.previousNonTemplateElement.nextSibling, bindingData);\n        } else {\n            // insert before next non template element\n            docRange.setStartBefore((bindingData.parentElement as HTMLElement).firstChild as Node);\n            setDocRangeEndAfter((bindingData.parentElement as HTMLElement).firstChild, bindingData);\n        }\n    } catch (err: unknown) {\n        console.log('error removeElemnetsByCommentWrap: ', err instanceof Error ? err.message : String(err));\n    }\n\n    docRange.deleteContents();\n};\n\n/**\n * removeDomTemplateElement\n * @param {object} bindingData\n * @return {object} null\n */\nconst removeDomTemplateElement = (bindingData: BindingCache): void => {\n    // first render - forElement is live DOM element so has parentNode\n    if (bindingData.el.parentNode) {\n        bindingData.el.parentNode.removeChild(bindingData.el);\n        return;\n    }\n    removeElemnetsByCommentWrap(bindingData);\n};\n\nconst insertRenderedElements = (bindingData: BindingCache, fragment: DocumentFragment): void => {\n    // insert rendered fragment after the previousNonTemplateElement\n    if (bindingData.previousNonTemplateElement) {\n        util.insertAfter(bindingData.parentElement, fragment, bindingData.previousNonTemplateElement);\n    } else {\n        // insert before next non template element\n        if (bindingData.nextNonTemplateElement) {\n            bindingData.parentElement.insertBefore(fragment, bindingData.nextNonTemplateElement);\n        } else if (bindingData.parentElement) {\n            // insert from parent\n            bindingData.parentElement.appendChild(fragment);\n        }\n    }\n};\n\nexport {\n    createClonedElementCache,\n    setCommentPrefix,\n    wrapCommentAround,\n    removeElemnetsByCommentWrap,\n    removeDomTemplateElement,\n    setDocRangeEndAfter,\n    insertRenderedElements,\n};\n","\nimport {bindingAttrs as configBindingAttrs, bindingDataReference} from './config';\nimport {\n    getViewModelPropValue,\n    isArray,\n    isPlainObject,\n    throwErrorMessage,\n    cloneDomNode,\n    isEmptyObject,\n} from './util';\nimport createBindingCache from './domWalker';\nimport renderIteration from './renderIteration';\nimport {\n    wrapCommentAround,\n    removeElemnetsByCommentWrap,\n    insertRenderedElements,\n} from './commentWrapper';\nimport type {ViewModel, BindingCache, BindingAttrs, ElementCache} from './types';\n\nconst renderForOfBinding = ({bindingData, viewModel, bindingAttrs}: {\n    bindingData: BindingCache;\n    viewModel: ViewModel;\n    bindingAttrs: BindingAttrs;\n}): void => {\n    if (!bindingData || !viewModel || !bindingAttrs) {\n        return;\n    }\n    let keys: string[] | undefined;\n    let iterationDataLength: number;\n    // FIX: Use bindingData.iterator instead of bindingData to get the iteration data\n    // The iterator object has the dataKey pointing to the array/object to iterate over\n    const iterationData = getViewModelPropValue(viewModel, bindingData.iterator as BindingCache);\n    let isRegenerate = false;\n\n    // check iterationData and set iterationDataLength\n    if (isArray(iterationData)) {\n        iterationDataLength = iterationData.length;\n    } else if (isPlainObject(iterationData)) {\n        keys = Object.keys(iterationData);\n        iterationDataLength = keys.length;\n    } else {\n        // throw error but let script contince to run\n        return throwErrorMessage(null, 'iterationData is not an plain object or array');\n    }\n\n    // flag as pared for-of logic with bindingData.type\n    if (!bindingData.type) {\n        bindingData.type = configBindingAttrs.forOf;\n        wrapCommentAround(bindingData, bindingData.el);\n    }\n\n    // assign forOf internal id to bindingData once\n    if (typeof bindingData.iterationSize === 'undefined') {\n        // store iterationDataLength\n        bindingData.iterationSize = iterationDataLength;\n        // remove orignal node for-of attributes\n        bindingData.el.removeAttribute(bindingAttrs.forOf);\n        isRegenerate = true;\n    } else {\n        // only regenerate cache if iterationDataLength changed\n        isRegenerate = bindingData.iterationSize !== iterationDataLength;\n        // update iterationSize\n        bindingData.iterationSize = iterationDataLength;\n    }\n\n    if (!isRegenerate) {\n        (bindingData.iterationBindingCache as ElementCache[])?.forEach((elementCache: ElementCache, i: number) => {\n            if (!isEmptyObject(elementCache)) {\n                const iterationVm = createIterationViewModel({\n                    bindingData,\n                    viewModel,\n                    iterationData,\n                    keys,\n                    index: i,\n                });\n                renderIteration({\n                    elementCache,\n                    iterationVm,\n                    bindingAttrs,\n                    isRegenerate: false,\n                });\n            }\n        });\n\n        return;\n    }\n\n    // generate forOfBinding elements into fragment\n    const fragment = generateForOfElements(bindingData, viewModel, bindingAttrs, iterationData, keys);\n\n    removeElemnetsByCommentWrap(bindingData);\n\n    // insert fragment content into DOM\n    return insertRenderedElements(bindingData, fragment);\n};\n\n/**\n * createIterationViewModel\n * @description\n * create an virtual viewModel for render binding while in loop iteration\n * $data is the current data in the loop eg. data in array\n * $root is point to top level viewModel\n * $index is the current loop index\n * @param {*} param0\n * @return {object} virtual viewModel\n */\nconst createIterationViewModel = ({bindingData, viewModel, iterationData, keys, index}: {\n    bindingData: BindingCache;\n    viewModel: ViewModel;\n    iterationData: unknown;\n    keys: string[] | undefined;\n    index: number;\n}): ViewModel => {\n    const iterationVm: ViewModel = {};\n    const alias = bindingData.iterator?.alias;\n    if (alias) {\n        iterationVm[alias] = keys ? (iterationData as Record<string, unknown>)[keys[index]] : (iterationData as unknown[])[index];\n    }\n    // populate common binding data reference\n    iterationVm[bindingDataReference.rootDataKey] = viewModel.$root || viewModel;\n    iterationVm[bindingDataReference.currentData] = alias ? iterationVm[alias] : undefined;\n    iterationVm[bindingDataReference.currentIndex] = index;\n    return iterationVm;\n};\n\nconst generateForOfElements = (\n    bindingData: BindingCache,\n    viewModel: ViewModel,\n    bindingAttrs: BindingAttrs,\n    iterationData: unknown,\n    keys: string[] | undefined,\n): DocumentFragment => {\n    const fragment = document.createDocumentFragment();\n    const iterationDataLength = bindingData.iterationSize as number;\n    let clonedItem: HTMLElement;\n    let iterationVm: ViewModel;\n    let iterationBindingCache: ElementCache;\n    let i = 0;\n\n    // create or clear exisitng iterationBindingCache\n    if (isArray(bindingData.iterationBindingCache)) {\n        (bindingData.iterationBindingCache as ElementCache[]).length = 0;\n    } else {\n        bindingData.iterationBindingCache = [];\n    }\n\n    // generate forOf and append to DOM\n    for (i = 0; i < iterationDataLength; i += 1) {\n        clonedItem = cloneDomNode(bindingData.el);\n\n        // create bindingCache per iteration\n        iterationBindingCache = createBindingCache({\n            rootNode: clonedItem,\n            bindingAttrs,\n        });\n\n        (bindingData.iterationBindingCache as ElementCache[]).push(iterationBindingCache);\n\n        if (!isEmptyObject(iterationBindingCache)) {\n            // create an iterationVm match iterator alias\n            iterationVm = createIterationViewModel({\n                bindingData,\n                viewModel,\n                iterationData,\n                keys,\n                index: i,\n            });\n\n            renderIteration({\n                elementCache: (bindingData.iterationBindingCache as ElementCache[])[i],\n                iterationVm,\n                bindingAttrs,\n                isRegenerate: true,\n            });\n        }\n\n        fragment.appendChild(clonedItem);\n    }\n\n    return fragment;\n};\n\nexport default renderForOfBinding;\n","import {maxDatakeyLength} from './config';\nimport {REGEX} from './util';\nimport renderForOfBinding from './renderForOfBinding';\nimport type {BindingCache, ViewModel, BindingAttrs} from './types';\n\n/**\n * forOfBinding\n * @description\n * DOM decleartive for binding.\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n */\nconst forOfBinding = (cache: BindingCache, viewModel: ViewModel, bindingAttrs: BindingAttrs, _forceRender?: boolean): void => {\n    const dataKey = cache.dataKey;\n\n    if (!dataKey || dataKey.length > maxDatakeyLength) {\n        return;\n    }\n\n    if (!cache.iterator) {\n        if (dataKey.length > maxDatakeyLength) {\n            return;\n        }\n        // replace mess spaces with single space\n        cache.dataKey = cache.dataKey.replace(REGEX.WHITE_SPACES, ' ');\n        const forExpMatch = dataKey.match(REGEX.FOR_OF);\n\n        if (!forExpMatch) {\n            return;\n        }\n\n        cache.iterator = {};\n        cache.iterator.alias = forExpMatch[1].trim();\n\n        if (forExpMatch[2]) {\n            cache.iterator.dataKey = forExpMatch[2].trim();\n            cache.parentElement = cache.el.parentElement;\n            cache.previousNonTemplateElement = cache.el.previousSibling;\n            cache.nextNonTemplateElement = cache.el.nextSibling;\n        }\n    }\n\n    renderForOfBinding({\n        bindingData: cache,\n        viewModel,\n        bindingAttrs,\n    });\n};\n\nexport default forOfBinding;\n","import {isEmptyObject} from './util';\nimport renderIteration from './renderIteration';\nimport createBindingCache from './domWalker';\nimport {commentSuffix} from './config';\nimport {removeElemnetsByCommentWrap, insertRenderedElements} from './commentWrapper';\nimport type {BindingCache, ViewModel, BindingAttrs, ElementCache} from './types';\n\ninterface RenderIfBindingParams {\n    bindingData: BindingCache;\n    viewModel: ViewModel;\n    bindingAttrs: BindingAttrs;\n}\n\n/**\n * isTargetDomRemoved\n * @description check if DOM between 'start' and 'end' comment tag has been removed\n * @param {object} bindingData\n * @return {boolean}\n */\nconst isTargetDomRemoved = (bindingData: BindingCache): boolean => {\n    let ret = false;\n    if (bindingData && bindingData.previousNonTemplateElement) {\n        const commentStartTextContent = bindingData.previousNonTemplateElement.textContent;\n        const endCommentTag = bindingData.previousNonTemplateElement.nextSibling;\n\n        if (endCommentTag && endCommentTag.nodeType === 8) {\n            if (endCommentTag.textContent === commentStartTextContent + commentSuffix) {\n                ret = true;\n            }\n        }\n    }\n    return ret;\n};\n\n/**\n * removeIfBinding\n * @description remove if binding DOM and clean up cache\n * @param {object} bindingData\n */\nconst removeIfBinding = (bindingData: BindingCache): void => {\n    removeElemnetsByCommentWrap(bindingData);\n    // remove cache.IterationBindingCache to prevent memory leak\n    if (bindingData.hasIterationBindingCache) {\n        delete bindingData.iterationBindingCache;\n        delete bindingData.hasIterationBindingCache;\n    }\n};\n\n/**\n * renderIfBinding\n * @description render if binding DOM\n * @param {object} bindingData\n * @param {object} viewModel\n * @param {object} bindingAttrs\n */\nconst renderIfBinding = ({bindingData, viewModel, bindingAttrs}: RenderIfBindingParams): void => {\n    if (!bindingData.fragment) {\n        return;\n    }\n\n    const isDomRemoved = isTargetDomRemoved(bindingData);\n    let rootElement: Node = bindingData.el;\n\n    // remove current old DOM.\n    // TODO: try preserve DOM\n    if (!isDomRemoved && !bindingData.isOnce) {\n        removeIfBinding(bindingData);\n        // use fragment for create iterationBindingCache\n        const firstChild = bindingData.fragment.firstChild;\n        if (firstChild) {\n            rootElement = firstChild.cloneNode(true);\n        }\n    }\n\n    // walk clonedElement to create iterationBindingCache once\n    if (!bindingData.iterationBindingCache || !bindingData.hasIterationBindingCache) {\n        bindingData.iterationBindingCache = createBindingCache({\n            rootNode: rootElement as HTMLElement,\n            bindingAttrs,\n        });\n    }\n\n    // only render if has iterationBindingCache\n    // means has other dataBindings to be render\n    if (!isEmptyObject(bindingData.iterationBindingCache)) {\n        bindingData.hasIterationBindingCache = true;\n        renderIteration({\n            elementCache: bindingData.iterationBindingCache as ElementCache,\n            iterationVm: viewModel,\n            bindingAttrs,\n            isRegenerate: true,\n        });\n    }\n\n    // insert to new rendered DOM\n    // TODO: check unnecessary insertion when DOM is preserved\n    insertRenderedElements(bindingData, rootElement as DocumentFragment);\n};\n\nexport {\n    renderIfBinding,\n    removeIfBinding,\n};\n","import {bindingAttrs as configBindingAttrs, constants} from './config';\nimport {getViewModelPropValue, removeElement} from './util';\nimport {createClonedElementCache, wrapCommentAround} from './commentWrapper';\nimport {renderIfBinding, removeIfBinding} from './renderIfBinding';\nimport type {BindingCache, ViewModel, BindingAttrs} from './types';\n\n/**\n * if-Binding\n * @description\n * DOM decleartive for binding.\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n */\nconst ifBinding = (cache: BindingCache, viewModel: ViewModel, bindingAttrs: BindingAttrs, _forceRender?: boolean): void => {\n    const dataKey = cache.dataKey;\n\n    // isOnce only return if there is no child bindings\n    if (!dataKey || (cache.isOnce && cache.hasIterationBindingCache === false)) {\n        return;\n    }\n\n    cache.elementData = cache.elementData || {};\n    cache.type = cache.type || configBindingAttrs.if;\n\n    const oldViewModelProValue = cache.elementData.viewModelPropValue;\n    // getViewModelPropValue could be return undefined or null\n    const viewModelPropValue = getViewModelPropValue(viewModel, cache) || false;\n\n    // do nothing if viewModel value not changed and no child bindings\n    if (oldViewModelProValue === viewModelPropValue && !cache.hasIterationBindingCache) {\n        return;\n    }\n\n    const shouldRender = Boolean(viewModelPropValue);\n\n    // remove this cache from parent array\n    if (!shouldRender && cache.isOnce && cache.el.parentNode) {\n        removeElement(cache.el);\n        // delete cache.fragment;\n        removeBindingInQueue({\n            viewModel,\n            cache,\n        });\n        return;\n    }\n\n    // store new show status\n    cache.elementData.viewModelPropValue = viewModelPropValue;\n\n    // only create fragment once\n    // wrap comment tag around\n    // remove if attribute from original element to allow later dataBind parsing\n    if (!cache.fragment) {\n        wrapCommentAround(cache, cache.el);\n        cache.el.removeAttribute(bindingAttrs.if);\n        createClonedElementCache(cache);\n    }\n\n    if (!shouldRender) {\n        // remove element\n        removeIfBinding(cache);\n    } else {\n        // render element\n        renderIfBinding({\n            bindingData: cache,\n            viewModel,\n            bindingAttrs,\n        });\n\n        // if render once\n        // remove this cache from parent array if no child caches\n        if (cache.isOnce && !cache.hasIterationBindingCache) {\n            // delete cache.fragment;\n            removeBindingInQueue({\n                viewModel,\n                cache,\n            });\n        }\n    }\n};\n\nconst removeBindingInQueue = ({viewModel, cache}: {viewModel: ViewModel; cache: BindingCache}): boolean => {\n    let ret = false;\n    if (viewModel.APP?.postProcessQueue) {\n        const parentRef = cache[constants.PARENT_REF] as BindingCache[];\n        viewModel.APP.postProcessQueue.push(\n            ((cache: BindingCache, index: number) => () => {\n                parentRef.splice(index, 1);\n            })(cache, parentRef.indexOf(cache)),\n        );\n        ret = true;\n    }\n    return ret;\n};\n\nexport default ifBinding;\n","import {getViewModelPropValue} from './util';\nimport {createClonedElementCache, wrapCommentAround} from './commentWrapper';\nimport {renderIfBinding, removeIfBinding} from './renderIfBinding';\nimport type {BindingCache, ViewModel, BindingAttrs, CaseData} from './types';\n\n/**\n * switch-Binding\n * @description\n * DOM decleartive switch binding.\n * switch parent element wrap direct child with case bindings\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n */\nconst switchBinding = (cache: BindingCache, viewModel: ViewModel, bindingAttrs: BindingAttrs, _forceRender?: boolean): void => {\n    const dataKey = cache.dataKey;\n\n    if (!dataKey) {\n        return;\n    }\n\n    cache.elementData = cache.elementData || {};\n\n    const newExpression = getViewModelPropValue(viewModel, cache);\n\n    if (newExpression === cache.elementData.viewModelPropValue) {\n        return;\n    }\n\n    cache.elementData.viewModelPropValue = newExpression;\n\n    // build switch cases if not yet defined\n    if (!cache.cases) {\n        const childrenElements = cache.el.children;\n        if (!childrenElements.length) {\n            return;\n        }\n        cache.cases = [];\n        for (let i = 0, elementLength = childrenElements.length; i < elementLength; i += 1) {\n            let caseData: CaseData | null = null;\n            const childElement = childrenElements[i] as HTMLElement;\n            if (childElement.hasAttribute(bindingAttrs.case)) {\n                caseData = createCaseData(childElement, bindingAttrs.case);\n            } else if (childElement.hasAttribute(bindingAttrs.default)) {\n                caseData = createCaseData(childElement, bindingAttrs.default);\n                caseData.isDefault = true;\n            }\n            // create fragment by clone node\n            // wrap with comment tag\n            if (caseData) {\n                wrapCommentAround(caseData, caseData.el);\n                // remove binding attribute for later dataBind parse\n                if (caseData.isDefault) {\n                    caseData.el.removeAttribute(bindingAttrs.default);\n                } else {\n                    caseData.el.removeAttribute(bindingAttrs.case);\n                }\n                createClonedElementCache(caseData);\n                cache.cases.push(caseData);\n            }\n        }\n    }\n\n    if (cache.cases.length) {\n        let hasMatch = false;\n        // do switch operation - reuse if binding logic\n        for (let j = 0, casesLength = cache.cases.length; j < casesLength; j += 1) {\n            let newCaseValue: unknown;\n            if (cache.cases[j].dataKey) {\n                // set back to dataKey if nothing found in viewModel\n                newCaseValue = getViewModelPropValue(viewModel, cache.cases[j]) || cache.cases[j].dataKey;\n            }\n\n            if (newCaseValue === cache.elementData.viewModelPropValue || cache.cases[j].isDefault) {\n                hasMatch = true;\n                // render element\n                renderIfBinding({\n                    bindingData: cache.cases[j],\n                    viewModel,\n                    bindingAttrs,\n                });\n\n                // remove other elements\n                removeUnmatchCases(cache.cases, j);\n                break;\n            }\n        }\n        // no match remove all cases\n        if (!hasMatch) {\n            removeUnmatchCases(cache.cases);\n        }\n    }\n};\n\nconst removeUnmatchCases = (cases: CaseData[], matchedIndex?: number): void => {\n    cases.forEach((caseData: CaseData, index: number) => {\n        if (index !== matchedIndex || typeof matchedIndex === 'undefined') {\n            removeIfBinding(caseData);\n            // remove cache.IterationBindingCache to prevent memory leak\n            if (caseData.hasIterationBindingCache) {\n                caseData.iterationBindingCache = null;\n                caseData.hasIterationBindingCache = false;\n            }\n        }\n    });\n};\n\nconst createCaseData = (node: HTMLElement, attrName: string): CaseData => {\n    const caseData: CaseData = {\n        el: node,\n        dataKey: node.getAttribute(attrName),\n        type: attrName,\n    };\n    return caseData;\n};\n\nexport default switchBinding;\n","import {\n    getFormData,\n    getViewModelValue,\n    resolveViewModelContext,\n    resolveParamList,\n} from './util';\nimport type {BindingCache, ViewModel} from './types';\n\n/**\n * Create event handler wrapper\n */\nconst createEventHandlerWrapper = (\n    type: string,\n    paramList: unknown[],\n    handlerFn: Function,\n    viewModelContext: ViewModel,\n): EventListener => {\n    return function handlerWrap(e: Event): void {\n        let formData: Record<string, unknown>;\n        let args: unknown[] = [];\n        if (type === 'submit') {\n            formData = getFormData(e.currentTarget as HTMLFormElement);\n            args = [e, e.currentTarget, formData, ...paramList];\n        } else {\n            args = [e, e.currentTarget, ...paramList];\n        }\n        handlerFn.apply(viewModelContext, args);\n    };\n};\n\ninterface CreateEventBindingParams {\n    cache?: BindingCache;\n    forceRender?: boolean;\n    type?: string;\n    viewModel?: ViewModel;\n}\n\nconst createEventBinding = ({\n    cache = {} as BindingCache,\n    forceRender = false,\n    type = '',\n    viewModel = {} as ViewModel,\n}: CreateEventBindingParams): void => {\n    const handlerName = cache.dataKey;\n    let paramList = cache.parameters;\n    let viewModelContext: ViewModel;\n    const APP = viewModel.APP || viewModel.$root?.APP;\n    const rootElement = APP?.$rootElement as HTMLElement | undefined;\n\n    if (!type || !handlerName || (!forceRender && rootElement && !rootElement.contains(cache.el))) {\n        return;\n    }\n\n    const handlerFn = getViewModelValue(viewModel, handlerName);\n\n    if (typeof handlerFn === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n\n        const handlerWrap = createEventHandlerWrapper(\n            type,\n            paramList,\n            handlerFn,\n            viewModelContext,\n        );\n\n        cache.el.removeEventListener(type, handlerWrap, false);\n        cache.el.addEventListener(type, handlerWrap, false);\n    }\n};\n\nexport default createEventBinding;\n","import hoverBinding from './hoverBinding';\nimport changeBinding from './changeBinding';\nimport modelBinding from './modelBinding';\nimport textBinding from './textBinding';\nimport showBinding from './showBinding';\nimport cssBinding from './cssBinding';\nimport attrBinding from './attrBinding';\nimport forOfBinding from './forOfBinding'; // depends renderForOfBinding -> this , renderIteration\nimport ifBinding from './ifBinding';\nimport switchBinding from './switchBinding';\nimport createEventBinding from './createEventBinding';\nimport type {ElementCache, UpdateOption, BindingAttrs, ViewModel, BindingCache} from './types';\n\ninterface ApplyBindingParams {\n    ctx: unknown;\n    elementCache: ElementCache;\n    updateOption: UpdateOption;\n    bindingAttrs: BindingAttrs;\n    viewModel: ViewModel;\n}\n\nconst applyBinding = ({ctx: _ctx, elementCache, updateOption, bindingAttrs, viewModel}: ApplyBindingParams): void => {\n    if (!elementCache || !updateOption) {\n        return;\n    }\n\n    // the follow binding should be in order for better efficiency\n\n    // apply forOf Binding\n    if (updateOption.forOfBinding && elementCache[bindingAttrs.forOf] && elementCache[bindingAttrs.forOf].length) {\n        elementCache[bindingAttrs.forOf].forEach((cache: BindingCache) => {\n            forOfBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n    }\n\n    // apply attr Binding\n    if (updateOption.attrBinding && elementCache[bindingAttrs.attr] && elementCache[bindingAttrs.attr].length) {\n        elementCache[bindingAttrs.attr].forEach((cache: BindingCache) => {\n            attrBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n    }\n\n    // apply if Binding\n    if (updateOption.ifBinding && elementCache[bindingAttrs.if] && elementCache[bindingAttrs.if].length) {\n        elementCache[bindingAttrs.if].forEach((cache: BindingCache) => {\n            ifBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n    }\n\n    // apply show Binding\n    if (updateOption.showBinding && elementCache[bindingAttrs.show] && elementCache[bindingAttrs.show].length) {\n        elementCache[bindingAttrs.show].forEach((cache: BindingCache) => {\n            showBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n    }\n\n    // apply switch Binding\n    if (updateOption.switchBinding && elementCache[bindingAttrs.switch] && elementCache[bindingAttrs.switch].length) {\n        elementCache[bindingAttrs.switch].forEach((cache: BindingCache) => {\n            switchBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n    }\n\n    // apply text binding\n    if (updateOption.textBinding && elementCache[bindingAttrs.text] && elementCache[bindingAttrs.text].length) {\n        elementCache[bindingAttrs.text].forEach((cache: BindingCache) => {\n            textBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n    }\n\n    // apply cssBinding\n    if (updateOption.cssBinding && elementCache[bindingAttrs.css] && elementCache[bindingAttrs.css].length) {\n        elementCache[bindingAttrs.css].forEach((cache: BindingCache) => {\n            cssBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n    }\n\n    // apply model binding\n    if (updateOption.modelBinding && elementCache[bindingAttrs.model] && elementCache[bindingAttrs.model].length) {\n        elementCache[bindingAttrs.model].forEach((cache: BindingCache) => {\n            modelBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n    }\n\n    // apply change binding\n    if (updateOption.changeBinding && elementCache[bindingAttrs.change] && elementCache[bindingAttrs.change].length) {\n        elementCache[bindingAttrs.change].forEach((cache: BindingCache) => {\n            changeBinding({\n                bindingAttrs,\n                cache,\n                forceRender: updateOption.forceRender,\n                type: 'change',\n                viewModel,\n            });\n        });\n    }\n\n    // apply submit binding\n    if (updateOption.submitBinding && elementCache[bindingAttrs.submit] && elementCache[bindingAttrs.submit].length) {\n        elementCache[bindingAttrs.submit].forEach((cache: BindingCache) => {\n            createEventBinding({\n                cache,\n                forceRender: updateOption.forceRender,\n                type: 'submit',\n                viewModel,\n            });\n        });\n    }\n\n    // apply click binding\n    if (updateOption.clickBinding && elementCache[bindingAttrs.click] && elementCache[bindingAttrs.click].length) {\n        elementCache[bindingAttrs.click].forEach((cache: BindingCache) => {\n            createEventBinding({\n                cache,\n                forceRender: updateOption.forceRender,\n                type: 'click',\n                viewModel,\n            });\n        });\n    }\n\n    // apply double click binding\n    if (updateOption.dblclickBinding && elementCache[bindingAttrs.dblclick] && elementCache[bindingAttrs.dblclick].length) {\n        elementCache[bindingAttrs.dblclick].forEach((cache: BindingCache) => {\n            createEventBinding({\n                cache,\n                forceRender: updateOption.forceRender,\n                type: 'dblclick',\n                viewModel,\n            });\n        });\n    }\n\n    // apply blur binding\n    if (updateOption.blurBinding && elementCache[bindingAttrs.blur] && elementCache[bindingAttrs.blur].length) {\n        elementCache[bindingAttrs.blur].forEach((cache: BindingCache) => {\n            createEventBinding({\n                cache,\n                forceRender: updateOption.forceRender,\n                type: 'blur',\n                viewModel,\n            });\n        });\n    }\n\n    // apply focus binding\n    if (updateOption.focusBinding && elementCache[bindingAttrs.focus] && elementCache[bindingAttrs.focus].length) {\n        elementCache[bindingAttrs.focus].forEach((cache: BindingCache) => {\n            createEventBinding({\n                cache,\n                forceRender: updateOption.forceRender,\n                type: 'focus',\n                viewModel,\n            });\n        });\n    }\n\n    // apply hover binding\n    if (updateOption.hoverBinding && elementCache[bindingAttrs.hover] && elementCache[bindingAttrs.hover].length) {\n        elementCache[bindingAttrs.hover].forEach((cache: BindingCache) => {\n            hoverBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n    }\n\n    // apply input binding - eg html range input\n    if (updateOption.inputBinding && elementCache[bindingAttrs.input] && elementCache[bindingAttrs.input].length) {\n        elementCache[bindingAttrs.input].forEach((cache: BindingCache) => {\n            changeBinding({\n                bindingAttrs,\n                cache,\n                forceRender: updateOption.forceRender,\n                type: 'input',\n                viewModel,\n            });\n        });\n    }\n};\n\nexport default applyBinding;\n","import {getViewModelPropValue} from './util';\nimport type {BindingCache, ViewModel, BindingAttrs} from './types';\n\n/**\n * showBinding\n * @description\n * DOM decleartive show binding. Make binding show/hide according to viewModel data (boolean)\n * viewModel data can function but must return boolean\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n */\nconst showBinding = (cache: BindingCache, viewModel: ViewModel, _bindingAttrs: BindingAttrs, _forceRender?: boolean): void => {\n    const dataKey = cache.dataKey;\n    let currentInlineSytle: CSSStyleDeclaration | Record<string, never> = {};\n    let currentInlineDisplaySytle = '';\n    let shouldShow = true;\n\n    if (!dataKey) {\n        return;\n    }\n\n    cache.elementData = cache.elementData || {};\n\n    const oldShowStatus = cache.elementData.viewModelPropValue;\n\n    // store current element display default style once only\n    if (\n        typeof cache.elementData.displayStyle === 'undefined' ||\n        typeof cache.elementData.computedStyle === 'undefined'\n    ) {\n        currentInlineSytle = cache.el.style;\n        currentInlineDisplaySytle = currentInlineSytle.display;\n        // use current inline style if defined\n        if (currentInlineDisplaySytle) {\n            // set to 'block' if is 'none'\n            cache.elementData.displayStyle = currentInlineDisplaySytle === 'none' ? 'block' : currentInlineDisplaySytle;\n            cache.elementData.computedStyle = null;\n        } else {\n            const computeStyle = window.getComputedStyle(cache.el, null).getPropertyValue('display');\n            cache.elementData.displayStyle = null;\n            cache.elementData.computedStyle = computeStyle;\n        }\n    }\n\n    shouldShow = getViewModelPropValue(viewModel, cache) as boolean;\n\n    // treat undefined || null as false.\n    // eg if property doesn't exsits in viewModel, it will treat as false to hide element\n    shouldShow = Boolean(shouldShow);\n\n    // reject if nothing changed\n    if (oldShowStatus === shouldShow) {\n        return;\n    }\n\n    if (!shouldShow) {\n        if (cache.el.style.display !== 'none') {\n            cache.el.style.setProperty('display', 'none');\n        }\n    } else {\n        if (cache.elementData.computedStyle || cache.el.style.display === 'none') {\n            if (cache.elementData.computedStyle === 'none') {\n                // default display is none in css rule, so use display 'block'\n                cache.el.style.setProperty('display', 'block');\n            } else {\n                // has default displayable type so just remove inline display 'none'\n                if (currentInlineSytle.length > 1) {\n                    cache.el.style.removeProperty('display');\n                } else {\n                    cache.el.removeAttribute('style');\n                }\n            }\n        } else {\n            // element default display was inline style, so restore it\n            cache.el.style.setProperty('display', cache.elementData.displayStyle);\n        }\n    }\n\n    // store new show status\n    cache.elementData.viewModelPropValue = shouldShow;\n};\n\nexport default showBinding;\n","import {getViewModelPropValue} from './util';\nimport type {BindingCache, ViewModel, BindingAttrs} from './types';\n\n/**\n * textBinding\n * * @description\n * DOM decleartive text binding update dom textnode with viewModel data\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {boolean} forceRender\n */\nconst textBinding = (cache: BindingCache, viewModel: ViewModel, bindingAttrs: BindingAttrs, forceRender: boolean): void => {\n    const dataKey = cache.dataKey;\n    const APP = viewModel.APP || viewModel.$root?.APP;\n\n    // NOTE: this doesn't work for for-of, if and switch bindings because element was not in DOM\n    if (!dataKey || (!forceRender && !(APP?.$rootElement as HTMLElement)?.contains(cache.el))) {\n        return;\n    }\n\n    const newValue = getViewModelPropValue(viewModel, cache);\n    const oldValue = cache.el.textContent;\n\n    if (typeof newValue !== 'undefined' && typeof newValue !== 'object' && newValue !== null) {\n        if (newValue !== oldValue) {\n            cache.el.textContent = String(newValue);\n        }\n    }\n};\n\nexport default textBinding;\n","import {\n    getViewModelPropValue,\n    isPlainObject,\n    arrayRemoveMatch,\n    each,\n} from './util';\nimport type {BindingCache, ViewModel, BindingAttrs, PlainObject} from './types';\n\n/**\n * cssBinding\n * @description\n * DOM decleartive css binding. update classlist.\n * viewModel data can function but must return JSOL.\n * added css class if value is true\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {boolean} forceRender\n */\nconst cssBinding = (cache: BindingCache, viewModel: ViewModel, bindingAttrs: BindingAttrs, forceRender: boolean): void => {\n    const dataKey = cache.dataKey;\n    const APP = viewModel.APP || viewModel.$root?.APP;\n\n    if (!dataKey || (!forceRender && !(APP?.$rootElement as HTMLElement)?.contains(cache.el))) {\n        return;\n    }\n\n    cache.elementData = cache.elementData || {};\n    cache.elementData.viewModelPropValue = cache.elementData.viewModelPropValue || '';\n\n    const oldCssList = cache.elementData.viewModelPropValue;\n    let newCssList = '';\n    const vmCssListObj = getViewModelPropValue(viewModel, cache);\n    let vmCssListArray: string[] = [];\n    let isViewDataObject = false;\n    let isViewDataString = false;\n    let cssList: string[] = [];\n\n    if (typeof vmCssListObj === 'string') {\n        isViewDataString = true;\n    } else if (isPlainObject(vmCssListObj)) {\n        isViewDataObject = true;\n    } else {\n        // reject if vmCssListObj is not an object or string\n        return;\n    }\n\n    if (isViewDataObject) {\n        newCssList = JSON.stringify(vmCssListObj);\n    } else {\n        newCssList = (vmCssListObj as string).replace(/\\s\\s+/g, ' ').trim();\n        vmCssListArray = newCssList.split(' ');\n    }\n    // reject if nothing changed\n    if (oldCssList === newCssList) {\n        return;\n    }\n\n    // get current css classes from element\n    const domCssList = cache.el.classList;\n    // clone domCssList as new array\n    const domCssListLength = domCssList.length;\n    for (let i = 0; i < domCssListLength; i += 1) {\n        cssList.push(domCssList[i]);\n    }\n\n    if (isViewDataObject) {\n        each(vmCssListObj as PlainObject, (k: string, v: unknown) => {\n            const i = cssList.indexOf(k);\n            if (v === true) {\n                cssList.push(k);\n            } else if (i !== -1) {\n                cssList.splice(i, 1);\n            }\n        });\n    } else if (isViewDataString) {\n        // remove oldCssList items from cssList\n        const oldCssArray = typeof oldCssList === 'string' && oldCssList ? oldCssList.split(' ') : [];\n        cssList = arrayRemoveMatch(cssList, oldCssArray) as string[];\n        cssList = cssList.concat(vmCssListArray);\n    }\n\n    // unique cssList array\n    cssList = cssList.filter((v: string, i: number, a: string[]) => {\n        return a.indexOf(v) === i;\n    });\n\n    const cssListString = cssList.join(' ');\n    // update element data\n    cache.elementData.viewModelPropValue = newCssList;\n    // replace all css classes\n    cache.el.setAttribute('class', cssListString);\n};\n\nexport default cssBinding;\n","import {getViewModelValue} from './util';\nimport type {BindingCache, ViewModel, BindingAttrs} from './types';\n\n/**\n * modelBinding\n * @description input element data binding. viewModel -> DOM update\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {boolean} forceRender\n */\nconst modelBinding = (cache: BindingCache, viewModel: ViewModel, bindingAttrs: BindingAttrs, forceRender: boolean): void => {\n    const dataKey = cache.dataKey;\n    let newValue: unknown = '';\n    const APP = viewModel.APP || viewModel.$root?.APP;\n\n    if (!dataKey || (!forceRender && !(APP?.$rootElement as HTMLElement)?.contains(cache.el))) {\n        return;\n    }\n\n    newValue = getViewModelValue(viewModel, dataKey);\n\n    if (typeof newValue !== 'undefined' && newValue !== null) {\n        const $element = cache.el as HTMLInputElement;\n        const isCheckbox = $element.type === 'checkbox';\n        const isRadio = $element.type === 'radio';\n        const inputName = $element.name;\n        const $radioGroup = isRadio ? (APP?.$rootElement as HTMLElement).querySelectorAll(`input[name=\"${inputName}\"]`) : [];\n        const oldValue = isCheckbox ? $element.checked : $element.value;\n\n        // update element value\n        if (newValue !== oldValue) {\n            if (isCheckbox) {\n                $element.checked = Boolean(newValue);\n            } else if (isRadio) {\n                let i = 0;\n                const radioGroupLength = $radioGroup.length;\n\n                for (i = 0; i < radioGroupLength; i += 1) {\n                    const radioInput = $radioGroup[i] as HTMLInputElement;\n                    if (radioInput.value === newValue) {\n                        radioInput.checked = true;\n                        break;\n                    }\n                }\n            } else {\n                $element.value = String(newValue);\n            }\n        }\n    }\n};\n\nexport default modelBinding;\n","\nimport {bindingDataReference} from './config';\nimport {\n    getViewModelValue,\n    resolveViewModelContext,\n    resolveParamList,\n} from './util';\nimport type {BindingCache, ViewModel, BindingAttrs, PlainObject} from './types';\n\n/**\n * Create mouse enter handler\n */\nconst createMouseEnterHandler = (\n    cache: BindingCache,\n    handlers: PlainObject,\n    inHandlerName: string,\n    viewModelContext: ViewModel,\n    paramList: unknown[],\n): (e: MouseEvent) => void => {\n    return function onMouseEnterHandler(e: MouseEvent) {\n        const args = [e, cache.el, ...paramList];\n        (handlers[inHandlerName] as Function).apply(viewModelContext, args);\n    };\n};\n\n/**\n * Create mouse leave handler\n */\nconst createMouseLeaveHandler = (\n    cache: BindingCache,\n    handlers: PlainObject,\n    outHandlerName: string,\n    viewModelContext: ViewModel,\n    paramList: unknown[],\n): (e: MouseEvent) => void => {\n    return function onMouseLeaveHandler(e: MouseEvent) {\n        const args = [e, cache.el, ...paramList];\n        (handlers[outHandlerName] as Function).apply(viewModelContext, args);\n    };\n};\n\n/**\n * hoverBinding\n * DOM decleartive on hover event binding\n * event handler bind to viewModel method according to the DOM attribute\n * @param {object} cache\n * @param {object} viewModel\n * @param {object} bindingAttrs\n * @param {boolean} forceRender\n */\nconst hoverBinding = (cache: BindingCache, viewModel: ViewModel, bindingAttrs: BindingAttrs, forceRender: boolean): void => {\n    const handlerName = cache.dataKey;\n    let paramList = cache.parameters;\n    const inHandlerName = bindingDataReference.mouseEnterHandlerName;\n    const outHandlerName = bindingDataReference.mouseLeaveHandlerName;\n    let viewModelContext: ViewModel;\n    const APP = viewModel.APP || viewModel.$root?.APP;\n\n    cache.elementData = cache.elementData || {};\n\n    // TODO: check what is APP.$rootElement.contains(cache.el)\n    const rootElement = APP?.$rootElement as HTMLElement | undefined;\n    if (!handlerName || (!forceRender && rootElement && !rootElement.contains(cache.el))) {\n        return;\n    }\n\n    const handlers = getViewModelValue(viewModel, handlerName) as PlainObject;\n\n    if (handlers && typeof handlers[inHandlerName] === 'function' && typeof handlers[outHandlerName] === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n\n        const onMouseEnterHandler = createMouseEnterHandler(cache, handlers as PlainObject, inHandlerName, viewModelContext, paramList);\n        const onMouseLeaveHandler = createMouseLeaveHandler(cache, handlers as PlainObject, outHandlerName, viewModelContext, paramList);\n\n        cache.el.removeEventListener('mouseenter', onMouseEnterHandler, false);\n        cache.el.removeEventListener('mouseleave', onMouseLeaveHandler, false);\n\n        cache.el.addEventListener('mouseenter', onMouseEnterHandler, false);\n        cache.el.addEventListener('mouseleave', onMouseLeaveHandler, false);\n    }\n};\n\nexport default hoverBinding;\n","import * as util from './util';\n\n/**\n *  pubSub\n * @description use jQuery object as pubSub\n * @example EVENTS object strucure:\n *  EVENTS = {\n        'EVENT-NAME': [{ 'comp-id': fn }],\n        'EVENT-NAME2': [{ 'comp-id': fn }]\n    };\n */\n\ninterface Subscriber {\n    [compId: string]: Function | boolean | undefined;\n    isOnce?: boolean;\n}\n\ninterface Events {\n    [eventName: string]: Subscriber[];\n}\n\nconst EVENTS: Events = {};\n\nexport const subscribeEvent = (instance: unknown = null, eventName: string = '', fn: Function, isOnce: boolean = false): void => {\n    if (!instance || typeof instance !== 'object' || !('compId' in instance) || !instance.compId || !eventName || typeof fn !== 'function') {\n        return;\n    }\n\n    let subscriber: Subscriber;\n    let isSubscribed = false;\n\n    eventName = eventName.replace(util.REGEX.WHITE_SPACES, '');\n    EVENTS[eventName] = EVENTS[eventName] || [];\n    // check if already subscribed and update callback fn\n    const instanceWithViewModel = instance as { compId: string | number; viewModel: unknown };\n    isSubscribed = EVENTS[eventName].some((subscriber) => {\n        if (subscriber[instanceWithViewModel.compId]) {\n            subscriber[instanceWithViewModel.compId] = fn.bind(instanceWithViewModel.viewModel);\n            subscriber.isOnce = isOnce;\n            return true;\n        }\n        return false;\n    });\n    // push if not yet subscribe\n    if (!isSubscribed) {\n        subscriber = {};\n        subscriber[instanceWithViewModel.compId] = fn.bind(instanceWithViewModel.viewModel);\n        subscriber.isOnce = isOnce;\n        EVENTS[eventName].push(subscriber);\n    }\n};\n\nexport const subscribeEventOnce = (instance: unknown = null, eventName: string = '', fn: Function): void => {\n    subscribeEvent(instance, eventName, fn, true);\n};\n\nexport const unsubscribeEvent = (compId: string | number = '', eventName: string = ''): void => {\n    if (!compId || !eventName) {\n        return;\n    }\n\n    let i = 0;\n    let subscribersLength = 0;\n    let subscriber: Subscriber;\n\n    eventName = eventName.replace(util.REGEX.WHITE_SPACES, '');\n\n    if (EVENTS[eventName]) {\n        subscribersLength = EVENTS[eventName].length;\n        for (i = 0; i < subscribersLength; i += 1) {\n            subscriber = EVENTS[eventName][i];\n            if (subscriber[compId]) {\n                EVENTS[eventName].splice(i, 1);\n                break;\n            }\n        }\n    }\n    // delete the event if no more subscriber\n    if (EVENTS[eventName] && !EVENTS[eventName].length) {\n        delete EVENTS[eventName];\n    }\n};\n\n/**\n * unsubscribeAllEvent\n * @description unsubscribe all event by compId. eg when a component removed\n * @param {string} compId\n */\nexport const unsubscribeAllEvent = (compId: string | number = ''): void => {\n    if (!compId) {\n        return;\n    }\n    Object.keys(EVENTS).forEach((eventName) => {\n        unsubscribeEvent(compId, eventName);\n    });\n};\n\nexport const publishEvent = (eventName: string = '', ...args: unknown[]): void => {\n    if (!eventName || !EVENTS[eventName]) {\n        return;\n    }\n\n    eventName = eventName.replace(util.REGEX.WHITE_SPACES, '');\n\n    EVENTS[eventName].forEach((subscriber) => {\n        Object.keys(subscriber).forEach((compId) => {\n            if (typeof subscriber[compId] === 'function') {\n                const ret = subscriber[compId](...args);\n                if (subscriber.isOnce) {\n                    unsubscribeEvent(compId, eventName);\n                }\n                return ret;\n            }\n        });\n    });\n};\n","import * as config from './config';\nimport {debounceRaf} from './util';\nimport createBindingCache from './domWalker';\nimport createBindingOption from './createBindingOption';\nimport applyBinding from './applyBinding';\nimport renderTemplatesBinding from './renderTemplatesBinding';\nimport postProcess from './postProcess';\nimport * as pubSub from './pubSub';\nimport type {ViewModel, ElementCache, UpdateOption, BindingAttrs} from './types';\n\nlet compIdIndex = 0;\n\nclass Binder {\n    [key: string]: unknown;\n    public initRendered: boolean;\n    public compId: number;\n    public $rootElement: HTMLElement;\n    public viewModel: ViewModel;\n    public bindingAttrs: BindingAttrs;\n    public isServerRendered: boolean;\n    public elementCache: ElementCache;\n    public postProcessQueue: Array<() => void>;\n    public render: (opt?: UpdateOption) => void;\n\n    constructor($rootElement: HTMLElement, viewModel: ViewModel, bindingAttrs: BindingAttrs) {\n        if (!$rootElement || $rootElement.nodeType !== 1 || viewModel === null || typeof viewModel !== 'object') {\n            throw new TypeError('$rootElement or viewModel is invalid');\n        }\n\n        this.initRendered = false;\n\n        this.compId = compIdIndex += 1;\n\n        this.$rootElement = $rootElement;\n\n        this.viewModel = viewModel;\n\n        this.bindingAttrs = bindingAttrs;\n\n        this.isServerRendered = this.$rootElement.getAttribute(config.serverRenderedAttr) !== null;\n\n        // Initialize render method with debounced version\n        this.render = debounceRaf(this._render.bind(this), this) as (opt?: UpdateOption) => void;\n\n        // inject instance into viewModel\n        this.viewModel.APP = this;\n\n        // add $root pointer to viewModel so binding can be refer as $root.something\n        this.viewModel.$root = this.viewModel;\n\n        // 1st step\n        // parsView walk the DOM and create binding cache that holds each element's binding details\n        // this binding cache is like AST for render and update\n        this.parseView();\n\n        // for jquery user set viewModel referece to $rootElement for easy debug\n        // otherwise use Expando to attach viewModel to $rootElement\n        this.$rootElement[config.bindingDataReference.rootDataKey] = this.viewModel;\n\n        return this;\n    }\n\n    /**\n     * parseView\n     * @description\n     * @return {this}\n     * traver from $rootElement to find each data-bind-* element\n     * then apply data binding\n     */\n    public parseView(): this {\n        this.elementCache = createBindingCache({\n            rootNode: this.$rootElement,\n            bindingAttrs: this.bindingAttrs,\n        });\n\n        // updateElementCache if server rendered on init\n        if (this.isServerRendered && !this.initRendered) {\n            this.updateElementCache({\n                templateCache: true,\n            });\n        }\n        return this;\n    }\n\n    /**\n     * updateElementCache\n     * @param {object} opt\n     * @description call createBindingCache to parse view and generate bindingCache\n     */\n    public updateElementCache(\n        opt: {\n            allCache?: boolean;\n            templateCache?: boolean;\n            elementCache?: ElementCache;\n            isRenderedTemplates?: boolean;\n        } = {},\n    ): void {\n        const elementCache = opt.elementCache || this.elementCache;\n\n        if (opt.allCache) {\n            // walk dom from root element to regenerate elementCache\n            this.elementCache = createBindingCache({\n                rootNode: this.$rootElement,\n                bindingAttrs: this.bindingAttrs,\n            });\n        }\n        // walk from first rendered template node to create/update child bindingCache\n        if (opt.allCache || opt.templateCache) {\n            if (elementCache[this.bindingAttrs.tmp] && elementCache[this.bindingAttrs.tmp].length) {\n                // Use for loop to handle templates added during rendering\n                for (let i = 0; i < elementCache[this.bindingAttrs.tmp].length; i++) {\n                    const cache = elementCache[this.bindingAttrs.tmp][i];\n                    // set skipCheck as skipForOfParseFn whenever an node has\n                    // both template and forOf bindings\n                    // then the template bindingCache should be an empty object\n                    let skipForOfParseFn: (() => boolean) | null = null;\n                    if (cache.el.hasAttribute(this.bindingAttrs.forOf)) {\n                        skipForOfParseFn = (): boolean => {\n                            return true;\n                        };\n                    }\n                    cache.bindingCache = createBindingCache({\n                        rootNode: cache.el,\n                        bindingAttrs: this.bindingAttrs,\n                        skipCheck: skipForOfParseFn,\n                        isRenderedTemplate: opt.isRenderedTemplates,\n                    });\n                }\n            }\n        }\n    }\n\n    private _render(opt: UpdateOption = {}): void {\n        let updateOption: UpdateOption = {};\n\n        if (!this.initRendered) {\n            // only update eventsBinding if server rendered\n            if (this.isServerRendered) {\n                this.$rootElement.removeAttribute(config.serverRenderedAttr);\n                updateOption = createBindingOption(config.bindingUpdateConditions.serverRendered, opt);\n            } else {\n                updateOption = createBindingOption(config.bindingUpdateConditions.init, opt);\n            }\n        } else {\n            // when called again only update visualBinding options\n            updateOption = createBindingOption('', opt);\n        }\n\n        // create postProcessQueue before start rendering\n        this.postProcessQueue = [];\n\n        const renderBindingOption = {\n            ctx: this,\n            elementCache: this.elementCache,\n            updateOption,\n            bindingAttrs: this.bindingAttrs,\n            viewModel: this.viewModel,\n        };\n\n        // always render template binding first\n        // render and apply binding to template(s)\n        // this is an share function therefore passing 'this' context\n        renderTemplatesBinding(renderBindingOption);\n\n        // apply bindings to rest of the DOM\n        applyBinding(renderBindingOption);\n\n        // trigger postProcess\n        postProcess(this.postProcessQueue);\n        // clear postProcessQueue\n        this.postProcessQueue.length = 0;\n        delete this.postProcessQueue;\n\n        this.initRendered = true;\n    }\n\n    public subscribe(eventName: string = '', fn: (...args: unknown[]) => void): this {\n        pubSub.subscribeEvent(this, eventName, fn);\n        return this;\n    }\n\n    public subscribeOnce(eventName: string = '', fn: (...args: unknown[]) => void): this {\n        pubSub.subscribeEventOnce(this, eventName, fn);\n        return this;\n    }\n\n    public unsubscribe(eventName: string = ''): this {\n        pubSub.unsubscribeEvent(this.compId, eventName);\n        return this;\n    }\n\n    public unsubscribeAll(): this {\n        pubSub.unsubscribeAllEvent(this.compId);\n        return this;\n    }\n\n    public publish(eventName: string = '', ...args: unknown[]): this {\n        pubSub.publishEvent(eventName, ...args);\n        return this;\n    }\n}\n\nexport default Binder;\n","import {\n    each,\n    throwErrorMessage,\n} from './util';\n\nconst postProcess = (tasks: Function[]): void => {\n    if (!tasks || !tasks.length) {\n        return;\n    }\n\n    each(tasks, (index: number, task: Function) => {\n        if (typeof task === 'function') {\n            try {\n                task();\n            } catch (err) {\n                throwErrorMessage(err, `Error postProcess: ${  String(task)}`);\n            }\n        }\n    });\n};\n\nexport default postProcess;\n","import * as config from './config';\nimport {extend} from './util';\nimport Binder from './binder';\nimport type {PlainObject, ViewModel, BindingAttrs} from './types';\n\nconst isSupportPromise = typeof window['Promise'] === 'function';\n\nlet bindingAttrs = config.bindingAttrs;\n\nconst use = (settings: PlainObject = {}): void => {\n    if (settings.bindingAttrs) {\n        bindingAttrs = extend(false, {}, settings.bindingAttrs as PlainObject) as unknown as typeof config.bindingAttrs;\n    }\n};\n\nconst init = ($rootElement: HTMLElement, viewModel: ViewModel | null = null): Binder | void => {\n    if (!isSupportPromise) {\n        return console.warn('Browser not support Promise');\n    }\n    return new Binder($rootElement, viewModel, bindingAttrs as unknown as BindingAttrs);\n};\n\nexport default {\n    use,\n    init,\n    version: '@version@',\n};\n"],"names":["bindingAttrs","comp","tmp","text","click","dblclick","blur","focus","hover","input","change","submit","model","show","css","attr","forOf","if","switch","case","default","serverRenderedAttr","commentPrefix","commentSuffix","bindingDataReference","bindingUpdateConditions","maxDatakeyLength","constants","ONCE","hasIsArray","Array","isArray","REGEX","BAD_TAGS","FOR_OF","FUNCTION_PARAM","HTML_TAG","OBJECT_LITERAL","PIPE","WHITE_SPACES","LINE_BREAKS_TABS","IS_SUPPORT_TEMPLATE","document","createElement","WRAP_MAP","div","thead","col","tr","td","caption","colgroup","tbody","tfoot","th","obj","Object","prototype","toString","call","isJsObject","isPlainObject","ctor","constructor","prot","hasOwnProperty","isEmptyObject","getOwnPropertyNames","length","createHtmlFragment","htmlString","template","innerHTML","removeBadTags","replace","content","fragment","createDocumentFragment","queryContainer","firstTag","match","getFirstHtmlStringTag","wrap","createRange","createContextualFragment","insertAdjacentHTML","query","querySelector","firstChild","appendChild","DANGEROUS_PROPS","isSafeProperty","prop","includes","getViewModelValue","viewModel","_get","path","def","fullPath","split","filter","Boolean","current","step","undefined","setViewModelValue","value","_set","pathArray","key","console","warn","lastKey","target","slice","reduce","a","c","i","nextKey","Math","abs","Number","getViewModelPropValue","bindingCache","dataKey","paramList","parameters","isInvertBoolean","charAt","substring","ret","viewModelContext","resolveViewModelContext","oldViewModelProValue","elementData","viewModelPropValue","resolveParamList","args","concat","el","apply","filtersViewModelPropValue","filters","each","index","filterFn","err","throwErrorMessage","createDeferredObj","dfObj","promise","Promise","resolve","reject","extend","isDeepMerge","sources","source","shift","isMergebleObject","keys","forEach","_extends","fn","keysLength","isArrayObj","TypeError","item","cloneDomNode","element","cloneNode","insertAfter","parentNode","newNode","referenceNode","refNextElement","nextSibling","insertBefore","datakey","bindingDataContext","config","map","param","resolvedParam","trim","emptyElement","node","removeChild","areNodesEqual","node1","node2","nodeType","nodeValue","el2","tagName","updateElementAttributes","existingElement","newElement","newAttrs","attributes","name","getAttribute","setAttribute","createFragmentFromChildren","from","childNodes","child","updateDomWithMinimalChanges","targetElement","newFragment","newNodes","existingNodes","existingNode","replaceChild","errorMessage","message","error","log","bindingAttrsMap","walkDOM","func","parseChildNode","currentNode","firstElementChild","nextElementSibling","rootSkipCheck","defaultSkipCheck","hasAttribute","populateBindingCache","attrObj","type","attrValue","cacheData","filterList","isOnceIndex","v","isOnce","splice","extractFilterList","str","paramlist","params","getFunctionParameterList","push","createBindingCache","rootNode","skipCheck","isRenderedTemplate","window","Node","sourceObj","invertedKey","parseNode","skipNodeCheckFn","isSkipForOfChild","hasAttributes","getAttributesObject","hasSkipChildParseBindings","checkSkipChildParseBindings","iterateList","createBindingOption","condition","opt","visualBindingOptions","templateBinding","textBinding","cssBinding","ifBinding","showBinding","modelBinding","attrBinding","forOfBinding","switchBinding","eventsBindingOptions","changeBinding","clickBinding","dblclickBinding","blurBinding","focusBinding","hoverBinding","inputBinding","submitBinding","serverRenderedOptions","updateOption","forceRender","reUnescapedHtml","reHasUnescapedHtml","RegExp","htmlEscapes","escapeHtmlChar","chr","createChangeHandler","modelDataKey","handlerFn","oldValue","newValue","e","$this","this","isCheckbox","checked","string","strValue","test","_escape","currentTarget","cache","handlerName","APP","_a","$root","rootElement","$rootElement","contains","changeHandler","removeEventListener","addEventListener","_bindingAttrs","_forceRender","isObjLiteralStr","isObjectLiteralString","vmAttrObj","parseBindingObjectString","objectLiteralString","keyVal","JSON","stringify","oldAttrObj","String","_value","removeAttribute","$domFragment","$templateRoot","$templateRootPrepend","$templateRootAppend","nestTemplatesCount","renderTemplate","elementCache","settings","parse","parseStringToJson","viewData","data","isAppend","append","isPrepend","prepend","$currentElement","$element","$indexAttr","$index","parseInt","id","templateElement","getElementById","getTemplateString","htmlFragment","$nestedTemplates","querySelectorAll","nestedTemplatesLength","thisTemplateCache","afterTemplateRender","renderTemplatesBinding","ctx","updateElementCache","templateCache","isRenderedTemplates","applyBindingModule","renderIteration","iterationVm","isRegenerate","bindingUpdateOption","createClonedElementCache","bindingData","clonedElement","setCommentPrefix","dataKeyMarker","util","setDocRangeEndAfter","endTextContent","textContent","docRange","setEndBefore","wrapCommentAround","prefix","commentBegin","createComment","commentEnd","previousNonTemplateElement","previousSibling","nextNonTemplateElement","parentElement","removeElemnetsByCommentWrap","setStartBefore","Error","deleteContents","insertRenderedElements","createIterationViewModel","iterationData","alias","iterator","generateForOfElements","iterationDataLength","iterationSize","clonedItem","iterationBindingCache","forExpMatch","renderForOfBinding","configBindingAttrs","removeIfBinding","hasIterationBindingCache","renderIfBinding","isDomRemoved","commentStartTextContent","endCommentTag","isTargetDomRemoved","removeBindingInQueue","postProcessQueue","parentRef","indexOf","removeUnmatchCases","cases","matchedIndex","caseData","createCaseData","attrName","createEventHandlerWrapper","formData","$form","HTMLFormElement","FormData","getFormData","createEventBinding","handlerWrap","applyBinding","_ctx","shouldRender","currentInlineSytle","currentInlineDisplaySytle","shouldShow","oldShowStatus","displayStyle","computedStyle","style","display","computeStyle","getComputedStyle","getPropertyValue","setProperty","removeProperty","newExpression","childrenElements","children","elementLength","childElement","isDefault","hasMatch","j","casesLength","newCaseValue","_b","oldCssList","newCssList","vmCssListObj","vmCssListArray","isViewDataObject","isViewDataString","cssList","domCssList","classList","domCssListLength","k","oldCssArray","frommArray","_index","arrayRemoveMatch","cssListString","join","isRadio","inputName","$radioGroup","radioGroupLength","radioInput","inHandlerName","outHandlerName","handlers","onMouseEnterHandler","createMouseEnterHandler","onMouseLeaveHandler","createMouseLeaveHandler","EVENTS","subscribeEvent","instance","eventName","compId","subscriber","isSubscribed","instanceWithViewModel","some","bind","unsubscribeEvent","subscribersLength","compIdIndex","Binder","initRendered","isServerRendered","render","debounceRaf","rafId","arguments","cancelAnimationFrame","requestAnimationFrame","_render","parseView","allCache","skipForOfParseFn","renderBindingOption","tasks","task","subscribe","pubSub","subscribeOnce","subscribeEventOnce","unsubscribe","unsubscribeAll","unsubscribeAllEvent","publish","publishEvent","isSupportPromise","use","init","version"],"mappings":"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"}