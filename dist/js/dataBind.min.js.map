{"version":3,"sources":["dataBind.min.js"],"names":["global","factory","exports","module","define","amd","globalThis","self","dataBind","this","bindingAttrs$1","comp","tmp","text","click","dblclick","blur","focus","hover","input","change","submit","model","show","css","attr","forOf","if","switch","case","default","serverRenderedAttr","commentPrefix","commentSuffix","bindingDataReference","bindingUpdateConditions","maxDatakeyLength","constants","ONCE","hasIsArray","Array","isArray","REGEX","BAD_TAGS","FOR_OF","FUNCTION_PARAM","HTML_TAG","OBJECT_LITERAL","PIPE","WHITE_SPACES","LINE_BREAKS_TABS","IS_SUPPORT_TEMPLATE","document","createElement","WRAP_MAP","div","thead","col","tr","td","caption","colgroup","tbody","tfoot","th","obj","Object","prototype","toString","call","isJsObject","isPlainObject","ctor","constructor","prot","hasOwnProperty","isEmptyObject","getOwnPropertyNames","length","createHtmlFragment","htmlString","template","innerHTML","replace","removeBadTags","content","fragment","createDocumentFragment","queryContainer","firstTag","match","getFirstHtmlStringTag","wrap","createRange","createContextualFragment","insertAdjacentHTML","query","querySelector","firstChild","appendChild","getViewModelValue","viewModel","prop","split","filter","Boolean","every","step","undefined","def","setViewModelValue","value","path","slice","reduce","a","c","i","Math","abs","_set","getViewModelPropValue","bindingCache","dataKey","paramList","parameters","isInvertBoolean","charAt","substring","ret","viewModelContext","resolveViewModelContext","oldViewModelProValue","elementData","viewModelPropValue","resolveParamList","args","concat","el","apply","filtersViewModelPropValue","filters","each","index","filterFn","err","throwErrorMessage","createDeferredObj","dfObj","promise","Promise","resolve","reject","extend","isDeepMerge","target","sources","source","shift","isMergebleObject","keys","forEach","key","assign","fn","keysLength","isArrayObj","TypeError","item","insertAfter","parentNode","newNode","referenceNode","refNextElement","nextSibling","insertBefore","datakey","bindingDataContext","map","param","trim","emptyElement","node","removeChild","errorMessage","message","console","error","log","bindingAttrsMap","walkDOM","func","parseChildNode","firstElementChild","nextElementSibling","rootSkipCheck","tagName","defaultSkipCheck","bindingAttrs","hasAttribute","populateBindingCache","attrObj","type","attrValue","cacheData","filterList","isOnceIndex","v","isOnce","splice","extractFilterList","str","paramlist","getFunctionParameterList","push","createBindingCache","rootNode","skipCheck","isRenderedTemplate","window","Node","sourceObj","parseNode","skipNodeCheckFn","isSkipForOfChild","nodeType","hasAttributes","attributes","name","getAttributesObject","hasSkipChildParseBindings","checkSkipChildParseBindings","iterateList","createBindingOption","condition","opt","visualBindingOptions","templateBinding","textBinding","cssBinding","ifBinding","showBinding","modelBinding","attrBinding","forOfBinding","switchBinding","eventsBindingOptions","changeBinding","clickBinding","dblclickBinding","blurBinding","focusBinding","hoverBinding","inputBinding","submitBinding","serverRenderedOptions","updateOption","reUnescapedHtml","reHasUnescapedHtml","RegExp","htmlEscapes","escapeHtmlChar","chr","cache","forceRender","handlerName","modelDataKey","getAttribute","newValue","oldValue","APP","$root","$rootElement","contains","handlerFn","changeHandler","e","$this","isCheckbox","string","checked","test","currentTarget","removeEventListener","addEventListener","isObjLiteralStr","isObjectLiteralString","vmAttrObj","objectLiteralString","keyVal","parseBindingObjectString","JSON","stringify","oldAttrObj","setAttribute","removeAttribute","$domFragment","$templateRoot","nestTemplatesCount","renderTemplate","elementCache","settings","parse","parseStringToJson","viewData","data","isAppend","append","isPrepend","prepend","$currentElement","$element","$index","htmlFragment","id","templateElement","getElementById","getTemplateString","childNodes","$nestedTemplates","querySelectorAll","nestedTemplatesLength","thisTemplateCache","afterTemplateRender","renderTemplatesBinding","ctx","updateElementCache","templateCache","isRenderedTemplates","applyBinding","renderIteration","iterationVm","isRegenerate","bindingUpdateOption","createClonedElementCache","bindingData","clonedElement","cloneNode","setCommentPrefix","commentPrefix$1","dataKeyMarker","setDocRangeEndAfter","endTextContent","textContent","docRange","setEndBefore","wrapCommentAround","prefix","commentBegin","createComment","commentEnd","previousNonTemplateElement","previousSibling","nextNonTemplateElement","parentElement","removeElemnetsByCommentWrap","setStartBefore","deleteContents","insertRenderedElements","createIterationViewModel","iterationData","iterator","alias","generateForOfElements","iterationDataLength","iterationSize","clonedItem","iterationBindingCache","forExpMatch","renderForOfBinding","renderIfBinding","isDomRemoved","commentStartTextContent","endCommentTag","isTargetDomRemoved","rootElement","removeIfBinding","hasIterationBindingCache","removeBindingInQueue","postProcessQueue","indexOf","removeUnmatchCases","cases","matchedIndex","caseData","createCaseData","attrName","createEventBinding","handlerWrap","formData","$form","HTMLFormElement","FormData","getFormData","shouldRender","currentInlineSytle","currentInlineDisplaySytle","shouldShow","oldShowStatus","displayStyle","computedStyle","style","display","computeStyle","getComputedStyle","getPropertyValue","setProperty","removeProperty","newExpression","childrenElements","children","elementLength","isDefault","hasMatch","j","casesLength","newCaseValue","oldCssList","newCssList","vmCssListObj","vmCssListArray","isViewDataObject","isViewDataString","cssList","domCssList","classList","domCssListLength","frommArray","k","join","isRadio","inputName","$radioGroup","radioGroupLength","inHandlerName","outHandlerName","handlers","onMouseEnterHandler","onMouseLeaveHandler","EVENTS","subscribeEvent","instance","eventName","compId","subscriber","isSubscribed","some","bind","unsubscribeEvent","subscribersLength","compIdIndex","Binder","initRendered","render","rafId","from","arguments","cancelAnimationFrame","requestAnimationFrame","debounceRaf","isServerRendered","parseView","allCache","skipForOfParseFn","renderBindingOption","tasks","task","String","subscribe","subscribeOnce","subscribeEventOnce","unsubscribe","unsubscribeAll","unsubscribeAllEvent","publish","publishEvent","isSupportPromise","use","init","warn","version"],"mappings":"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","file":"dataBind.min.js","sourcesContent":["/**\n * @gogocat/data-bind\n * version 1.12.0\n * By Adam Chow\n * link https://gogocat.github.io/dataBind/\n * license MIT\n * \n */\n\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.dataBind = factory());\n}(this, (function () { 'use strict';\n\n    const bindingAttrs$1 = {\n      comp: 'data-bind-comp',\n      tmp: 'data-bind-tmp',\n      text: 'data-bind-text',\n      click: 'data-bind-click',\n      dblclick: 'data-bind-dblclick',\n      blur: 'data-bind-blur',\n      focus: 'data-bind-focus',\n      hover: 'data-bind-hover',\n      input: 'data-bind-input',\n      change: 'data-bind-change',\n      submit: 'data-bind-submit',\n      model: 'data-bind-model',\n      show: 'data-bind-show',\n      css: 'data-bind-css',\n      attr: 'data-bind-attr',\n      forOf: 'data-bind-for',\n      if: 'data-bind-if',\n      switch: 'data-bind-switch',\n      case: 'data-bind-case',\n      default: 'data-bind-default'\n    };\n    const serverRenderedAttr = 'data-server-rendered';\n    const dataIndexAttr = 'data-index';\n    const commentPrefix = {\n      forOf: 'data-forOf_',\n      if: 'data-if_',\n      case: 'data-case_',\n      default: 'data-default_'\n    };\n    const commentSuffix = '_end';\n    const bindingDataReference = {\n      rootDataKey: '$root',\n      currentData: '$data',\n      currentIndex: '$index',\n      mouseEnterHandlerName: 'in',\n      mouseLeaveHandlerName: 'out'\n    };\n    const bindingUpdateConditions = {\n      serverRendered: 'SERVER-RENDERED',\n      init: 'INIT'\n    }; // maximum string length before running regex\n\n    const maxDatakeyLength = 250;\n    const constants = {\n      filters: {\n        ONCE: 'once'\n      },\n      PARENT_REF: '_parent'\n    };\n\n    const hasIsArray = Array.isArray;\n    const REGEX = {\n      BAD_TAGS: /<(script|del)(?=[\\s>])[\\w\\W]*?<\\/\\1\\s*>/ig,\n      FOR_OF: /(.*?)\\s+(?:in|of)\\s+(.*)/,\n      FUNCTION_PARAM: /\\((.*?)\\)/,\n      HTML_TAG: /^[\\s]*<([a-z][^\\/\\s>]+)/i,\n      OBJECT_LITERAL: /^\\{.+\\}$/,\n      PIPE: /\\|/,\n      WHITE_SPACES: /\\s+/g,\n      LINE_BREAKS_TABS: /(\\r\\n|\\n|\\r|\\t)/gm\n    };\n    const IS_SUPPORT_TEMPLATE = ('content' in document.createElement('template'));\n    const WRAP_MAP = {\n      div: ['div', '<div>', '</div>'],\n      thead: ['table', '<table>', '</table>'],\n      col: ['colgroup', '<table><colgroup>', '</colgroup></table>'],\n      tr: ['tbody', '<table><tbody>', '</tbody></table>'],\n      td: ['tr', '<table><tr>', '</tr></table>']\n    };\n    WRAP_MAP.caption = WRAP_MAP.colgroup = WRAP_MAP.tbody = WRAP_MAP.tfoot = WRAP_MAP.thead;\n    WRAP_MAP.th = WRAP_MAP.td;\n\n    const isArray = obj => {\n      return hasIsArray ? Array.isArray(obj) : Object.prototype.toString.call(obj) === '[object Array]';\n    };\n\n    const isJsObject = obj => {\n      return obj !== null && typeof obj === 'object' && Object.prototype.toString.call(obj) === '[object Object]';\n    };\n\n    const isPlainObject = obj => {\n      if (!isJsObject(obj)) {\n        return false;\n      } // If has modified constructor\n\n\n      const ctor = obj.constructor;\n      if (typeof ctor !== 'function') return false; // If has modified prototype\n\n      const prot = ctor.prototype;\n      if (isJsObject(prot) === false) return false; // If constructor does not have an Object-specific method\n\n      if (prot.hasOwnProperty('isPrototypeOf') === false) {\n        return false;\n      } // Most likely a plain Object\n\n\n      return true;\n    }; // test if string contains '{...}'. string must not contains tab, line breaks\n\n\n    const isObjectLiteralString = (str = '') => {\n      return REGEX.OBJECT_LITERAL.test(str);\n    };\n\n    const isEmptyObject = obj => {\n      if (isJsObject(obj)) {\n        return Object.getOwnPropertyNames(obj).length === 0;\n      }\n\n      return false;\n    };\n\n    function getFirstHtmlStringTag(htmlString) {\n      const match = htmlString.match(REGEX.HTML_TAG);\n\n      if (match) {\n        return match[1];\n      }\n\n      return null;\n    }\n\n    function removeBadTags(htmlString = '') {\n      return htmlString.replace(REGEX.BAD_TAGS, '');\n    }\n\n    function createHtmlFragment(htmlString) {\n      if (typeof htmlString !== 'string') {\n        return null;\n      } // use template element\n\n\n      if (IS_SUPPORT_TEMPLATE) {\n        const template = document.createElement('template');\n        template.innerHTML = removeBadTags(htmlString);\n        return template.content;\n      } // use document fragment with wrap html tag for tr, td etc.\n\n\n      const fragment = document.createDocumentFragment();\n      const queryContainer = document.createElement('div');\n      const firstTag = getFirstHtmlStringTag(htmlString);\n      const wrap = WRAP_MAP[firstTag || 'div'];\n\n      if (wrap[0] === 'div') {\n        return document.createRange().createContextualFragment(htmlString);\n      }\n\n      queryContainer.insertAdjacentHTML('beforeend', `${wrap[1]}${htmlString}${wrap[2]}`);\n      const query = queryContainer.querySelector(wrap[0]);\n\n      while (query.firstChild) {\n        fragment.appendChild(query.firstChild);\n      }\n\n      return fragment;\n    }\n\n\n    const _get = function get(obj, path, def) {\n      function everyFunc(step) {\n        return !(step && (obj = obj[step]) === undefined);\n      }\n\n      const fullPath = path.replace(/\\[/g, '.').replace(/]/g, '').split('.').filter(Boolean);\n      return fullPath.every(everyFunc) ? obj : def;\n    };\n    /**\r\n     * getViewModelValue\r\n     * @description walk a object by provided string path. eg 'a.b.c'\r\n     * @param {object} viewModel\r\n     * @param {string} prop\r\n     * @return {object}\r\n     */\n\n\n    const getViewModelValue = (viewModel, prop) => {\n      return _get(viewModel, prop);\n    }; // simplified version of Lodash _.set\n    // https://stackoverflow.com/questions/54733539/javascript-implementation-of-lodash-set-method\n\n\n    const _set = (obj, path, value) => {\n      if (Object(obj) !== obj) return obj; // When obj is not an object\n      // If not yet an array, get the keys from the string-path\n\n      if (!Array.isArray(path)) path = path.toString().match(/[^.[\\]]+/g) || []; // Iterate all of them except the last one\n\n      path.slice(0, -1).reduce((a, c, i) => Object(a[c]) === a[c] ? // Does the key exist and is its value an object?\n      // Yes: then follow that path\n      a[c] : // No: create the key. Is the next key a potential array-index?\n      a[c] = Math.abs(path[i + 1]) >> 0 === +path[i + 1] ? [] : // Yes: assign a new array object\n      {}, // No: assign a new plain object\n      obj)[path[path.length - 1]] = value; // Finally assign the value to the last key\n      // Return the top-level object to allow chaining\n\n      return obj;\n    };\n    /**\r\n     * setViewModelValue\r\n     * @description populate viewModel object by path string\r\n     * @param {object} obj\r\n     * @param {string} prop\r\n     * @param {string} value\r\n     * @return {call} underscore set\r\n     */\n\n\n    const setViewModelValue = (obj, prop, value) => {\n      return _set(obj, prop, value);\n    };\n\n    const getViewModelPropValue = (viewModel, bindingCache) => {\n      let dataKey = bindingCache.dataKey;\n      let paramList = bindingCache.parameters;\n      const isInvertBoolean = dataKey.charAt(0) === '!';\n\n      if (isInvertBoolean) {\n        dataKey = isInvertBoolean ? dataKey.substring(1) : dataKey;\n      }\n\n      let ret = getViewModelValue(viewModel, dataKey);\n\n      if (typeof ret === 'function') {\n        const viewModelContext = resolveViewModelContext(viewModel, dataKey);\n        const oldViewModelProValue = bindingCache.elementData ? bindingCache.elementData.viewModelPropValue : null;\n        paramList = paramList ? resolveParamList(viewModel, paramList) : []; // let args = [oldViewModelProValue, bindingCache.el].concat(paramList);\n\n        const args = paramList.concat([oldViewModelProValue, bindingCache.el]);\n        ret = ret.apply(viewModelContext, args);\n      }\n\n      ret = isInvertBoolean ? !Boolean(ret) : ret; // call through fitlers to get final value\n\n      ret = filtersViewModelPropValue({\n        value: ret,\n        viewModel: viewModel,\n        bindingCache: bindingCache\n      });\n      return ret;\n    };\n\n    const filtersViewModelPropValue = ({\n      value,\n      viewModel,\n      bindingCache\n    }) => {\n      let ret = value;\n\n      if (bindingCache.filters) {\n        each(bindingCache.filters, (index, filter) => {\n          const viewModelContext = resolveViewModelContext(viewModel, filter);\n          const filterFn = getViewModelValue.call(viewModelContext, viewModelContext, filter);\n\n          try {\n            ret = filterFn.call(viewModelContext, ret);\n          } catch (err) {\n            throwErrorMessage(err, `Invalid filter: ${filter}`);\n          }\n        });\n      }\n\n      return ret;\n    };\n\n    const parseStringToJson = str => {\n      // fix unquote or single quote keys and replace single quote to double quote\n      const ret = str.replace(/(\\s*?{\\s*?|\\s*?,\\s*?)(['\"])?([a-zA-Z0-9]+)(['\"])?:/g, '$1\"$3\":').replace(/'/g, '\"');\n      return JSON.parse(ret);\n    };\n    /**\r\n     * arrayRemoveMatch\r\n     * @description remove match items in fromArray out of toArray\r\n     * @param {array} toArray\r\n     * @param {array} frommArray\r\n     * @return {boolean}\r\n     */\n\n\n    const arrayRemoveMatch = (toArray, frommArray) => {\n      return toArray.filter((value, index) => {\n        return frommArray.indexOf(value) < 0;\n      });\n    };\n\n    const getFormData = $form => {\n      const data = {};\n\n      if (!$form instanceof HTMLFormElement) {\n        return data;\n      }\n\n      const formData = new FormData($form);\n      formData.forEach((value, key) => {\n        if (!Object.prototype.hasOwnProperty.call(Object, key)) {\n          data[key] = value;\n          return;\n        }\n\n        if (!Array.isArray(data[key])) {\n          data[key] = [data[key]];\n        }\n\n        data[key].push(value);\n      });\n      return data;\n    };\n    /**\r\n     * getFunctionParameterList\r\n     * @description convert parameter string to arrary\r\n     * eg. '(\"a\",\"b\",\"c\")' > [\"a\",\"b\",\"c\"]\r\n     * @param {string} str\r\n     * @return {array} paramlist\r\n     */\n\n\n    const getFunctionParameterList = str => {\n      if (!str || str.length > maxDatakeyLength) {\n        return;\n      }\n\n      let paramlist = str.match(REGEX.FUNCTION_PARAM);\n\n      if (paramlist && paramlist[1]) {\n        paramlist = paramlist[1].split(',');\n        paramlist.forEach(function (v, i) {\n          paramlist[i] = v.trim();\n        });\n      }\n\n      return paramlist;\n    };\n\n    const extractFilterList = cacheData => {\n      if (!cacheData || !cacheData.dataKey || cacheData.dataKey.length > maxDatakeyLength) {\n        return cacheData;\n      }\n\n      const filterList = cacheData.dataKey.split(REGEX.PIPE);\n      let isOnceIndex;\n      cacheData.dataKey = filterList[0].trim();\n\n      if (filterList.length > 1) {\n        filterList.shift(0);\n        filterList.forEach(function (v, i) {\n          filterList[i] = v.trim();\n\n          if (filterList[i] === constants.filters.ONCE) {\n            cacheData.isOnce = true;\n            isOnceIndex = i;\n          }\n        }); // don't store filter 'once' - because it is internal logic not a property from viewModel\n\n        if (isOnceIndex >= 0) {\n          filterList.splice(isOnceIndex, 1);\n        }\n\n        cacheData.filters = filterList;\n      }\n\n      return cacheData;\n    };\n\n    const invertObj = sourceObj => {\n      return Object.keys(sourceObj).reduce(function (obj, key) {\n        obj[sourceObj[key]] = key;\n        return obj;\n      }, {});\n    };\n\n    const createDeferredObj = () => {\n      const dfObj = {};\n      dfObj.promise = new Promise((resolve, reject) => {\n        dfObj.resolve = resolve;\n        dfObj.reject = reject;\n      });\n      return dfObj;\n    };\n    /**\r\n     * debounce\r\n     * @description decorate a function to be debounce using requestAnimationFrame\r\n     * @param {function} fn\r\n     * @param {context} ctx\r\n     * @return {function}\r\n     */\n\n\n    const debounceRaf = (fn, ctx = null) => {\n      return function (fn, ctx) {\n        let dfObj = createDeferredObj();\n        let rafId = 0; // return decorated fn\n\n        return function () {\n          /* eslint-disable prefer-rest-params */\n          const args = Array.from ? Array.from(arguments) : Array.prototype.slice.call(arguments);\n          window.cancelAnimationFrame(rafId);\n          rafId = window.requestAnimationFrame(() => {\n            try {\n              // fn is Binder.render function\n              fn.apply(ctx, args); // dfObj.resolve is function provided in .then promise chain\n              // ctx is the current component\n\n              dfObj.resolve(ctx);\n            } catch (err) {\n              console.error('error in rendering: ', err);\n              dfObj.reject(err);\n            } // reset dfObj - otherwise then callbacks will not be in execution order\n            // example:\n            // myApp.render().then(function(){console.log('ok1')});\n            // myApp.render().then(function(){console.log('ok2')});\n            // myApp.render().then(function(){console.log('ok3')});\n            // >> ok1, ok2, ok3\n\n\n            dfObj = createDeferredObj();\n            window.cancelAnimationFrame(rafId);\n          });\n          return dfObj.promise;\n        };\n      }(fn, ctx);\n    };\n    /**\r\n     * extend\r\n     * @param {boolean} isDeepMerge\r\n     * @param {object} target\r\n     * @param {object} sources\r\n     * @return {object} merged object\r\n     */\n\n\n    const extend = (isDeepMerge = false, target, ...sources) => {\n      if (!sources.length) {\n        return target;\n      }\n\n      const source = sources.shift();\n\n      if (source === undefined) {\n        return target;\n      }\n\n      if (!isDeepMerge) {\n        return Object.assign(target, ...sources);\n      }\n\n      if (isMergebleObject(target) && isMergebleObject(source)) {\n        Object.keys(source).forEach(key => {\n          if (isMergebleObject(source[key])) {\n            if (!target[key]) {\n              target[key] = {};\n            }\n\n            extend(target[key], source[key]);\n          } else {\n            target[key] = source[key];\n          }\n        });\n      }\n\n      return extend(true, target, ...sources);\n    };\n\n    const each = (obj, fn) => {\n      if (typeof obj !== 'object' || typeof fn !== 'function') {\n        return;\n      }\n\n      let keys = [];\n      let keysLength = 0;\n      const isArrayObj = isArray(obj);\n      let key;\n      let value;\n      let i = 0;\n\n      if (isArrayObj) {\n        keysLength = obj.length;\n      } else if (isJsObject(obj)) {\n        keys = Object.keys(obj);\n        keysLength = keys.length;\n      } else {\n        throw new TypeError('Object is not an array or object');\n      }\n\n      for (i = 0; i < keysLength; i += 1) {\n        if (isArrayObj) {\n          key = i;\n          value = obj[i];\n        } else {\n          key = keys[i];\n          value = obj[key];\n        }\n\n        fn(key, value);\n      }\n    };\n\n    const isMergebleObject = item => {\n      return isJsObject(item) && !isArray(item);\n    };\n    /**\r\n     * cloneDomNode\r\n     * @param {object} element\r\n     * @return {object} cloned element\r\n     * @description helper function to clone node\r\n     */\n\n\n    const cloneDomNode = element => {\n      return element.cloneNode(true);\n    };\n    /**\r\n     * insertAfter\r\n     * @param {object} parentNode\r\n     * @param {object} newNode\r\n     * @param {object} referenceNode\r\n     * @return {object} node\r\n     * @description helper function to insert new node before the reference node\r\n     */\n\n\n    const insertAfter = (parentNode, newNode, referenceNode) => {\n      const refNextElement = referenceNode && referenceNode.nextSibling ? referenceNode.nextSibling : null;\n      return parentNode.insertBefore(newNode, refNextElement);\n    };\n\n    const resolveViewModelContext = (viewModel, datakey) => {\n      let ret = viewModel;\n\n      if (typeof datakey !== 'string') {\n        return ret;\n      }\n\n      const bindingDataContext = datakey.split('.');\n\n      if (bindingDataContext.length > 1) {\n        if (bindingDataContext[0] === bindingDataReference.rootDataKey) {\n          ret = viewModel[bindingDataReference.rootDataKey] || viewModel;\n        } else if (bindingDataContext[0] === bindingDataReference.currentData) {\n          ret = viewModel[bindingDataReference.currentData] || viewModel;\n        }\n      }\n\n      return ret;\n    };\n\n    const resolveParamList = (viewModel, paramList) => {\n      if (!viewModel || !isArray(paramList)) {\n        return;\n      }\n\n      return paramList.map(param => {\n        param = param.trim();\n\n        if (param === bindingDataReference.currentIndex) {\n          // convert '$index' to value\n          param = viewModel[bindingDataReference.currentIndex];\n        } else if (param === bindingDataReference.currentData) {\n          // convert '$data' to value or current viewModel\n          param = viewModel[bindingDataReference.currentData] || viewModel;\n        } else if (param === bindingDataReference.rootDataKey) {\n          // convert '$root' to root viewModel\n          param = viewModel[bindingDataReference.rootDataKey] || viewModel;\n        }\n\n        return param;\n      });\n    };\n\n    const removeElement = el => {\n      if (el && el.parentNode) {\n        el.parentNode.removeChild(el);\n      }\n    };\n\n    const emptyElement = node => {\n      if (node && node.firstChild) {\n        while (node.firstChild) {\n          node.removeChild(node.firstChild);\n        }\n      }\n\n      return node;\n    };\n\n    const throwErrorMessage = (err = null, errorMessage = '') => {\n      const message = err && err.message ? err.message : errorMessage;\n\n      if (typeof console.error === 'function') {\n        return console.error(message);\n      }\n\n      return console.log(message);\n    };\n    /**\r\n     * parseBindingObjectString\r\n     * @description parse bining object string to object with value always stringify\r\n     * @param {string} str - eg '{ id: $data.id, name: $data.name }'\r\n     * @return {object} - eg { id: '$data.id', name: '$data.name'}\r\n     */\n\n\n    const parseBindingObjectString = (str = '') => {\n      let objectLiteralString = str.trim();\n      const ret = {};\n\n      if (!REGEX.OBJECT_LITERAL.test(str)) {\n        return null;\n      } // clearn up line breaks and remove first { character\n\n\n      objectLiteralString = objectLiteralString.replace(REGEX.LINE_BREAKS_TABS, '').substring(1); // remove last } character\n\n      objectLiteralString = objectLiteralString.substring(0, objectLiteralString.length - 1);\n      objectLiteralString.split(',').forEach(item => {\n        const keyVal = item.trim(); // ignore if last empty item - eg split last comma in object literal\n\n        if (keyVal) {\n          const prop = keyVal.split(':');\n          const key = prop[0].trim();\n          ret[key] = `${prop[1]}`.trim();\n        }\n      });\n      return ret;\n    };\n\n    let bindingAttrsMap;\n    /**\n     * walkDOM\n     * @description by Douglas Crockford - walk each DOM node and calls provided callback function\n     * start walk from firstChild\n     * @param {object} node\n     * @param {function} func\n     */\n\n    const walkDOM = (node, func) => {\n      let parseChildNode = true;\n      node = node.firstElementChild;\n\n      while (node) {\n        parseChildNode = func(node);\n\n        if (parseChildNode) {\n          walkDOM(node, func);\n        }\n\n        node = node.nextElementSibling;\n      }\n    };\n\n    const getAttributesObject = node => {\n      const ret = {};\n      Array.prototype.slice.call(node.attributes).forEach(item => {\n        ret[item.name] = item.value;\n      });\n      return ret;\n    };\n\n    const checkSkipChildParseBindings = (attrObj = {}, bindingAttrs) => {\n      return [bindingAttrs.forOf, bindingAttrs.if, bindingAttrs.case, bindingAttrs.default].filter(type => {\n        return typeof attrObj[type] !== 'undefined';\n      });\n    };\n\n    const rootSkipCheck = node => {\n      return node.tagName === 'SVG';\n    };\n\n    const defaultSkipCheck = (node, bindingAttrs) => {\n      return node.tagName === 'SVG' || node.hasAttribute(bindingAttrs.comp);\n    };\n\n    const populateBindingCache = ({\n      node,\n      attrObj,\n      bindingCache,\n      type\n    }) => {\n      let attrValue;\n      let cacheData;\n\n      if (bindingAttrsMap && bindingAttrsMap[type] && typeof attrObj[type] !== 'undefined') {\n        bindingCache[type] = bindingCache[type] || [];\n        attrValue = attrObj[type] || '';\n\n        if (attrValue) {\n          attrValue = attrValue.replace(REGEX.LINE_BREAKS_TABS, '').replace(REGEX.WHITE_SPACES, ' ').trim();\n        }\n\n        cacheData = {\n          el: node,\n          dataKey: attrValue\n        }; // populate cacheData.filters. update filterList first item as dataKey\n\n        cacheData = extractFilterList(cacheData); // populate cacheData.parameters\n        // for store function call parameters eg. '$index', '$root'\n        // useful with DOM for-loop template as reference to binding data\n\n        const paramList = getFunctionParameterList(cacheData.dataKey);\n\n        if (paramList) {\n          cacheData.parameters = paramList;\n          cacheData.dataKey = cacheData.dataKey.replace(REGEX.FUNCTION_PARAM, '').trim();\n        } // store parent array reference to cacheData\n\n\n        cacheData[constants.PARENT_REF] = bindingCache[type];\n        bindingCache[type].push(cacheData);\n      }\n\n      return bindingCache;\n    };\n\n    const createBindingCache = ({\n      rootNode = null,\n      bindingAttrs = {},\n      skipCheck,\n      isRenderedTemplate = false\n    }) => {\n      let bindingCache = {};\n\n      if (!rootNode instanceof window.Node) {\n        throw new TypeError('walkDOM: Expected a DOM node');\n      }\n\n      bindingAttrsMap = bindingAttrsMap || invertObj(bindingAttrs);\n\n      const parseNode = (node, skipNodeCheckFn = defaultSkipCheck) => {\n        let isSkipForOfChild = false;\n\n        if (node.nodeType !== 1 || !node.hasAttributes()) {\n          return true;\n        }\n\n        if (skipNodeCheckFn(node, bindingAttrs) || typeof skipCheck === 'function' && skipCheck(node)) {\n          return false;\n        } // when creating sub bindingCache if is for tmp binding\n        // skip same element that has forOf binding the  forOf is alredy parsed\n\n\n        const attrObj = getAttributesObject(node);\n        const hasSkipChildParseBindings = checkSkipChildParseBindings(attrObj, bindingAttrs);\n        let iterateList = [];\n\n        if (hasSkipChildParseBindings.length) {\n          isSkipForOfChild = true;\n          iterateList = hasSkipChildParseBindings;\n        } else if (isRenderedTemplate && attrObj[bindingAttrs.tmp]) {\n          // skip current node parse if was called by node has template binding and already rendered\n          return true;\n        } else {\n          iterateList = Object.keys(attrObj);\n        }\n\n        iterateList.forEach(key => {\n          // skip for switch case and default bining\n          if (key !== bindingAttrs.case && key !== bindingAttrs.default) {\n            bindingCache = populateBindingCache({\n              node: node,\n              attrObj: attrObj,\n              bindingCache: bindingCache,\n              type: key\n            });\n          }\n        }); // after cache forOf skip parse child nodes\n\n        if (isSkipForOfChild) {\n          return false;\n        }\n\n        return true;\n      };\n\n      if (parseNode(rootNode, rootSkipCheck)) {\n        walkDOM(rootNode, parseNode);\n      }\n\n      return bindingCache;\n    };\n\n    /**\n     * createBindingOption\n     * @param {string} condition\n     * @param {object} opt\n     * @description\n     * generate binding update option object by condition\n     * @return {object} updateOption\n     */\n\n    function createBindingOption(condition = '', opt = {}) {\n      const visualBindingOptions = {\n        templateBinding: false,\n        textBinding: true,\n        cssBinding: true,\n        ifBinding: true,\n        showBinding: true,\n        modelBinding: true,\n        attrBinding: true,\n        forOfBinding: true,\n        switchBinding: true\n      };\n      const eventsBindingOptions = {\n        changeBinding: true,\n        clickBinding: true,\n        dblclickBinding: true,\n        blurBinding: true,\n        focusBinding: true,\n        hoverBinding: true,\n        inputBinding: true,\n        submitBinding: true\n      }; // this is visualBindingOptions but everything false\n      // concrete declear for performance purpose\n\n      const serverRenderedOptions = {\n        templateBinding: false,\n        textBinding: false,\n        cssBinding: false,\n        ifBinding: false,\n        showBinding: false,\n        modelBinding: false,\n        attrBinding: false,\n        forOfBinding: false,\n        switchBinding: false\n      };\n      let updateOption = {};\n\n      switch (condition) {\n        case bindingUpdateConditions.serverRendered:\n          updateOption = extend({}, eventsBindingOptions, serverRenderedOptions, opt);\n          break;\n\n        case bindingUpdateConditions.init:\n          // flag templateBinding to true to render tempalte(s)\n          opt.templateBinding = true;\n          updateOption = extend({}, visualBindingOptions, eventsBindingOptions, opt);\n          break;\n\n        default:\n          // when called again only update visualBinding options\n          updateOption = extend({}, visualBindingOptions, opt);\n      }\n\n      return updateOption;\n    }\n\n    /* eslint-disable no-invalid-this */\n    /**\n     * blurBinding\n     * DOM decleartive on blur event binding\n     * event handler bind to viewModel method according to the DOM attribute\n     * @param {object} cache\n     * @param {object} viewModel\n     * @param {object} bindingAttrs\n     * @param {boolean} forceRender\n     */\n\n    const hoverBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n      const handlerName = cache.dataKey;\n      let paramList = cache.parameters;\n      const inHandlerName = bindingDataReference.mouseEnterHandlerName;\n      const outHandlerName = bindingDataReference.mouseLeaveHandlerName;\n      let viewModelContext;\n      const APP = viewModel.APP || viewModel.$root.APP;\n      cache.elementData = cache.elementData || {}; // TODO: check what is APP.$rootElement.contains(cache.el)\n\n      if (!handlerName || !forceRender && !APP.$rootElement.contains(cache.el)) {\n        return;\n      }\n\n      const handlers = getViewModelValue(viewModel, handlerName);\n\n      if (handlers && typeof handlers[inHandlerName] === 'function' && typeof handlers[outHandlerName] === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n\n        function onMouseEnterHandler(e) {\n          const args = [e, cache.el].concat(paramList);\n          handlers[inHandlerName].apply(viewModelContext, args);\n        }\n\n        function onMouseLeaveHandler(e) {\n          const args = [e, cache.el].concat(paramList);\n          handlers[outHandlerName].apply(viewModelContext, args);\n        }\n\n        cache.el.removeEventListener('mouseenter', onMouseEnterHandler, false);\n        cache.el.removeEventListener('mouseleave', onMouseLeaveHandler, false);\n        cache.el.addEventListener('mouseenter', onMouseEnterHandler, false);\n        cache.el.addEventListener('mouseleave', onMouseLeaveHandler, false);\n      }\n    };\n\n    /**\n     * _escape\n     * @description\n     * https://github.com/lodash/lodash/blob/master/escape.js\n     */\n    function baseToString(value) {\n      if (typeof value == 'string') {\n        return value;\n      }\n\n      return value == null ? '' : `${value}`;\n    }\n    /** Used to match HTML entities and HTML characters. */\n\n\n    const reUnescapedHtml = /[&<>\"'`]/g;\n    const reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n    /** Used to map characters to HTML entities. */\n\n    const htmlEscapes = {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      '\\'': '&#39;',\n      '`': '&#96;'\n    };\n    /**\n       * escapeHtmlChar\n       * @description convert characters to HTML entities.\n       * @private\n       * @param {string} chr The matched character to escape.\n       * @return {string} Returns the escaped character.\n       */\n\n    function escapeHtmlChar(chr) {\n      return htmlEscapes[chr];\n    }\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', \"'\", and \"\\`\", in `string` to\n     * their corresponding HTML entities.\n     * @param {string} string\n     * @return {string} string\n     */\n\n\n    function escape(string) {\n      // Reset `lastIndex` because in IE < 9 `String#replace` does not.\n      string = baseToString(string);\n      return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;\n    }\n\n    /* eslint-disable no-invalid-this */\n    /**\n     * changeBinding\n     * @description input element on change event binding. DOM -> viewModel update\n     * @param {object} cache\n     * @param {object} viewModel\n     * @param {object} bindingAttrs\n     * @param {boolean} forceRender\n     */\n\n    const changeBinding = ({\n      cache,\n      viewModel,\n      bindingAttrs,\n      forceRender,\n      type = 'change'\n    }) => {\n      const handlerName = cache.dataKey;\n      let paramList = cache.parameters;\n      const modelDataKey = cache.el.getAttribute(bindingAttrs.model);\n      let newValue = '';\n      let oldValue = '';\n      let viewModelContext;\n      const APP = viewModel.APP || viewModel.$root.APP;\n\n      if (!handlerName || !forceRender && !APP.$rootElement.contains(cache.el)) {\n        return;\n      }\n\n      const handlerFn = getViewModelValue(viewModel, handlerName);\n\n      if (typeof handlerFn === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n\n        function changeHandler(e) {\n          const $this = this;\n          const isCheckbox = $this.type === 'checkbox';\n          newValue = isCheckbox ? $this.checked : escape($this.value); // set data to viewModel\n\n          if (modelDataKey) {\n            oldValue = getViewModelValue(viewModel, modelDataKey);\n            setViewModelValue(viewModel, modelDataKey, newValue);\n          }\n\n          const args = [e, e.currentTarget, newValue, oldValue].concat(paramList);\n          handlerFn.apply(viewModelContext, args);\n          oldValue = newValue;\n        } // assing on change event\n\n\n        cache.el.removeEventListener(type, changeHandler, false);\n        cache.el.addEventListener(type, changeHandler, false);\n      }\n    };\n\n    /**\n     * modelBinding\n     * @description input element data binding. viewModel -> DOM update\n     * @param {object} cache\n     * @param {object} viewModel\n     * @param {object} bindingAttrs\n     * @param {boolean} forceRender\n     */\n\n    const modelBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n      const dataKey = cache.dataKey;\n      let newValue = '';\n      const APP = viewModel.APP || viewModel.$root.APP;\n\n      if (!dataKey || !forceRender && !APP.$rootElement.contains(cache.el)) {\n        return;\n      }\n\n      newValue = getViewModelValue(viewModel, dataKey);\n\n      if (typeof newValue !== 'undefined' && newValue !== null) {\n        const $element = cache.el;\n        const isCheckbox = $element.type === 'checkbox';\n        const isRadio = $element.type === 'radio';\n        const inputName = $element.name;\n        const $radioGroup = isRadio ? APP.$rootElement.querySelectorAll(`input[name=\"${inputName}\"]`) : [];\n        const oldValue = isCheckbox ? $element.checked : $element.value; // update element value\n\n        if (newValue !== oldValue) {\n          if (isCheckbox) {\n            $element.checked = Boolean(newValue);\n          } else if (isRadio) {\n            let i = 0;\n            const radioGroupLength = $radioGroup.length;\n\n            for (i = 0; i < radioGroupLength; i += 1) {\n              if ($radioGroup[i].value === newValue) {\n                $radioGroup[i].checked = true;\n                break;\n              }\n            }\n          } else {\n            $element.value = newValue;\n          }\n        }\n      }\n    };\n\n    /**\n     * textBinding\n     * * @description\n     * DOM decleartive text binding update dom textnode with viewModel data\n     * @param {object} cache\n     * @param {object} viewModel\n     * @param {object} bindingAttrs\n     * @param {boolean} forceRender\n     */\n\n    const textBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n      const dataKey = cache.dataKey;\n      const APP = viewModel.APP || viewModel.$root.APP; // NOTE: this doesn't work for for-of, if and switch bindings because element was not in DOM\n\n      if (!dataKey || !forceRender && !APP.$rootElement.contains(cache.el)) {\n        return;\n      }\n\n      const newValue = getViewModelPropValue(viewModel, cache);\n      const oldValue = cache.el.textContent;\n\n      if (typeof newValue !== 'undefined' && typeof newValue !== 'object' && newValue !== null) {\n        if (newValue !== oldValue) {\n          cache.el.textContent = newValue;\n        }\n      }\n    };\n\n    /**\n     * showBinding\n     * @description\n     * DOM decleartive show binding. Make binding show/hide according to viewModel data (boolean)\n     * viewModel data can function but must return boolean\n     * @param {object} cache\n     * @param {object} viewModel\n     * @param {object} bindingAttrs\n     */\n\n    const showBinding = (cache, viewModel, bindingAttrs) => {\n      const dataKey = cache.dataKey;\n      let currentInlineSytle = {};\n      let currentInlineDisplaySytle = '';\n      let shouldShow = true;\n\n      if (!dataKey) {\n        return;\n      }\n\n      cache.elementData = cache.elementData || {};\n      const oldShowStatus = cache.elementData.viewModelPropValue; // store current element display default style once only\n\n      if (typeof cache.elementData.displayStyle === 'undefined' || typeof cache.elementData.computedStyle === 'undefined') {\n        currentInlineSytle = cache.el.style;\n        currentInlineDisplaySytle = currentInlineSytle.display; // use current inline style if defined\n\n        if (currentInlineDisplaySytle) {\n          // set to 'block' if is 'none'\n          cache.elementData.displayStyle = currentInlineDisplaySytle === 'none' ? 'block' : currentInlineDisplaySytle;\n          cache.elementData.computedStyle = null;\n        } else {\n          const computeStyle = window.getComputedStyle(cache.el, null).getPropertyValue('display');\n          cache.elementData.displayStyle = null;\n          cache.elementData.computedStyle = computeStyle;\n        }\n      }\n\n      shouldShow = getViewModelPropValue(viewModel, cache); // treat undefined || null as false.\n      // eg if property doesn't exsits in viewModel, it will treat as false to hide element\n\n      shouldShow = Boolean(shouldShow); // reject if nothing changed\n\n      if (oldShowStatus === shouldShow) {\n        return;\n      }\n\n      if (!shouldShow) {\n        if (cache.el.style.display !== 'none') {\n          cache.el.style.setProperty('display', 'none');\n        }\n      } else {\n        if (cache.elementData.computedStyle || cache.el.style.display === 'none') {\n          if (cache.elementData.computedStyle === 'none') {\n            // default display is none in css rule, so use display 'block'\n            cache.el.style.setProperty('display', 'block');\n          } else {\n            // has default displayable type so just remove inline display 'none'\n            if (currentInlineSytle.length > 1) {\n              cache.el.style.removeProperty('display');\n            } else {\n              cache.el.removeAttribute('style');\n            }\n          }\n        } else {\n          // element default display was inline style, so restore it\n          cache.el.style.setProperty('display', cache.elementData.displayStyle);\n        }\n      } // store new show status\n\n\n      cache.elementData.viewModelPropValue = shouldShow;\n    };\n\n    /**\n     * cssBinding\n     * @description\n     * DOM decleartive css binding. update classlist.\n     * viewModel data can function but must return JSOL.\n     * added css class if value is true\n     * @param {object} cache\n     * @param {object} viewModel\n     * @param {object} bindingAttrs\n     * @param {boolean} forceRender\n     */\n\n    const cssBinding = (cache, viewModel, bindingAttrs, forceRender) => {\n      const dataKey = cache.dataKey;\n      const APP = viewModel.APP || viewModel.$root.APP;\n\n      if (!dataKey || !forceRender && !APP.$rootElement.contains(cache.el)) {\n        return;\n      }\n\n      cache.elementData = cache.elementData || {};\n      cache.elementData.viewModelPropValue = cache.elementData.viewModelPropValue || '';\n      const oldCssList = cache.elementData.viewModelPropValue;\n      let newCssList = '';\n      const vmCssListObj = getViewModelPropValue(viewModel, cache);\n      let vmCssListArray = [];\n      let isViewDataObject = false;\n      let isViewDataString = false;\n      let cssList = [];\n\n      if (typeof vmCssListObj === 'string') {\n        isViewDataString = true;\n      } else if (isPlainObject(vmCssListObj)) {\n        isViewDataObject = true;\n      } else {\n        // reject if vmCssListObj is not an object or string\n        return;\n      }\n\n      if (isViewDataObject) {\n        newCssList = JSON.stringify(vmCssListObj);\n      } else {\n        newCssList = vmCssListObj.replace(/\\s\\s+/g, ' ').trim();\n        vmCssListArray = newCssList.split(' ');\n      } // reject if nothing changed\n\n\n      if (oldCssList === newCssList) {\n        return;\n      } // get current css classes from element\n\n\n      const domCssList = cache.el.classList; // clone domCssList as new array\n\n      const domCssListLength = domCssList.length;\n\n      for (let i = 0; i < domCssListLength; i += 1) {\n        cssList.push(domCssList[i]);\n      }\n\n      if (isViewDataObject) {\n        each(vmCssListObj, function (k, v) {\n          const i = cssList.indexOf(k);\n\n          if (v === true) {\n            cssList.push(k);\n          } else if (i !== -1) {\n            cssList.splice(i, 1);\n          }\n        });\n      } else if (isViewDataString) {\n        // remove oldCssList items from cssList\n        cssList = arrayRemoveMatch(cssList, oldCssList);\n        cssList = cssList.concat(vmCssListArray);\n      } // unique cssList array\n\n\n      cssList = cssList.filter((v, i, a) => {\n        return a.indexOf(v) === i;\n      });\n      cssList = cssList.join(' '); // update element data\n\n      cache.elementData.viewModelPropValue = newCssList; // replace all css classes\n\n      cache.el.setAttribute('class', cssList);\n    };\n\n    /**\n     * attrBinding\n     * @description\n     * DOM decleartive attr binding. update elenment attributes\n     * @param {object} cache\n     * @param {object} viewModel\n     * @param {object} bindingAttrs\n     */\n\n    const attrBinding = (cache = {}, viewModel) => {\n      if (!cache.dataKey) {\n        return;\n      } // check if Object Literal String style dataKey\n\n\n      const isObjLiteralStr = isObjectLiteralString(cache.dataKey); // resolve vmAttrObj, when Object Literal String style if will be object without resolve each value\n      // otherwise, resolve value from viewModel\n\n      const vmAttrObj = isObjLiteralStr ? parseBindingObjectString(cache.dataKey) : getViewModelPropValue(viewModel, cache); // vmAttrObj must be a plain object\n\n      if (!isPlainObject(vmAttrObj)) {\n        return;\n      } // populate cache.elementData if not exits\n      // check and set default cache.elementData.viewModelPropValue\n\n\n      cache.elementData = cache.elementData || {};\n      cache.elementData.viewModelPropValue = cache.elementData.viewModelPropValue || {}; // start diff comparison\n      // reject if nothing changed by comparing\n      // cache.elementData.viewModelPropValue (previous render) vs vmAttrObj(current render)\n\n      if (JSON.stringify(cache.elementData.viewModelPropValue) === JSON.stringify(vmAttrObj)) {\n        return;\n      }\n\n      if (isObjLiteralStr) {\n        // resolve each value in vmAttrObj\n        each(vmAttrObj, (key, value) => {\n          // resolve value from viewModel including $data and $root\n          // from viewModel.$data or viewModel.$root\n          vmAttrObj[key] = getViewModelPropValue(viewModel, {\n            dataKey: value\n          });\n        });\n      } // shortcut for reading cache.elementData.viewModelPropValue\n\n\n      const oldAttrObj = cache.elementData.viewModelPropValue; // start set element attribute - oldAttrObj is empty meaning no previous render\n\n      if (isEmptyObject(oldAttrObj)) {\n        each(vmAttrObj, (key, value) => {\n          if (typeof value !== 'undefined') {\n            cache.el.setAttribute(key, value); // populate cache.elementData.viewModelPropValue for future comparison\n\n            if (!isObjLiteralStr) {\n              cache.elementData.viewModelPropValue[key] = value;\n            }\n          }\n        });\n      } else {\n        // loop oldAttrObj, remove attribute not present in current vmAttrObj\n        each(oldAttrObj, (key, value) => {\n          if (typeof vmAttrObj[key] === 'undefined') {\n            cache.el.removeAttribute(key);\n          }\n        }); // loop vmAttrObj, set attribute not present in oldAttrObj\n\n        each(vmAttrObj, (key, value) => {\n          if (typeof value !== 'undefined') {\n            if (oldAttrObj[key] !== vmAttrObj[key]) {\n              cache.el.setAttribute(key, vmAttrObj[key]); // populate cache.elementData.viewModelPropValue for future comparison\n\n              if (!isObjLiteralStr) {\n                cache.elementData.viewModelPropValue[key] = value;\n              }\n            }\n          }\n        });\n      } // for object literal style binding\n      // set viewModelPropValue for future diff comaprison\n      // note: vmAttrObj is a not fully resolve object, each value is still string unresloved\n\n\n      if (isObjLiteralStr) {\n        cache.elementData.viewModelPropValue = extend({}, vmAttrObj);\n      }\n    };\n\n    let $domFragment = null;\n    let $templateRoot = null;\n    let nestTemplatesCount = 0;\n    /**\n     * getTemplateString\n     * @description get Template tag innerHTML string\n     * @param {string} id\n     * @return {string} rendered html string\n     */\n\n    const getTemplateString = id => {\n      const templateElement = document.getElementById(id);\n      return templateElement ? templateElement.innerHTML : '';\n    };\n    /**\n     * renderTemplate\n     * @description\n     * get template setting from DOM attribute then call compileTemplate\n     * to render and append to target DOM\n     * @param {object} cache\n     * @param {object} viewModel\n     * @param {object} bindingAttrs\n     * @param {object} elementCache\n     */\n\n\n    const renderTemplate = (cache, viewModel, bindingAttrs, elementCache) => {\n      const settings = typeof cache.dataKey === 'string' ? parseStringToJson(cache.dataKey) : cache.dataKey;\n      let viewData = settings.data;\n      const isAppend = settings.append;\n      const isPrepend = settings.prepend;\n      let $currentElement;\n      cache.dataKey = settings;\n      viewData = typeof viewData === 'undefined' || viewData === '$root' ? viewModel : getViewModelPropValue(viewModel, {\n        dataKey: settings.data,\n        parameters: cache.parameters\n      });\n\n      if (!viewData) {\n        return;\n      }\n\n      const $element = cache.el;\n      const $index = typeof viewModel.$index !== 'undefined' ? viewModel.$index : $element.getAttribute(dataIndexAttr);\n\n      if (typeof $index !== 'undefined') {\n        viewData.$index = $index;\n      }\n\n      $domFragment = $domFragment || document.createDocumentFragment();\n      $templateRoot = $templateRoot || $element;\n      const htmlString = getTemplateString(settings.id);\n      const htmlFragment = createHtmlFragment(htmlString); // append rendered html\n\n      if (!$domFragment.childNodes.length) {\n        // domFragment should be empty in first run\n        $currentElement = $domFragment; // copy of $domFragment for later find nested template check\n\n        $domFragment.appendChild(htmlFragment);\n      } else {\n        // during recursive run keep append to current fragment\n        $currentElement = $element; // reset to current nested template element\n\n        if (!isAppend && !isPrepend) {\n          $currentElement = emptyElement($currentElement);\n        }\n\n        if (isPrepend) {\n          $currentElement.insertBefore(htmlFragment, $currentElement.firstChild);\n        } else {\n          $currentElement.appendChild(htmlFragment);\n        }\n      } // check if there are nested template then recurisive render them\n\n\n      const $nestedTemplates = $currentElement.querySelectorAll('[' + bindingAttrs.tmp + ']');\n      const nestedTemplatesLength = $nestedTemplates.length;\n\n      if (nestedTemplatesLength) {\n        nestTemplatesCount += nestedTemplatesLength;\n\n        for (let i = 0; i < nestedTemplatesLength; i += 1) {\n          const thisTemplateCache = {\n            el: $nestedTemplates[i],\n            dataKey: $nestedTemplates[i].getAttribute(bindingAttrs.tmp)\n          };\n          elementCache[bindingAttrs.tmp].push(thisTemplateCache); // recursive template render\n\n          renderTemplate(thisTemplateCache, viewModel, bindingAttrs, elementCache);\n          nestTemplatesCount -= 1;\n        }\n      } // no more nested tempalted to render, start to append $domFragment into $templateRoot\n\n\n      if (nestTemplatesCount === 0) {\n        // append to DOM once\n        if (!isAppend && !isPrepend) {\n          $templateRoot = emptyElement($templateRoot);\n        }\n\n        if (isPrepend) {\n          $templateRoot.insertBefore($domFragment, $templateRoot.firstChild);\n        } else {\n          $templateRoot.appendChild($domFragment);\n        } // clear cached fragment\n\n\n        $domFragment = $templateRoot = null; // trigger callback if provided\n\n        if (typeof viewModel.afterTemplateRender === 'function') {\n          viewModel.afterTemplateRender(viewData);\n        }\n      }\n    };\n\n    const renderTemplatesBinding = ({\n      ctx,\n      elementCache,\n      updateOption,\n      bindingAttrs,\n      viewModel\n    }) => {\n      if (!elementCache || !bindingAttrs) {\n        return false;\n      } // render and apply binding to template(s) and forOf DOM\n\n\n      if (elementCache[bindingAttrs.tmp] && elementCache[bindingAttrs.tmp].length) {\n        // when re-render call with {templateBinding: true}\n        // template and nested templates\n        if (updateOption.templateBinding) {\n          // overwrite updateOption with 'init' bindingUpdateConditions\n          updateOption = createBindingOption(bindingUpdateConditions.init);\n          elementCache[bindingAttrs.tmp].forEach($element => {\n            renderTemplate($element, viewModel, bindingAttrs, elementCache);\n          }); // update cache after all template(s) rendered\n\n          ctx.updateElementCache({\n            templateCache: true,\n            elementCache: elementCache,\n            isRenderedTemplates: true\n          });\n        } // enforce render even element is not in DOM tree\n\n\n        updateOption.forceRender = true; // apply bindings to rendered templates element\n\n        elementCache[bindingAttrs.tmp].forEach(cache => {\n          applyBinding({\n            elementCache: cache.bindingCache,\n            updateOption: updateOption,\n            bindingAttrs: bindingAttrs,\n            viewModel: viewModel\n          });\n        });\n      }\n\n      return true;\n    };\n\n    /**\n     * renderIteration\n     * @param {object} opt\n     * @description\n     * render element's binding by supplied elementCache\n     * This function is desidned for FoOf, If, switch bindings\n     */\n\n    const renderIteration = ({\n      elementCache,\n      iterationVm,\n      bindingAttrs,\n      isRegenerate\n    }) => {\n      const bindingUpdateOption = isRegenerate ? createBindingOption(bindingUpdateConditions.init) : createBindingOption(); // enforce render even element is not in DOM tree\n\n      bindingUpdateOption.forceRender = true; // render and apply binding to template(s)\n      // this is an share function therefore passing current APP 'this' context\n      // viewModel is a dynamic generated iterationVm\n\n      renderTemplatesBinding({\n        ctx: iterationVm.$root ? iterationVm.$root.APP : iterationVm.APP,\n        elementCache: elementCache,\n        updateOption: bindingUpdateOption,\n        bindingAttrs: bindingAttrs,\n        viewModel: iterationVm\n      });\n      applyBinding({\n        elementCache: elementCache,\n        updateOption: bindingUpdateOption,\n        bindingAttrs: bindingAttrs,\n        viewModel: iterationVm\n      });\n    };\n\n    /* eslint-disable no-invalid-this */\n\n    const createClonedElementCache = bindingData => {\n      const clonedElement = bindingData.el.cloneNode(true);\n      bindingData.fragment = document.createDocumentFragment();\n      bindingData.fragment.appendChild(clonedElement);\n      return bindingData;\n    };\n\n    const setCommentPrefix = bindingData => {\n      if (!bindingData || !bindingData.type) {\n        return bindingData;\n      }\n\n      let commentPrefix$1 = '';\n      const dataKeyMarker = bindingData.dataKey ? bindingData.dataKey.replace(REGEX.WHITE_SPACES, '_') : '';\n\n      switch (bindingData.type) {\n        case bindingAttrs$1.forOf:\n          commentPrefix$1 = commentPrefix.forOf;\n          break;\n\n        case bindingAttrs$1.if:\n          commentPrefix$1 = commentPrefix.if;\n          break;\n\n        case bindingAttrs$1.case:\n          commentPrefix$1 = commentPrefix.case;\n          break;\n\n        case bindingAttrs$1.default:\n          commentPrefix$1 = commentPrefix.default;\n          break;\n      }\n\n      bindingData.commentPrefix = commentPrefix$1 + dataKeyMarker;\n      return bindingData;\n    };\n    /**\n     * setDocRangeEndAfter\n     * @param {object} node\n     * @param {object} bindingData\n     * @description\n     * recursive execution to find last wrapping comment node\n     * and set as bindingData.docRange.setEndAfter\n     * if not found deleteContents will has no operation\n     * @return {undefined}\n     */\n\n\n    const setDocRangeEndAfter = (node, bindingData) => {\n      if (!bindingData.commentPrefix) {\n        setCommentPrefix(bindingData);\n      }\n\n      const startTextContent = bindingData.commentPrefix;\n      const endTextContent = startTextContent + commentSuffix;\n      node = node.nextSibling; // check last wrap comment node\n\n      if (node) {\n        if (node.nodeType === 8 && node.textContent === endTextContent) {\n          return bindingData.docRange.setEndBefore(node);\n        }\n\n        setDocRangeEndAfter(node, bindingData);\n      }\n    };\n    /**\n     * wrapCommentAround\n     * @param {object} bindingData\n     * @param {Node} node\n     * @return {object} DOM fragment\n     * @description\n     * wrap frament with comment node\n     */\n\n\n    const wrapCommentAround = (bindingData, node) => {\n      let prefix = '';\n\n      if (!bindingData.commentPrefix) {\n        setCommentPrefix(bindingData);\n      }\n\n      prefix = bindingData.commentPrefix;\n      const commentBegin = document.createComment(prefix);\n      const commentEnd = document.createComment(prefix + commentSuffix); // document fragment - logic for ForOf binding\n      // check node.parentNode because node could be from cache and no longer in DOM\n\n      if (node.nodeType === 11) {\n        node.insertBefore(commentBegin, node.firstChild);\n        node.appendChild(commentEnd);\n      } else if (node.parentNode) {\n        node.parentNode.insertBefore(commentBegin, node);\n        insertAfter(node.parentNode, commentEnd, node); // update bindingData details\n\n        bindingData.previousNonTemplateElement = node.previousSibling;\n        bindingData.nextNonTemplateElement = node.nextSibling;\n        bindingData.parentElement = node.previousSibling.parentElement;\n      }\n\n      return node;\n    };\n    /**\n     * removeElemnetsByCommentWrap\n     * @param {object} bindingData\n     * @return {undefined}\n     * @description remove elments by range\n     */\n\n\n    const removeElemnetsByCommentWrap = bindingData => {\n      if (!bindingData.docRange) {\n        bindingData.docRange = document.createRange();\n      }\n\n      try {\n        if (bindingData.previousNonTemplateElement) {\n          // update docRange start and end match the wrapped comment node\n          bindingData.docRange.setStartBefore(bindingData.previousNonTemplateElement.nextSibling);\n          setDocRangeEndAfter(bindingData.previousNonTemplateElement.nextSibling, bindingData);\n        } else {\n          // insert before next non template element\n          bindingData.docRange.setStartBefore(bindingData.parentElement.firstChild);\n          setDocRangeEndAfter(bindingData.parentElement.firstChild, bindingData);\n        }\n      } catch (err) {\n        console.log('error removeElemnetsByCommentWrap: ', err.message);\n      }\n\n      return bindingData.docRange.deleteContents();\n    };\n\n    const insertRenderedElements = (bindingData, fragment) => {\n      // insert rendered fragment after the previousNonTemplateElement\n      if (bindingData.previousNonTemplateElement) {\n        insertAfter(bindingData.parentElement, fragment, bindingData.previousNonTemplateElement);\n      } else {\n        // insert before next non template element\n        if (bindingData.nextNonTemplateElement) {\n          bindingData.parentElement.insertBefore(fragment, bindingData.nextNonTemplateElement);\n        } else if (bindingData.parentElement) {\n          // insert from parent\n          bindingData.parentElement.appendChild(fragment);\n        }\n      }\n    };\n\n    /* eslint-disable no-invalid-this */\n\n    const renderForOfBinding = ({\n      bindingData,\n      viewModel,\n      bindingAttrs\n    }) => {\n      if (!bindingData || !viewModel || !bindingAttrs) {\n        return;\n      }\n\n      let keys;\n      let iterationDataLength;\n      const iterationData = getViewModelPropValue(viewModel, bindingData.iterator);\n      let isRegenerate = false; // check iterationData and set iterationDataLength\n\n      if (isArray(iterationData)) {\n        iterationDataLength = iterationData.length;\n      } else if (isPlainObject(iterationData)) {\n        keys = Object.keys(iterationData);\n        iterationDataLength = keys.length;\n      } else {\n        // throw error but let script contince to run\n        return throwErrorMessage(null, 'iterationData is not an plain object or array');\n      } // flag as pared for-of logic with bindingData.type\n\n\n      if (!bindingData.type) {\n        bindingData.type = bindingAttrs$1.forOf;\n        wrapCommentAround(bindingData, bindingData.el);\n      } // assign forOf internal id to bindingData once\n\n\n      if (typeof bindingData.iterationSize === 'undefined') {\n        // store iterationDataLength\n        bindingData.iterationSize = iterationDataLength; // remove orignal node for-of attributes\n\n        bindingData.el.removeAttribute(bindingAttrs.forOf);\n        isRegenerate = true;\n      } else {\n        // only regenerate cache if iterationDataLength changed\n        isRegenerate = bindingData.iterationSize !== iterationDataLength; // update iterationSize\n\n        bindingData.iterationSize = iterationDataLength;\n      }\n\n      if (!isRegenerate) {\n        bindingData.iterationBindingCache.forEach(function (elementCache, i) {\n          if (!isEmptyObject(elementCache)) {\n            const iterationVm = createIterationViewModel({\n              bindingData: bindingData,\n              viewModel: viewModel,\n              iterationData: iterationData,\n              keys: keys,\n              index: i\n            });\n            renderIteration({\n              elementCache: elementCache,\n              iterationVm: iterationVm,\n              bindingAttrs: bindingAttrs,\n              isRegenerate: false\n            });\n          }\n        });\n        return;\n      } // generate forOfBinding elements into fragment\n\n\n      const fragment = generateForOfElements(bindingData, viewModel, bindingAttrs, iterationData, keys);\n      removeElemnetsByCommentWrap(bindingData); // insert fragment content into DOM\n\n      return insertRenderedElements(bindingData, fragment);\n    };\n    /**\n     * createIterationViewModel\n     * @description\n     * create an virtual viewModel for render binding while in loop iteration\n     * $data is the current data in the loop eg. data in array\n     * $root is point to top level viewModel\n     * $index is the current loop index\n     * @param {*} param0\n     * @return {object} virtual viewModel\n     */\n\n\n    const createIterationViewModel = ({\n      bindingData,\n      viewModel,\n      iterationData,\n      keys,\n      index\n    }) => {\n      const iterationVm = {};\n      iterationVm[bindingData.iterator.alias] = keys ? iterationData[keys[index]] : iterationData[index]; // populate common binding data reference\n\n      iterationVm[bindingDataReference.rootDataKey] = viewModel.$root || viewModel;\n      iterationVm[bindingDataReference.currentData] = iterationVm[bindingData.iterator.alias];\n      iterationVm[bindingDataReference.currentIndex] = index;\n      return iterationVm;\n    };\n\n    const generateForOfElements = (bindingData, viewModel, bindingAttrs, iterationData, keys) => {\n      const fragment = document.createDocumentFragment();\n      const iterationDataLength = bindingData.iterationSize;\n      let clonedItem;\n      let iterationVm;\n      let iterationBindingCache;\n      let i = 0; // create or clear exisitng iterationBindingCache\n\n      if (isArray(bindingData.iterationBindingCache)) {\n        bindingData.iterationBindingCache.length = 0;\n      } else {\n        bindingData.iterationBindingCache = [];\n      } // generate forOf and append to DOM\n\n\n      for (i = 0; i < iterationDataLength; i += 1) {\n        clonedItem = cloneDomNode(bindingData.el); // create bindingCache per iteration\n\n        iterationBindingCache = createBindingCache({\n          rootNode: clonedItem,\n          bindingAttrs: bindingAttrs\n        });\n        bindingData.iterationBindingCache.push(iterationBindingCache);\n\n        if (!isEmptyObject(iterationBindingCache)) {\n          // create an iterationVm match iterator alias\n          iterationVm = createIterationViewModel({\n            bindingData: bindingData,\n            viewModel: viewModel,\n            iterationData: iterationData,\n            keys: keys,\n            index: i\n          });\n          renderIteration({\n            elementCache: bindingData.iterationBindingCache[i],\n            iterationVm: iterationVm,\n            bindingAttrs: bindingAttrs,\n            isRegenerate: true\n          });\n        }\n\n        fragment.appendChild(clonedItem);\n      }\n\n      return fragment;\n    };\n\n    /**\n     * forOfBinding\n     * @description\n     * DOM decleartive for binding.\n     * @param {object} cache\n     * @param {object} viewModel\n     * @param {object} bindingAttrs\n     */\n\n    const forOfBinding = (cache, viewModel, bindingAttrs) => {\n      const dataKey = cache.dataKey;\n\n      if (!dataKey || dataKey.length > maxDatakeyLength) {\n        return;\n      }\n\n      if (!cache.iterator) {\n        if (dataKey.length > maxDatakeyLength) {\n          return;\n        } // replace mess spaces with single space\n\n\n        cache.dataKey = cache.dataKey.replace(REGEX.WHITE_SPACES, ' ');\n        const forExpMatch = dataKey.match(REGEX.FOR_OF);\n\n        if (!forExpMatch) {\n          return;\n        }\n\n        cache.iterator = {};\n        cache.iterator.alias = forExpMatch[1].trim();\n\n        if (forExpMatch[2]) {\n          cache.iterator.dataKey = forExpMatch[2].trim();\n          cache.parentElement = cache.el.parentElement;\n          cache.previousNonTemplateElement = cache.el.previousSibling;\n          cache.nextNonTemplateElement = cache.el.nextSibling;\n        }\n      }\n\n      renderForOfBinding({\n        bindingData: cache,\n        viewModel: viewModel,\n        bindingAttrs: bindingAttrs\n      });\n    };\n\n    /**\n     * isTargetDomRemoved\n     * @description check if DOM between 'start' and 'end' comment tag has been removed\n     * @param {object} bindingData\n     * @return {boolean}\n     */\n\n    const isTargetDomRemoved = bindingData => {\n      let ret = false;\n\n      if (bindingData && bindingData.previousNonTemplateElement) {\n        const commentStartTextContent = bindingData.previousNonTemplateElement.textContent;\n        const endCommentTag = bindingData.previousNonTemplateElement.nextSibling;\n\n        if (endCommentTag.nodeType === 8) {\n          if (endCommentTag.textContent === commentStartTextContent + commentSuffix) {\n            ret = true;\n          }\n        }\n      }\n\n      return ret;\n    };\n\n    const renderIfBinding = ({\n      bindingData,\n      viewModel,\n      bindingAttrs\n    }) => {\n      if (!bindingData.fragment) {\n        return;\n      }\n\n      const isDomRemoved = isTargetDomRemoved(bindingData);\n      let rootElement = bindingData.el; // remove current old DOM.\n      // TODO: try preserve DOM\n\n      if (!isDomRemoved && !bindingData.isOnce) {\n        removeIfBinding(bindingData); // use fragment for create iterationBindingCache\n\n        rootElement = bindingData.fragment.firstChild.cloneNode(true);\n      } // walk clonedElement to create iterationBindingCache once\n\n\n      if (!bindingData.iterationBindingCache || !bindingData.hasIterationBindingCache) {\n        bindingData.iterationBindingCache = createBindingCache({\n          rootNode: rootElement,\n          bindingAttrs: bindingAttrs\n        });\n      } // only render if has iterationBindingCache\n      // means has other dataBindings to be render\n\n\n      if (!isEmptyObject(bindingData.iterationBindingCache)) {\n        bindingData.hasIterationBindingCache = true;\n        renderIteration({\n          elementCache: bindingData.iterationBindingCache,\n          iterationVm: viewModel,\n          bindingAttrs: bindingAttrs,\n          isRegenerate: true\n        });\n      } // insert to new rendered DOM\n      // TODO: check unnecessary insertion when DOM is preserved\n\n\n      insertRenderedElements(bindingData, rootElement);\n    };\n\n    const removeIfBinding = bindingData => {\n      removeElemnetsByCommentWrap(bindingData); // remove cache.IterationBindingCache to prevent memory leak\n\n      if (bindingData.hasIterationBindingCache) {\n        delete bindingData.iterationBindingCache;\n        delete bindingData.hasIterationBindingCache;\n      }\n    };\n\n    /**\n     * if-Binding\n     * @description\n     * DOM decleartive for binding.\n     * @param {object} cache\n     * @param {object} viewModel\n     * @param {object} bindingAttrs\n     */\n\n    const ifBinding = (cache, viewModel, bindingAttrs) => {\n      const dataKey = cache.dataKey; // isOnce only return if there is no child bindings\n\n      if (!dataKey || cache.isOnce && cache.hasIterationBindingCache === false) {\n        return;\n      }\n\n      cache.elementData = cache.elementData || {};\n      cache.type = cache.type || bindingAttrs$1.if;\n      const oldViewModelProValue = cache.elementData.viewModelPropValue; // getViewModelPropValue could be return undefined or null\n\n      const viewModelPropValue = getViewModelPropValue(viewModel, cache) || false; // do nothing if viewModel value not changed and no child bindings\n\n      if (oldViewModelProValue === viewModelPropValue && !cache.hasIterationBindingCache) {\n        return;\n      }\n\n      const shouldRender = Boolean(viewModelPropValue); // remove this cache from parent array\n\n      if (!shouldRender && cache.isOnce && cache.el.parentNode) {\n        removeElement(cache.el); // delete cache.fragment;\n\n        removeBindingInQueue({\n          viewModel: viewModel,\n          cache: cache\n        });\n        return;\n      } // store new show status\n\n\n      cache.elementData.viewModelPropValue = viewModelPropValue; // only create fragment once\n      // wrap comment tag around\n      // remove if attribute from original element to allow later dataBind parsing\n\n      if (!cache.fragment) {\n        wrapCommentAround(cache, cache.el);\n        cache.el.removeAttribute(bindingAttrs.if);\n        createClonedElementCache(cache);\n      }\n\n      if (!shouldRender) {\n        // remove element\n        removeIfBinding(cache);\n      } else {\n        // render element\n        renderIfBinding({\n          bindingData: cache,\n          viewModel: viewModel,\n          bindingAttrs: bindingAttrs\n        }); // if render once\n        // remove this cache from parent array if no child caches\n\n        if (cache.isOnce && !cache.hasIterationBindingCache) {\n          // delete cache.fragment;\n          removeBindingInQueue({\n            viewModel: viewModel,\n            cache: cache\n          });\n        }\n      }\n    };\n\n    const removeBindingInQueue = ({\n      viewModel,\n      cache\n    }) => {\n      let ret = false;\n\n      if (viewModel.APP.postProcessQueue) {\n        viewModel.APP.postProcessQueue.push(((cache, index) => () => {\n          cache[constants.PARENT_REF].splice(index, 1);\n        })(cache, cache[constants.PARENT_REF].indexOf(cache)));\n        ret = true;\n      }\n\n      return ret;\n    };\n\n    /**\n     * switch-Binding\n     * @description\n     * DOM decleartive switch binding.\n     * switch parent element wrap direct child with case bindings\n     * @param {object} cache\n     * @param {object} viewModel\n     * @param {object} bindingAttrs\n     */\n\n    const switchBinding = (cache, viewModel, bindingAttrs) => {\n      const dataKey = cache.dataKey;\n\n      if (!dataKey) {\n        return;\n      }\n\n      cache.elementData = cache.elementData || {};\n      const newExpression = getViewModelPropValue(viewModel, cache);\n\n      if (newExpression === cache.elementData.viewModelPropValue) {\n        return;\n      }\n\n      cache.elementData.viewModelPropValue = newExpression; // build switch cases if not yet defined\n\n      if (!cache.cases) {\n        const childrenElements = cache.el.children;\n\n        if (!childrenElements.length) {\n          return;\n        }\n\n        cache.cases = [];\n\n        for (let i = 0, elementLength = childrenElements.length; i < elementLength; i += 1) {\n          let caseData = null;\n\n          if (childrenElements[i].hasAttribute(bindingAttrs.case)) {\n            caseData = createCaseData(childrenElements[i], bindingAttrs.case);\n          } else if (childrenElements[i].hasAttribute(bindingAttrs.default)) {\n            caseData = createCaseData(childrenElements[i], bindingAttrs.default);\n            caseData.isDefault = true;\n          } // create fragment by clone node\n          // wrap with comment tag\n\n\n          if (caseData) {\n            wrapCommentAround(caseData, caseData.el); // remove binding attribute for later dataBind parse\n\n            if (caseData.isDefault) {\n              caseData.el.removeAttribute(bindingAttrs.default);\n            } else {\n              caseData.el.removeAttribute(bindingAttrs.case);\n            }\n\n            createClonedElementCache(caseData);\n            cache.cases.push(caseData);\n          }\n        }\n      }\n\n      if (cache.cases.length) {\n        let hasMatch = false; // do switch operation - reuse if binding logic\n\n        for (let j = 0, casesLength = cache.cases.length; j < casesLength; j += 1) {\n          let newCaseValue;\n\n          if (cache.cases[j].dataKey) {\n            // set back to dataKey if nothing found in viewModel\n            newCaseValue = getViewModelPropValue(viewModel, cache.cases[j]) || cache.cases[j].dataKey;\n          }\n\n          if (newCaseValue === cache.elementData.viewModelPropValue || cache.cases[j].isDefault) {\n            hasMatch = true; // render element\n\n            renderIfBinding({\n              bindingData: cache.cases[j],\n              viewModel: viewModel,\n              bindingAttrs: bindingAttrs\n            }); // remove other elements\n\n            removeUnmatchCases(cache.cases, j);\n            break;\n          }\n        } // no match remove all cases\n\n\n        if (!hasMatch) {\n          removeUnmatchCases(cache.cases);\n        }\n      }\n    };\n\n    function removeUnmatchCases(cases, matchedIndex) {\n      cases.forEach((caseData, index) => {\n        if (index !== matchedIndex || typeof matchedIndex === 'undefined') {\n          removeIfBinding(caseData); // remove cache.IterationBindingCache to prevent memory leak\n\n          if (caseData.hasIterationBindingCache) {\n            caseData.iterationBindingCache = null;\n            caseData.hasIterationBindingCache = false;\n          }\n        }\n      });\n    }\n\n    function createCaseData(node, attrName) {\n      const caseData = {\n        el: node,\n        dataKey: node.getAttribute(attrName),\n        type: attrName\n      };\n      return caseData;\n    }\n\n    const createEventBinding = ({\n      cache = {},\n      forceRender = false,\n      type = '',\n      viewModel = {}\n    }) => {\n      const handlerName = cache.dataKey;\n      let paramList = cache.parameters;\n      let viewModelContext;\n      const APP = viewModel.APP || viewModel.$root.APP;\n\n      if (!type || !handlerName || !forceRender && !APP.$rootElement.contains(cache.el)) {\n        return;\n      }\n\n      const handlerFn = getViewModelValue(viewModel, handlerName);\n\n      if (typeof handlerFn === 'function') {\n        viewModelContext = resolveViewModelContext(viewModel, handlerName);\n        paramList = paramList ? resolveParamList(viewModel, paramList) : [];\n\n        const handlerWrap = e => {\n          let formData;\n          let args = [];\n\n          if (type === 'submit') {\n            formData = getFormData(e.currentTarget);\n            args = [e, e.currentTarget, formData].concat(paramList);\n          } else {\n            args = [e, e.currentTarget].concat(paramList);\n          }\n\n          handlerFn.apply(viewModelContext, args);\n        };\n\n        cache.el.removeEventListener(type, handlerWrap, false);\n        cache.el.addEventListener(type, handlerWrap, false);\n      }\n    };\n\n    function applyBinding({\n      ctx,\n      elementCache,\n      updateOption,\n      bindingAttrs,\n      viewModel\n    }) {\n      if (!elementCache || !updateOption) {\n        return;\n      } // the follow binding should be in order for better efficiency\n      // apply forOf Binding\n\n\n      if (updateOption.forOfBinding && elementCache[bindingAttrs.forOf] && elementCache[bindingAttrs.forOf].length) {\n        elementCache[bindingAttrs.forOf].forEach(cache => {\n          forOfBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n      } // apply attr Binding\n\n\n      if (updateOption.attrBinding && elementCache[bindingAttrs.attr] && elementCache[bindingAttrs.attr].length) {\n        elementCache[bindingAttrs.attr].forEach(cache => {\n          attrBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n      } // apply if Binding\n\n\n      if (updateOption.ifBinding && elementCache[bindingAttrs.if] && elementCache[bindingAttrs.if].length) {\n        elementCache[bindingAttrs.if].forEach(cache => {\n          ifBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n      } // apply show Binding\n\n\n      if (updateOption.showBinding && elementCache[bindingAttrs.show] && elementCache[bindingAttrs.show].length) {\n        elementCache[bindingAttrs.show].forEach(cache => {\n          showBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n      } // apply switch Binding\n\n\n      if (updateOption.switchBinding && elementCache[bindingAttrs.switch] && elementCache[bindingAttrs.switch].length) {\n        elementCache[bindingAttrs.switch].forEach(cache => {\n          switchBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n      } // apply text binding\n\n\n      if (updateOption.textBinding && elementCache[bindingAttrs.text] && elementCache[bindingAttrs.text].length) {\n        elementCache[bindingAttrs.text].forEach(cache => {\n          textBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n      } // apply cssBinding\n\n\n      if (updateOption.cssBinding && elementCache[bindingAttrs.css] && elementCache[bindingAttrs.css].length) {\n        elementCache[bindingAttrs.css].forEach(cache => {\n          cssBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n      } // apply model binding\n\n\n      if (updateOption.modelBinding && elementCache[bindingAttrs.model] && elementCache[bindingAttrs.model].length) {\n        elementCache[bindingAttrs.model].forEach(cache => {\n          modelBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n      } // apply change binding\n\n\n      if (updateOption.changeBinding && elementCache[bindingAttrs.change] && elementCache[bindingAttrs.change].length) {\n        elementCache[bindingAttrs.change].forEach(cache => {\n          changeBinding({\n            bindingAttrs,\n            cache,\n            forceRender: updateOption.forceRender,\n            type: 'change',\n            viewModel\n          });\n        });\n      } // apply submit binding\n\n\n      if (updateOption.submitBinding && elementCache[bindingAttrs.submit] && elementCache[bindingAttrs.submit].length) {\n        elementCache[bindingAttrs.submit].forEach(cache => {\n          createEventBinding({\n            cache,\n            forceRender: updateOption.forceRender,\n            type: 'submit',\n            viewModel\n          });\n        });\n      } // apply click binding\n\n\n      if (updateOption.clickBinding && elementCache[bindingAttrs.click] && elementCache[bindingAttrs.click].length) {\n        elementCache[bindingAttrs.click].forEach(cache => {\n          createEventBinding({\n            cache,\n            forceRender: updateOption.forceRender,\n            type: 'click',\n            viewModel\n          });\n        });\n      } // apply double click binding\n\n\n      if (updateOption.dblclickBinding && elementCache[bindingAttrs.dblclick] && elementCache[bindingAttrs.dblclick].length) {\n        elementCache[bindingAttrs.dblclick].forEach(cache => {\n          createEventBinding({\n            cache,\n            forceRender: updateOption.forceRender,\n            type: 'dblclick',\n            viewModel\n          });\n        });\n      } // apply blur binding\n\n\n      if (updateOption.blurBinding && elementCache[bindingAttrs.blur] && elementCache[bindingAttrs.blur].length) {\n        elementCache[bindingAttrs.blur].forEach(cache => {\n          createEventBinding({\n            cache,\n            forceRender: updateOption.forceRender,\n            type: 'blur',\n            viewModel\n          });\n        });\n      } // apply focus binding\n\n\n      if (updateOption.focusBinding && elementCache[bindingAttrs.focus] && elementCache[bindingAttrs.focus].length) {\n        elementCache[bindingAttrs.focus].forEach(cache => {\n          createEventBinding({\n            cache,\n            forceRender: updateOption.forceRender,\n            type: 'focus',\n            viewModel\n          });\n        });\n      } // apply hover binding\n\n\n      if (updateOption.hoverBinding && elementCache[bindingAttrs.hover] && elementCache[bindingAttrs.hover].length) {\n        elementCache[bindingAttrs.hover].forEach(cache => {\n          hoverBinding(cache, viewModel, bindingAttrs, updateOption.forceRender);\n        });\n      } // apply input binding - eg html range input\n\n\n      if (updateOption.inputBinding && elementCache[bindingAttrs.input] && elementCache[bindingAttrs.input].length) {\n        elementCache[bindingAttrs.input].forEach(cache => {\n          changeBinding({\n            bindingAttrs,\n            cache,\n            forceRender: updateOption.forceRender,\n            type: 'input',\n            viewModel\n          });\n        });\n      }\n    }\n\n    function postProcess(tasks) {\n      if (!tasks || !tasks.length) {\n        return;\n      }\n\n      each(tasks, (index, task) => {\n        if (typeof task === 'function') {\n          try {\n            task();\n          } catch (err) {\n            throwErrorMessage(err, 'Error postProcess: ' + String(task));\n          }\n        }\n      });\n    }\n\n    /**\n     *  pubSub\n     * @description use jQuery object as pubSub\n     * @example EVENTS object strucure:\n     *  EVENTS = {\n            'EVENT-NAME': [{ 'comp-id': fn }],\n            'EVENT-NAME2': [{ 'comp-id': fn }]\n        };\n     */\n\n    const EVENTS = {};\n\n    const subscribeEvent = (instance = null, eventName = '', fn, isOnce = false) => {\n      if (!instance || !instance.compId || !eventName || typeof fn !== 'function') {\n        return;\n      }\n\n      let subscriber;\n      let isSubscribed = false;\n      eventName = eventName.replace(REGEX.WHITE_SPACES, '');\n      EVENTS[eventName] = EVENTS[eventName] || []; // check if already subscribed and update callback fn\n\n      isSubscribed = EVENTS[eventName].some(subscriber => {\n        if (subscriber[instance.compId]) {\n          subscriber[instance.compId] = fn.bind(instance.viewModel);\n          subscriber.isOnce = isOnce;\n          return true;\n        }\n      }); // push if not yet subscribe\n\n      if (!isSubscribed) {\n        subscriber = {};\n        subscriber[instance.compId] = fn.bind(instance.viewModel);\n        subscriber.isOnce = isOnce;\n        EVENTS[eventName].push(subscriber);\n      }\n    };\n\n    const subscribeEventOnce = (instance = null, eventName = '', fn) => {\n      subscribeEvent(instance, eventName, fn, true);\n    };\n\n    const unsubscribeEvent = (compId = '', eventName = '') => {\n      if (!compId || !eventName) {\n        return;\n      }\n\n      let i = 0;\n      let subscribersLength = 0;\n      let subscriber;\n      eventName = eventName.replace(REGEX.WHITE_SPACES, '');\n\n      if (EVENTS[eventName]) {\n        subscribersLength = EVENTS[eventName].length;\n\n        for (i = 0; i < subscribersLength; i += 1) {\n          subscriber = EVENTS[eventName][i];\n\n          if (subscriber[compId]) {\n            EVENTS[eventName].splice(i, 1);\n            break;\n          }\n        }\n      } // delete the event if no more subscriber\n\n\n      if (!EVENTS[eventName].length) {\n        delete EVENTS[eventName];\n      }\n    };\n    /**\n     * unsubscribeAllEvent\n     * @description unsubscribe all event by compId. eg when a component removed\n     * @param {string} compId\n     */\n\n\n    const unsubscribeAllEvent = (compId = '') => {\n      if (!compId) {\n        return;\n      }\n\n      Object.keys(EVENTS).forEach(eventName => {\n        unsubscribeEvent(compId, eventName);\n      });\n    };\n\n    const publishEvent = (eventName = '', ...args) => {\n      if (!eventName || !EVENTS[eventName]) {\n        return;\n      }\n\n      eventName = eventName.replace(REGEX.WHITE_SPACES, '');\n      EVENTS[eventName].forEach(subscriber => {\n        Object.keys(subscriber).forEach(compId => {\n          if (typeof subscriber[compId] === 'function') {\n            const ret = subscriber[compId](...args);\n\n            if (subscriber.isOnce) {\n              unsubscribeEvent(compId, eventName);\n            }\n\n            return ret;\n          }\n        });\n      });\n    };\n\n    let compIdIndex = 0;\n\n    class Binder {\n      constructor($rootElement, viewModel, bindingAttrs) {\n        if (!$rootElement || $rootElement.nodeType !== 1 || viewModel === null || typeof viewModel !== 'object') {\n          throw new TypeError('$rootElement or viewModel is invalid');\n        }\n\n        this.initRendered = false;\n        this.compId = compIdIndex += 1;\n        this.$rootElement = $rootElement;\n        this.viewModel = viewModel;\n        this.bindingAttrs = bindingAttrs;\n        this.render = debounceRaf(this.render, this);\n        this.isServerRendered = this.$rootElement.getAttribute(serverRenderedAttr) !== null; // inject instance into viewModel\n\n        this.viewModel.APP = this; // add $root pointer to viewModel so binding can be refer as $root.something\n\n        this.viewModel.$root = this.viewModel; // 1st step\n        // parsView walk the DOM and create binding cache that holds each element's binding details\n        // this binding cache is like AST for render and update\n\n        this.parseView(); // for jquery user set viewModel referece to $rootElement for easy debug\n        // otherwise use Expando to attach viewModel to $rootElement\n\n        this.$rootElement[bindingDataReference.rootDataKey] = this.viewModel;\n        return this;\n      }\n      /**\r\n       * parseView\r\n       * @description\r\n       * @return {this}\r\n       * traver from $rootElement to find each data-bind-* element\r\n       * then apply data binding\r\n       */\n\n\n      parseView() {\n        this.elementCache = createBindingCache({\n          rootNode: this.$rootElement,\n          bindingAttrs: this.bindingAttrs\n        }); // updateElementCache if server rendered on init\n\n        if (this.isServerRendered && !this.initRendered) {\n          this.updateElementCache({\n            templateCache: true\n          });\n        }\n\n        return this;\n      }\n      /**\r\n       * updateElementCache\r\n       * @param {object} opt\r\n       * @description call createBindingCache to parse view and generate bindingCache\r\n       */\n\n\n      updateElementCache(opt = {}) {\n        const elementCache = opt.elementCache || this.elementCache;\n\n        if (opt.allCache) {\n          // walk dom from root element to regenerate elementCache\n          this.elementCache = createBindingCache({\n            rootNode: this.$rootElement,\n            bindingAttrs: this.bindingAttrs\n          });\n        } // walk from first rendered template node to create/update child bindingCache\n\n\n        if (opt.allCache || opt.templateCache) {\n          if (elementCache[this.bindingAttrs.tmp] && elementCache[this.bindingAttrs.tmp].length) {\n            elementCache[this.bindingAttrs.tmp].forEach(cache => {\n              // set skipCheck as skipForOfParseFn whenever an node has\n              // both template and forOf bindings\n              // then the template bindingCache should be an empty object\n              let skipForOfParseFn = null;\n\n              if (cache.el.hasAttribute(this.bindingAttrs.forOf)) {\n                skipForOfParseFn = () => {\n                  return true;\n                };\n              }\n\n              cache.bindingCache = createBindingCache({\n                rootNode: cache.el,\n                bindingAttrs: this.bindingAttrs,\n                skipCheck: skipForOfParseFn,\n                isRenderedTemplate: opt.isRenderedTemplates\n              });\n            });\n          }\n        }\n      }\n\n      render(opt = {}) {\n        let updateOption = {};\n\n        if (!this.initRendered) {\n          // only update eventsBinding if server rendered\n          if (this.isServerRendered) {\n            this.$rootElement.removeAttribute(serverRenderedAttr);\n            updateOption = createBindingOption(bindingUpdateConditions.serverRendered, opt);\n          } else {\n            updateOption = createBindingOption(bindingUpdateConditions.init, opt);\n          }\n        } else {\n          // when called again only update visualBinding options\n          updateOption = createBindingOption('', opt);\n        } // create postProcessQueue before start rendering\n\n\n        this.postProcessQueue = [];\n        const renderBindingOption = {\n          ctx: this,\n          elementCache: this.elementCache,\n          updateOption: updateOption,\n          bindingAttrs: this.bindingAttrs,\n          viewModel: this.viewModel\n        }; // always render template binding first\n        // render and apply binding to template(s)\n        // this is an share function therefore passing 'this' context\n\n        renderTemplatesBinding(renderBindingOption); // apply bindings to rest of the DOM\n\n        applyBinding(renderBindingOption); // trigger postProcess\n\n        postProcess(this.postProcessQueue); // clear postProcessQueue\n\n        this.postProcessQueue.length = 0;\n        delete this.postProcessQueue;\n        this.initRendered = true;\n      }\n\n      subscribe(eventName = '', fn) {\n        subscribeEvent(this, eventName, fn);\n        return this;\n      }\n\n      subscribeOnce(eventName = '', fn) {\n        subscribeEventOnce(this, eventName, fn);\n        return this;\n      }\n\n      unsubscribe(eventName = '') {\n        unsubscribeEvent(this.compId, eventName);\n        return this;\n      }\n\n      unsubscribeAll() {\n        unsubscribeAllEvent(this.compId);\n        return this;\n      }\n\n      publish(eventName = '', ...args) {\n        publishEvent(eventName, ...args);\n        return this;\n      }\n\n    }\n\n    const isSupportPromise = typeof window['Promise'] === 'function';\n    let bindingAttrs = bindingAttrs$1;\n\n    const use = (settings = {}) => {\n      if (settings.bindingAttrs) {\n        bindingAttrs = extend({}, settings.bindingAttrs);\n      }\n    };\n\n    const init = ($rootElement, viewModel = null) => {\n      if (!isSupportPromise) {\n        return console.warn('Browser not support Promise');\n      }\n\n      return new Binder($rootElement, viewModel, bindingAttrs);\n    };\n\n    var index = {\n      use: use,\n      init: init,\n      version: '1.12.0'\n    };\n\n    return index;\n\n})));\n"]}